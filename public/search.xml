<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + GitHub Pages搭建个人博客</title>
    <url>/2021/09/16/Hexo-GitHubPages/</url>
    <content><![CDATA[<center>本博客搭建过程中参考了许多教程。本文用于记录搭建过程，以及出现的一些小问题</center>  
<span id="more"></span>  

<br>  
<br>  

<p>有需要学习搭建博客的朋友可直接参考他人成熟的教程。本文参考教程：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/70240127">Hexo+Github Pages快速实现个人网站</a><br> 搭建流程较为清晰，整体框架都有，不想详细了解每一个步骤只是想成功搭建一个博客参考这个教程就够</li>
<li><a href="https://juejin.cn/post/6844904131266609165">彻底搞懂如何使用Hexo+GitHubPages搭建个人博客</a><br> 对于各种概念的解释都很详细，能够学习到很多知识，有助于未来对博客进行魔改升级等高级操作</li>
<li><a href="https://hexo.io/zh-cn/docs/">Hexo官方说明文档</a><br> Hexo官方说明文档，目前更新版本为1/9/2021。内容步骤简洁明了，跟着一步步做不会出大的差错，如有问题也可以直接提交</li>
<li><a href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site">GitHub Pages官方说明文档</a><br> GitHub Pages官方说明文档，参考性不如前面三个链接，但也能提供一部分支持。</li>
</ol>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Mac和Linux系统的电脑已经预装了git.<br>Windows系统的电脑可以从官网(<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> )下载相应的版本，安装过程中选择默认选项即可。<br>由于之前简单使用过gitee加git存代码，git的配置在当初已经完成。搜索“git使用”能够找到很多有用的教程。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>可从官网 (<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>)直接下载安装，可根据需求下载最新版本或推荐版本。需要注意的是，目前Hexo官网给出的建议是Node.js版本需不低于10.13，建议使用Node.js 12.0及以上版本。此处下载了Nodejs官网的推荐版本(recommended for most users)，14.17.6 LTS.<br>由于对Node.js并不了解，安装过程中直接选择了Automatically install the necessary tools.如果想更深入了解安装过程及自定义安装，可参考官方给出的详细安装教程(<a href="https://github.com/nodejs/node-gyp#on-windows">https://github.com/nodejs/node-gyp#on-windows</a>)</p>
<h3 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h3><h4 id="检查Git和node-js安装情况"><a href="#检查Git和node-js安装情况" class="headerlink" title="检查Git和node.js安装情况"></a>检查Git和node.js安装情况</h4><p>安装Hexo需要git和node.js安装完成。检查电脑中这两项安装完成后，即可安装Hexo。可使用查看版本来检查是否安装成功。  </p>
<pre><code>$ npm -v  
$ node -v  
$ git --version  
</code></pre>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>上述安装成功后，只需要使用npm即可完成Hexo的安装  </p>
<pre><code>$ npm install -g hexo-cli  
</code></pre>
<p>对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包  </p>
<pre><code>$ npm install hexo
</code></pre>
<h4 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h4><p>依然使用查看版本号的方式检查安装是否成功，运行命令：  </p>
<pre><code>$ hexo - v
</code></pre>
<h4 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h4><pre><code>$ hexo init &lt;blogname&gt; #此处blogname可以自己起名字，此步要在空目录下进行
$ cd blog  #进入blog目录
$ npm install  #它会根据package.json依赖配置文件自动下载安装所需要的依赖模块node_modules
$ hexo generate  #生成静态文件, 缩写 $ hexo g
$ hexo server  #开启本地服务, 此时通过 http://localhost:4000 就可以访问默认样式的博客, 缩写$ hexo s
</code></pre>
<h4 id="小小的Debug"><a href="#小小的Debug" class="headerlink" title="小小的Debug"></a>小小的Debug</h4><p>安装时，显示在resolveNewModule步骤耗时很久，不知道是卡住还是这个步骤本就耗费时间。<br>Google找到Hexo的官方说明文档(<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a>)，其中提到安装只需要几分钟，并且这个几分钟可能包含前述的Git和Node.js的准备。因此意识到安装出现问题，直接停下此次安装并重新运行命令。<br>出现问题的原因可能是安装的同时在下载一个较大的文件，无论是内存占用还是网络占用都达到一定程度，使得Hexo的安装受到影响。二次运行命令行时，下载已经结束，只用时51s就完成安装。<br>多翻了几个教程，很多教程都有提到新建文件夹Hexo，在这个目录下安装Hexo。因此卸载Hexo，在目标位置建立文件夹重装。卸载命令：  </p>
<pre><code>$ npm uninstall hexo-cli -g
</code></pre>
<p>这次安装同样比较顺利，很快就完成。<br>实际上，如果在安装前没有建立文件夹，只需在安装成功后建立一个新目录，后续步骤在这个空目录下进行即可。上述uninstall步骤是因为比较心急，直接推翻重来，但没有必要。</p>
<h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><h3 id="git初始配置"><a href="#git初始配置" class="headerlink" title="git初始配置"></a>git初始配置</h3><p>Git安装完成后确认是否完成基本部署，用户名和邮箱设置是否完成。  </p>
<pre><code>$ git config --global user.name &quot;YOUR NAME&quot;  #设置用户名称
$ git config --global user.email &quot;YOUR EMAIL&quot;  #设置邮箱地址
</code></pre>
<h3 id="生成SSH-key公钥"><a href="#生成SSH-key公钥" class="headerlink" title="生成SSH key公钥"></a>生成SSH key公钥</h3><p>查看当前用户的目录下是否存在.ssh目录，如果存在进入到此目录下检查是否存在id_rsa和id_rsa.pub两个文件，这两个文件分别对应的是公钥和私钥，如果存在直接跳过此步，否则输入下面的命令：  </p>
<pre><code>$ ssh-keygen -t rsa -C “your_github_email”
# -t type:指定你要生成的密钥类型
# -C commit:提供一个新的注释  
</code></pre>
<p>然后一路回车，直到生成一个矩形的图案为止。记下生成的这串字符，这就是后面需要给GitHub配置的公钥。</p>
<h3 id="创建GitHub账号"><a href="#创建GitHub账号" class="headerlink" title="创建GitHub账号"></a>创建GitHub账号</h3><p>打开官网用邮箱一步步注册即可，仅有的两个可能遇到的问题:</p>
<ul>
<li>没想好用户名</li>
<li>确认注册的邮件因为有链接可能会被当作垃圾邮件。</li>
</ul>
<h3 id="配置GitHub中的公钥"><a href="#配置GitHub中的公钥" class="headerlink" title="配置GitHub中的公钥"></a>配置GitHub中的公钥</h3><p>在GitHub账号设置中找到添加SSH key的地方，即<br>Settings -&gt; SSH and GPG keys -&gt; New SSH key<br>将前述步骤中生成的公钥贴在此处  </p>
<h3 id="创建仓库-repository"><a href="#创建仓库-repository" class="headerlink" title="创建仓库(repository)"></a>创建仓库(repository)</h3><p>单机右上角(用户头像旁边)的“+”号即可创建New repository，会出现如图所示界面。<br>Owner处为用户名，后面的Repository name需要严格按照username.github.io填写。这样才能保证生成的是GitHub Pages页面，而不是其它代码库。  </p>
<h3 id="GitHub-Pages-1"><a href="#GitHub-Pages-1" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><p>创建成功后会自动进入该repository，进入setting找到Pages，进入后即可看到GitHub Pages界面。<br>这一步骤可能需要一些时间，耐心等待，一般几分钟就会显示站点发布成功。</p>
<h4 id="小小的debug"><a href="#小小的debug" class="headerlink" title="小小的debug"></a>小小的debug</h4><p>第一次走到这一步时，此处有一句提醒，由于该GitHub仓库是空的，所以无法创建GitHub Pages站点。解决方式： </p>
<ul>
<li>可自己创建一个README文件</li>
<li>粗暴删库重来，建库时选择生成默认README文件  </li>
</ul>
<h2 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h2><h3 id="安装hexo-deployer-git"><a href="#安装hexo-deployer-git" class="headerlink" title="安装hexo-deployer-git"></a>安装hexo-deployer-git</h3><p>在博客根目录下运行命令  </p>
<pre><code>$ npm install hexo-deployer-git –save
</code></pre>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>_config.yml是整个博客的配置文件，每项配置参数在Hexo官方文档可找到详细介绍。<br>使用git能将本地博客文件夹关联到GitHub的远程仓库，并把本地文件push到对应的仓库中。Hexo提供了一种更简便地方式，只需要在_config.yml中作相应的配置，通过命令行命令就可以很方便地把静态文件部署到对应的仓库中。<br>找到根目录中的_config.yml博客配置文件，在deployment配置项下设置如下参数：  </p>
<pre><code>deploy:  
    type: git  
    repo: git@github.com:yourname/yourname.github.io.git  
    branch: master  
</code></pre>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre><code>$ hexo generate #生成本地静态文件，可缩写为hexo g
$ hexo deploy   #部署，可缩写为hexo d
</code></pre>
<p>这时回到GitHub仓库, 可以看到网站的静态文件已经上传。</p>
<h4 id="小小的Debug-1"><a href="#小小的Debug-1" class="headerlink" title="小小的Debug"></a>小小的Debug</h4><p>部署没有报错，但网站没有更新<br>原因：GitHub Pages默认是从main生成页面，但本地设置部署参数是branch一项中填写的是master<br>Debug：修改该repository设置中pages的source一项或将前面提到的修改博客配置文件的branch参数为main</p>
<h3 id="一些有用的命令"><a href="#一些有用的命令" class="headerlink" title="一些有用的命令"></a>一些有用的命令</h3><pre><code>hexo clean = hexo c #清除本地缓存，也就是清除public/文件夹和db.json文件
hexo generate = hexo g #将souce文件夹下的Markdown和HTML文件解析到了public文件夹下，并生成了db.json文件
hexo server = hexo s #开启本地调试模式
hexo deploy = hexo d #将本地资源部署到GithubPages
</code></pre>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><p>Hexo的官网上即可找到许多可用主题，或搜索Hexo theme也可以找到。官网中列出的主题直达：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>找主题除了符合自己的审美之外，也要注意该主题是否一直有人维护。较长时间无人维护的主题可能由于版本问题无法顺利安装使用。</p>
<h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>本博客选择的主题是Next，安装步骤如下：<br>将主题clone到theme文件夹下</p>
<pre><code>$ cd blog
$ git clone https://github.com/next-theme/hexo-theme-next themes/next
</code></pre>
<p>然后在hexo配置文件中修改themes为next</p>
<pre><code>themes: next
</code></pre>
<h3 id="一些小改动"><a href="#一些小改动" class="headerlink" title="一些小改动"></a>一些小改动</h3><p>根据next的说明文件，可以在该主题的配置文件中对细节进行修改。<br>对博客名、描述以及作者等的修改在根目录的配置文件中进行。</p>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Building</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>blastp的本地化使用</title>
    <url>/2021/09/16/blastp/</url>
    <content><![CDATA[<center>blastp在Windows系统电脑上的本地使用</center>
<span id="more"></span>

<h2 id="下载blast到本地"><a href="#下载blast到本地" class="headerlink" title="下载blast到本地"></a>下载blast到本地</h2><p>在NCBI官网找到blast工具即可找到下载链接，根据提示一步步完成下载即可。<br>官网下载链接：<a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web&PAGE_TYPE=BlastDocs&DOC_TYPE=Download">blast tools</a><br>网站打开速度较慢，挂梯可能会好一点。</p>
<h2 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p>从uniprot下载所需参考蛋白质组的fast.a文件作为建库文件此处以人类蛋白质组为例  </p>
<pre><code>$ makeblastdb -in uniprot-proteome%3AUP000005640.fasta -dbtype prot -parse_seqids -hash_index -out human
# 在blast-2.6.0/bin文件夹下运行该命令或在makeblastdb前加上该程序所在的路径

# 参数说明
# -in 所需建库的参考蛋白质组
# -out 输出的库名
# -dbtype 蛋白质组用prot，核酸组用nucl
# parse_seqids =&gt; Parse Seq-ids in FASTA input
# -hash_index =&gt; Create index of sequence hash values
</code></pre>
<h3 id="搜库比对"><a href="#搜库比对" class="headerlink" title="搜库比对"></a>搜库比对</h3><p>将query序列比对到参考序列。此处用小鼠蛋白质组和人蛋白质组进行比对，运行如下命令：</p>
<pre><code>$ blastp.exe -query uniprot-proteome%3AUP000000589.fasta -db human -evalue 1e-3 -out blast.xml -outfmt &quot;5&quot; -num_alignments 10 -num_threads 2
#在blast-2.6.0/bin文件夹下运行该命令或在blastp.exe前加上该程序所在的路径

# 参数说明
# -query 输入文件名，也就是需要比对的序列文件
# -db 格式化后的数据库名称
# -evalue 设定输出结果中的e-value阈值
# -out 输出文件名
# -num_alignments 输出比对上的序列的最大值条目数
# -num_threads 线程数
# 此外还有：
# -num_descriptions 对比对上序列的描述信息，一般跟tabular格式连用
# -outfmt
#   0 = pairwise,
#   1 = query-anchored showing identities,
#   2 = query-anchored no identities,
#   3 = flat query-anchored, show identities,
#   4 = flat query-anchored, no identities,
#   5 = XML Blast output,
#   6 = tabular,
#   7 = tabular with comment lines,
#   8 = Text ASN.1,
#   9 = Binary ASN.1
#  10 = Comma-separated values
</code></pre>
<h3 id="提取搜库结果中的信息"><a href="#提取搜库结果中的信息" class="headerlink" title="提取搜库结果中的信息"></a>提取搜库结果中的信息</h3><h2 id="xml文件所含的信息"><a href="#xml文件所含的信息" class="headerlink" title="xml文件所含的信息"></a>xml文件所含的信息</h2><p>使用outfmt 5参数的话，会产生一个xml格式的文件，对比信息很完整。一个序列的完整比对信息如下所示：</p>
<pre><code>&lt;Iteration&gt;
&lt;Iteration_iter-num&gt;1&lt;/Iteration_iter-num&gt;
&lt;Iteration_query-ID&gt;Query_1&lt;/Iteration_query-ID&gt;
&lt;Iteration_query-def&gt;sp|Q62302|TX261_MOUSE Protein TEX261 OS=Mus musculus OX=10090 GN=Tex261 PE=2 SV=1&lt;/Iteration_query-def&gt;
&lt;Iteration_query-len&gt;196&lt;/Iteration_query-len&gt;
&lt;Iteration_hits&gt;
&lt;Hit&gt;
&lt;Hit_num&gt;1&lt;/Hit_num&gt;
&lt;Hit_id&gt;sp|Q6UWH6|TX261_HUMAN&lt;/Hit_id&gt;
&lt;Hit_def&gt;Protein TEX261 OS=Homo sapiens OX=9606 GN=TEX261 PE=2 SV=1&lt;/Hit_def&gt;
&lt;Hit_accession&gt;Q6UWH6&lt;/Hit_accession&gt;
&lt;Hit_len&gt;196&lt;/Hit_len&gt;
&lt;Hit_hsps&gt;
  &lt;Hsp&gt;
    &lt;Hsp_num&gt;1&lt;/Hsp_num&gt;
    &lt;Hsp_bit-score&gt;391.734&lt;/Hsp_bit-score&gt;
    &lt;Hsp_score&gt;1005&lt;/Hsp_score&gt;
    &lt;Hsp_evalue&gt;8.09539e-141&lt;/Hsp_evalue&gt;
    &lt;Hsp_query-from&gt;1&lt;/Hsp_query-from&gt;
    &lt;Hsp_query-to&gt;196&lt;/Hsp_query-to&gt;
    &lt;Hsp_hit-from&gt;1&lt;/Hsp_hit-from&gt;
    &lt;Hsp_hit-to&gt;196&lt;/Hsp_hit-to&gt;
    &lt;Hsp_query-frame&gt;0&lt;/Hsp_query-frame&gt;
    &lt;Hsp_hit-frame&gt;0&lt;/Hsp_hit-frame&gt;
    &lt;Hsp_identity&gt;195&lt;/Hsp_identity&gt;
    &lt;Hsp_positive&gt;196&lt;/Hsp_positive&gt;
    &lt;Hsp_gaps&gt;0&lt;/Hsp_gaps&gt;
    &lt;Hsp_align-len&gt;196&lt;/Hsp_align-len&gt;
    &lt;Hsp_qseq&gt;MWFMYVLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPGDDVVSNYFTKGKRGKRLGILVVFSFIKEAILPSRQKIY&lt;/Hsp_qseq&gt;
    &lt;Hsp_hseq&gt;MWFMYLLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPGDDVVSNYFTKGKRGKRLGILVVFSFIKEAILPSRQKIY&lt;/Hsp_hseq&gt;
    &lt;Hsp_midline&gt;MWFMY+LSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPGDDVVSNYFTKGKRGKRLGILVVFSFIKEAILPSRQKIY&lt;/Hsp_midline&gt;
  &lt;/Hsp&gt;
&lt;/Hit_hsps&gt;
&lt;/Hit&gt;
&lt;Hit&gt;
&lt;Hit_num&gt;2&lt;/Hit_num&gt;
&lt;Hit_id&gt;tr|U3KQ87|U3KQ87_HUMAN&lt;/Hit_id&gt;
&lt;Hit_def&gt;Uncharacterized protein OS=Homo sapiens OX=9606 PE=4 SV=1&lt;/Hit_def&gt;
&lt;Hit_accession&gt;U3KQ87&lt;/Hit_accession&gt;
&lt;Hit_len&gt;197&lt;/Hit_len&gt;
&lt;Hit_hsps&gt;
  &lt;Hsp&gt;
    &lt;Hsp_num&gt;1&lt;/Hsp_num&gt;
    &lt;Hsp_bit-score&gt;312.768&lt;/Hsp_bit-score&gt;
    &lt;Hsp_score&gt;800&lt;/Hsp_score&gt;
    &lt;Hsp_evalue&gt;1.35723e-109&lt;/Hsp_evalue&gt;
    &lt;Hsp_query-from&gt;1&lt;/Hsp_query-from&gt;
    &lt;Hsp_query-to&gt;158&lt;/Hsp_query-to&gt;
    &lt;Hsp_hit-from&gt;1&lt;/Hsp_hit-from&gt;
    &lt;Hsp_hit-to&gt;158&lt;/Hsp_hit-to&gt;
    &lt;Hsp_query-frame&gt;0&lt;/Hsp_query-frame&gt;
    &lt;Hsp_hit-frame&gt;0&lt;/Hsp_hit-frame&gt;
    &lt;Hsp_identity&gt;157&lt;/Hsp_identity&gt;
    &lt;Hsp_positive&gt;158&lt;/Hsp_positive&gt;
    &lt;Hsp_gaps&gt;0&lt;/Hsp_gaps&gt;
    &lt;Hsp_align-len&gt;158&lt;/Hsp_align-len&gt;
    &lt;Hsp_qseq&gt;MWFMYVLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPG&lt;/Hsp_qseq&gt;
    &lt;Hsp_hseq&gt;MWFMYLLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPG&lt;/Hsp_hseq&gt;
    &lt;Hsp_midline&gt;MWFMY+LSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPG&lt;/Hsp_midline&gt;
  &lt;/Hsp&gt;
&lt;/Hit_hsps&gt;
&lt;/Hit&gt;
&lt;Hit&gt;
&lt;Hit_num&gt;3&lt;/Hit_num&gt;
&lt;Hit_id&gt;tr|F8WAR8|F8WAR8_HUMAN&lt;/Hit_id&gt;
&lt;Hit_def&gt;Protein TEX261 OS=Homo sapiens OX=9606 GN=TEX261 PE=4 SV=1&lt;/Hit_def&gt;
&lt;Hit_accession&gt;F8WAR8&lt;/Hit_accession&gt;
&lt;Hit_len&gt;51&lt;/Hit_len&gt;
&lt;Hit_hsps&gt;
  &lt;Hsp&gt;
    &lt;Hsp_num&gt;1&lt;/Hsp_num&gt;
    &lt;Hsp_bit-score&gt;98.5969&lt;/Hsp_bit-score&gt;
    &lt;Hsp_score&gt;244&lt;/Hsp_score&gt;
    &lt;Hsp_evalue&gt;4.07837e-27&lt;/Hsp_evalue&gt;
    &lt;Hsp_query-from&gt;1&lt;/Hsp_query-from&gt;
    &lt;Hsp_query-to&gt;50&lt;/Hsp_query-to&gt;
    &lt;Hsp_hit-from&gt;1&lt;/Hsp_hit-from&gt;
    &lt;Hsp_hit-to&gt;50&lt;/Hsp_hit-to&gt;
    &lt;Hsp_query-frame&gt;0&lt;/Hsp_query-frame&gt;
    &lt;Hsp_hit-frame&gt;0&lt;/Hsp_hit-frame&gt;
    &lt;Hsp_identity&gt;49&lt;/Hsp_identity&gt;
    &lt;Hsp_positive&gt;50&lt;/Hsp_positive&gt;
    &lt;Hsp_gaps&gt;0&lt;/Hsp_gaps&gt;
    &lt;Hsp_align-len&gt;50&lt;/Hsp_align-len&gt;
    &lt;Hsp_qseq&gt;MWFMYVLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_qseq&gt;
    &lt;Hsp_hseq&gt;MWFMYLLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_hseq&gt;
    &lt;Hsp_midline&gt;MWFMY+LSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_midline&gt;
  &lt;/Hsp&gt;
&lt;/Hit_hsps&gt;
&lt;/Hit&gt;
&lt;Hit&gt;
&lt;Hit_num&gt;4&lt;/Hit_num&gt;
&lt;Hit_id&gt;tr|U3KQC7|U3KQC7_HUMAN&lt;/Hit_id&gt;
&lt;Hit_def&gt;Uncharacterized protein (Fragment) OS=Homo sapiens OX=9606 PE=4 SV=1&lt;/Hit_def&gt;
&lt;Hit_accession&gt;U3KQC7&lt;/Hit_accession&gt;
&lt;Hit_len&gt;49&lt;/Hit_len&gt;
&lt;Hit_hsps&gt;
  &lt;Hsp&gt;
    &lt;Hsp_num&gt;1&lt;/Hsp_num&gt;
    &lt;Hsp_bit-score&gt;91.2781&lt;/Hsp_bit-score&gt;
    &lt;Hsp_score&gt;225&lt;/Hsp_score&gt;
    &lt;Hsp_evalue&gt;2.69841e-24&lt;/Hsp_evalue&gt;
    &lt;Hsp_query-from&gt;4&lt;/Hsp_query-from&gt;
    &lt;Hsp_query-to&gt;50&lt;/Hsp_query-to&gt;
    &lt;Hsp_hit-from&gt;2&lt;/Hsp_hit-from&gt;
    &lt;Hsp_hit-to&gt;48&lt;/Hsp_hit-to&gt;
    &lt;Hsp_query-frame&gt;0&lt;/Hsp_query-frame&gt;
    &lt;Hsp_hit-frame&gt;0&lt;/Hsp_hit-frame&gt;
    &lt;Hsp_identity&gt;46&lt;/Hsp_identity&gt;
    &lt;Hsp_positive&gt;47&lt;/Hsp_positive&gt;
    &lt;Hsp_gaps&gt;0&lt;/Hsp_gaps&gt;
    &lt;Hsp_align-len&gt;47&lt;/Hsp_align-len&gt;
    &lt;Hsp_qseq&gt;MYVLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_qseq&gt;
    &lt;Hsp_hseq&gt;MYLLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_hseq&gt;
    &lt;Hsp_midline&gt;MY+LSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_midline&gt;
  &lt;/Hsp&gt;
&lt;/Hit_hsps&gt;
&lt;/Hit&gt;
&lt;/Iteration_hits&gt;
&lt;Iteration_stat&gt;
  &lt;Statistics&gt;
    &lt;Statistics_db-num&gt;95943&lt;/Statistics_db-num&gt;
    &lt;Statistics_db-len&gt;38082498&lt;/Statistics_db-len&gt;
    &lt;Statistics_hsp-len&gt;101&lt;/Statistics_hsp-len&gt;
    &lt;Statistics_eff-space&gt;2697264225&lt;/Statistics_eff-space&gt;
    &lt;Statistics_kappa&gt;0.041&lt;/Statistics_kappa&gt;
    &lt;Statistics_lambda&gt;0.267&lt;/Statistics_lambda&gt;
    &lt;Statistics_entropy&gt;0.14&lt;/Statistics_entropy&gt;
  &lt;/Statistics&gt;
&lt;/Iteration_stat&gt;
&lt;/Iteration&gt;
</code></pre>
<h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>观察序列信息的各种标识，可从中提取有用的信息。下面是以julia语言写的一个简单粗暴提取比对上的两个蛋白(Accession)以及打分信息的脚本。</p>
<pre><code># Julia language
function main()
    ioBlast = open(&quot;blast.xml&quot;, &quot;r&quot;) 
    # 读BLAST结果
    ioBPout = open(&quot;blastresult.txt&quot;, &quot;w&quot;) 
    # 将提取的信息写入该文件
    # 自行选择方便后续步骤的文件格式
    
    write(ioBPout, &quot;Mouse\tHuman\tHsp_bit-score\thspscore\t&quot;) # 信息表头

    global Mouse_P, Human_P, bitscore, hspscore 
    # 声明变量为global，便于后续的步骤

    while !eof(ioBlast)
        # 按行读文件，若有所需信息则提取，没有则继续读取下一行
        line = readline(ioBlast)
        if occursin(r&quot;&lt;Iteration_query-def&gt;&quot;, line)
            (a, Mouse_P, c) = split(line, &quot;|&quot;)
        end
        if occursin(r&quot;&lt;Hit_id&gt;&quot;, line)
            (a, Human_P, c) = split(line, &quot;|&quot;)
        end
        if occursin(r&quot;&lt;Hsp_bit-score&gt;&quot;, line)
            (a, temps) = split(line, &quot;&gt;&quot;)
            (bitscore, c) = split(temps, &quot;&lt;&quot;)
        end
        if occursin(r&quot;&lt;Hsp_score&gt;&quot;, line)
            (a, temps) = split(line, &quot;&gt;&quot;)
            (hspscore, c) = split(temps, &quot;&lt;&quot;)
        end
        if occursin(r&quot;&lt;/Hit&gt;&quot;, line)
            write(ioBPout, Mouse_P, &quot;\t&quot;, Human_P, &quot;\t&quot;, bitscore, &quot;\t&quot;, hspscore, &quot;\n&quot;)
        end
    end

    close(ioBlast)
    close(ioBPout)            
end

main() # 运行上述函数
</code></pre>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="https://www.bioinfo-scrounger.com/archives/77/">BLAST本地化使用</a></li>
<li><a href="https://www.bioinfo-scrounger.com/archives/82/">Blast+ xml格式解读</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>BLAST</category>
      </categories>
      <tags>
        <tag>BLAST</tag>
      </tags>
  </entry>
  <entry>
    <title>Mastodon 建站笔记</title>
    <url>/2022/03/02/buildmastodon/</url>
    <content><![CDATA[<center> mastodon 建站笔记：慢慢来，6 月之前搞完就行；不要怕，不行就重启试试 </center>
<span id="more"></span>

<h2 id="一点说明"><a href="#一点说明" class="headerlink" title="一点说明"></a>一点说明</h2><p>本文所记录的搭建非常缓慢，开始于二月，但给自己设定的 DDL 在六月。搭建过程完全碎片化，每次推进都基于“这会儿没什么事情不如搞一搞建站”，且超过一小时就会先放着下次再说，非常随性随意。每一步完成于哪一天、大概耗时都有记录，给想搭建却又嫌麻烦、觉得需要特意安排时间的朋友提供一个佛系搭建参考。  </p>
<h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><p>参考：蓝盒子站长的<a href="https://pullopen.github.io/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/2020/10/19/Mastodon-on-Docker.html">利用 docker 搭建 Mastodon 实例</a>和塔塔的<a href="https://mantyke.icu/2021/mastodon-bulid/">小球飞象建站笔记</a>。  </p>
<p>感谢嘎嘎、塔塔和其他写下详细教程和笔记的朋友！因为你们和你们的教程，我这种没有参考不敢做事的人才能一点点把实例搭建起来。<br>特别感谢塔塔，给我每完成一步的嘟嘟点星星，给予我很大鼓励！  </p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>前期准备主要是花钱，大多数运营商都支持 Visa、MasterCard 或 PayPal，godaddy 支持支付宝付款。<br>为能有更多选择，个人建议开通 PayPal，比办信用卡方便一些。本文中除 Scaleway 以外，所有支付都通过 PayPal 完成。如使用 PayPal 付款，建议付款时直接使用目标货币，而不使用 PayPal 提供的转换为人民币付款。这种情况下付款使用的是银行汇率，会比 PayPal 划算。  </p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>常用的域名提供商很多，比如 <a href="https://www.namecheap.com/">NameCheap</a>，<a href="https://sg.godaddy.com/">godaddy</a> 和 <a href="https://www.dynadot.com/">dynadot</a>。可参考o3o站长给出的<a href="https://www.notion.so/c66e3332f4824f71b9d7d1dc8db410c7">域名选购指南</a>。<br>本站根据蓝盒子站长的推荐，在 NameCheap 购买域名。由于之前给博客换域名已经在 NameCheap 买过一次，而且很早就想好要买什么域名，所以这一步成为这个跨越几个月的搭建过程中最简单、最快速的一步。  </p>
<p>该步骤完成于 2022.02.17。约耗时 15 分钟，主要在犹豫到底要不要这天买，实际操作只用掉两三分钟。以及早知道我这么快就要自建站，博客就换个域名了！两年后我博客必换域名！</p>
<h3 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h3><p>使用 Zoho Mail 提供的 Business Mail 服务中的 Forever Free Plan。<br>由于本人需要很详细的操作步骤才敢进行下一步，这里找了个注册 Zoho Mail 的详细教程 —— <a href="https://www.dreambuildinglab.com/website-construction/email/how-to-register-free-zoho-business-email.html">注册zoho免费企业邮箱</a>。这个教程虽然详细，但稍微有点过时，有些操作的名称略有更改。如有需要，可再找其它教程参考。  </p>
<p>该步骤完成于 2022.02.21。约耗时 40 分钟，因为一些步骤没有明确的参考不太敢试，必须找到别人这一步怎么做才动手。但实际上没关系，大胆试，不行重来嘛！  </p>
<h3 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h3><p>选择 <a href="https://contabo.com/en/">Contabo</a> 购买 VPS，在购买前将价格修改为欧元，选择5欧套餐，德国服务器，一次性购买 12 个月，其它选项全部默认。<br>这里塔塔提醒<a href="https://mantyke.icu/2021/mastodon-bulid/#%E8%B4%AD%E4%B9%B0vps"> Contabo 审核严格</a>，最好真实 IP 购买，填写信息时不要太扯，不然会被要求提供身份证明。但我就是那个认真填写还被要求提供护照的倒霉蛋。由于目前和德国有 7 个小时时差，上午提供护照信息后，一直到下午四点多才收到确认邮件。  </p>
<p>该步骤完成于 2022.03.02。约耗时 15 分钟加 19 小时，15 分钟是实际需要操作的时间，包括提供护照信息；19 小时是由于买服务器时护照不在手边，第二天上午才回复，下午收到确认。  </p>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><p>这一部分参考<a href="https://pullopen.github.io/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/2020/10/19/Mastodon-on-Docker.html">蓝盒子站长教程</a>。  </p>
<ul>
<li><p>配置 ssh-key<br>首先查看电脑当前用户的目录下是否存在.ssh目录，以及目录中是否存在<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。如果存在，公钥即为<code>id_rsa.pub</code>中的内容。如果不存在，则输入命令：  </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “your_email”</span><br></pre></td></tr></table></figure>

<p>一路回车，直到生成一个矩形的图案为止，生成的这串字符就是后面需要的公钥。  </p>
<p>接下来的步骤全部按照蓝盒子站长的教程进行，但我遇到了一个愚蠢的问题，不会保存 nano 编辑的内容并退出。即使编辑器下方有两行提醒，也没能正确保存文件。万一有朋友和我一样，可参考以下保存并退出的方法：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ^ 为键盘上的 Ctrl 键，以下方法直接使用 Ctrl 代替</span><br><span class="line"># 退出，并根据提示保存</span><br><span class="line">Ctrl + X 退出，按 y 选择保存，提示 file name to write，利用上下左右键选择要保存到的文件，回车保存</span><br><span class="line"># 退出，并保存</span><br><span class="line">Ctrl + X 退出，按 y 选择保存，回车</span><br><span class="line"># 先保存，后退出</span><br><span class="line">Ctrl + O 并回车保存，Ctrl + X 退出</span><br></pre></td></tr></table></figure></li>
<li><p>安装常用命令和配置防火墙<br>直接照抄蓝盒子站长给的命令，都非常顺利。  </p>
</li>
</ul>
<p>该步骤完成于 2022.03.03。约耗时 55 分钟，主要由于不会保存 nano 编辑的内容，根据各种教程也总是保存失败。中途一度试图换回之前常用的 vim，但事实证明两年没用就会忘记一切。如果能顺利保存，这一步十分钟以内就可以完成。  </p>
<p><strong>tips</strong><br>虽然上次建站配置好了服务器端的公钥，但这次登录时，MobaXterm 一直返回错误信息：  </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disconnected: No supported authentication methods available (server sent: publickey)</span><br></pre></td></tr></table></figure>

<p>原因是服务器已经关闭账户密码登录，但使用 MobaXterm 登录时没有勾选 <code>Use private key</code> 并指定私钥文件。<br>具体步骤为 <code>Session -&gt; SSH -&gt; Use private key and specify a private key for passwordless login</code>。<br>设置完成后即可顺利登录。  </p>
<h3 id="安装-docker-和-docker-compose"><a href="#安装-docker-和-docker-compose" class="headerlink" title="安装 docker 和 docker-compose"></a>安装 docker 和 docker-compose</h3><p>根据蓝盒子站长的教程，使用官方提供的一键脚本安装 docker。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 代码来自蓝盒子站长教程</span><br><span class="line">bash &lt;(curl -L https://get.docker.com/)</span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>该步骤完成于 2022.03.13。约耗时 15 分钟，包括一开始登录不上服务器而查找原因的时间，实际操作时间约 3 分钟。这一步骤完成后可以通过命令 <code>docker-compose -h</code> 检查 docker 是否真的安装成功。  </p>
<h3 id="拉取-Mastodon-镜像-amp-初始化-PostgreSQL"><a href="#拉取-Mastodon-镜像-amp-初始化-PostgreSQL" class="headerlink" title="拉取 Mastodon 镜像 &amp; 初始化 PostgreSQL"></a>拉取 Mastodon 镜像 &amp; 初始化 PostgreSQL</h3><p>这几项全部根据蓝盒子站长 <a href="https://pullopen.github.io/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/2020/10/19/Mastodon-on-Docker.html">2022-04-25 修改的教程</a>进行。  </p>
<ul>
<li>拉取 Mastodon 镜像<br>直接复制粘贴代码，拉取版本为 <code>v3.5.1</code>，并修改 <code>docker-compose.yml</code> 配置文件。  </li>
<li>初始化 PostgreSQL<br>复制粘贴代码，并根据教程中的提醒检查代码运行情况。  </li>
</ul>
<p>该步骤完成于 2022.05.07。约耗时 20 分钟，大部分用于思考设个什么密码。以及如果太久没有建站，一定要先看看上一次都做了什么、用过什么命令，这次又因为忘记 <code>nano</code> 怎么退出而慌乱几秒。  </p>
<h3 id="配置-Mastodon"><a href="#配置-Mastodon" class="headerlink" title="配置 Mastodon"></a>配置 Mastodon</h3><p>这一步骤仍然按照蓝盒子站长的教程进行，根据教程一步步慢慢做，看仔细每一步都要填什么就可以。  </p>
<p>根据<a href="https://mantyke.icu/2021/mastodon-bulid/#%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91">小球飞象建站笔记</a>中踩坑提醒，如果使用的是 zoho 邮件服务，建议 SMTP server 使用国际版地址，否则可能配置失败，无法发送通知邮件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMTP_SERVER=smtp.zoho.com</span><br></pre></td></tr></table></figure>

<p>该步骤完成于 2022.05.07。耗时约 40 分钟，大多数时间消耗在 <code>docker-compose run --rm web bundle exec rake mastodon:setup</code> 的每一小步上。尤其是 zoho 还突然登录不上，而我又因为时隔近两个月，完全忘记了管理员邮箱是什么，手忙脚乱几分钟。<br>还需注意的是，在这一步中，所有的密码都不可见。一开始没有意识到这一点，以为密码没有粘贴上，同一位置贴两三遍密码导致出错。以及 .env.production 配置信息一定要在电脑上保存一遍！  </p>
<h3 id="安装并配置-nginx"><a href="#安装并配置-nginx" class="headerlink" title="安装并配置 nginx"></a>安装并配置 nginx</h3><p>在进行这一步之前，根据蓝盒子站长的提示，先在购买域名的网站 DNS 设置中增加一个 <code>A Record</code>，将设定的域名指向服务器。  </p>
<ul>
<li>安装 nginx<br>直接运行命令 <code>sudo apt install nginx -y</code> 出现报错信息：  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Err:2 http://security.ubuntu.com/ubuntu focal-updates/main amd64 libnginx-mod-http-image-filter amd64 1.18.0-0ubuntu1.2</span><br><span class="line">404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:3 http://security.ubuntu.com/ubuntu focal-updates/main amd64 libnginx-mod-http-xslt-filter amd64 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:4 http://security.ubuntu.com/ubuntu focal-updates/main amd64 libnginx-mod-mail amd64 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:5 http://security.ubuntu.com/ubuntu focal-updates/main amd64 libnginx-mod-stream amd64 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:6 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx-core amd64 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Ign:1 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx-common all 1.18.0-0ubuntu1.2</span><br><span class="line">Ign:7 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx all 1.18.0-0ubuntu1.2</span><br><span class="line">Err:1 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx-common all 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:7 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx all 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/nginx-common_1.18.0-0ubuntu1.2_all.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/libnginx-mod-http-image-filter_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/libnginx-mod-http-xslt-filter_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/libnginx-mod-mail_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/libnginx-mod-stream_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/nginx-core_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/nginx_1.18.0-0ubuntu1.2_all.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?</span><br></pre></td></tr></table></figure>

<p>谷歌之后发现这是 <code>Ubuntu 20.04</code> 会出现的常见报错，在运行安装命令前应先运行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update # 运行这一行之后可以尝试运行安装命令，如果仍报错再运行下一行</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<ul>
<li>配置 nginx &amp; 配置SSL证书 &amp; 重启nginx<br>根据蓝盒子站长的教程配置，步骤中没有出错。</li>
</ul>
<p>该步骤完成于 2022.05.07。约耗时 30 分钟，除了一开始找报错原因费点时间之外，都是运行命令、等待命令结束，操作非常简单。  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到这里站点已经上线，后续都是一些个性化修改，可以根据不同需求找相应的教程。<br>站点搭建实际用时 230 分钟，其中很多时间浪费在不敢做和注意力不集中上。如果不是像我一样每天找一点时间随手操作其中一个小步骤，而是空出一大段时间专心建站的话，应该两到三小时就能够完成上述所有步骤。<br>如果你和我一样也记不住整个过程中太多账号、用户名和密码，可以在电脑上建一个备忘录或在其它安全的地方记住密码。</p>
<h2 id="备份-未完成"><a href="#备份-未完成" class="headerlink" title="备份 (未完成)"></a>备份 (未完成)</h2><p>参考蓝盒子站长的教程：<a href="https://pullopen.github.io/%E7%AB%99%E7%82%B9%E7%BB%B4%E6%8A%A4/2020/07/22/Move-mastodon-media-to-Scaleway.html">如何将Mastodon媒体上传至Scaleway云储存</a></p>
<h2 id="装修"><a href="#装修" class="headerlink" title="装修"></a>装修</h2><h3 id="使用管理命令行"><a href="#使用管理命令行" class="headerlink" title="使用管理命令行"></a>使用管理命令行</h3><ul>
<li>使用脚本简化命令<br>参考：<a href="https://blog.tantalum.life/posts/how-to-run-your-mastodon-by-docker/#%E4%BD%BF%E7%94%A8alias%E8%84%9A%E6%9C%AC%E7%BC%A9%E5%86%99tootctl%E5%91%BD%E4%BB%A4">使用 alias 脚本缩写 tootctl 命令</a>。<br>由于前面的步骤一直主要参考蓝盒子站长的教程，所以这里第一步目标文件夹应为 <code>/home/mastodon/mastodon</code>，即 <code>cd /home/mastodon/mastodon</code>。  </li>
<li>使用命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tootctl help # 帮助信息，如果正常运行说明上一步的简化命令脚本生效。</span><br><span class="line">tootctl settings registrations close # 关闭注册</span><br></pre></td></tr></table></figure></li>
</ul>
<p>此处由于站点装修未完成，暂时关闭注册。也可以在网页端关闭注册。  </p>
<h3 id="开启全文搜索"><a href="#开启全文搜索" class="headerlink" title="开启全文搜索"></a>开启全文搜索</h3><p>参考蓝盒子站长给出的命令修改相应的配置文件，但在重启 docker 这一步骤报错：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: yaml.parser.ParserError: while parsing a block mapping</span><br><span class="line">  in &quot;./docker-compose.yml&quot;, line 3, column 3</span><br><span class="line">expected &lt;block end&gt;, but found &#x27;&lt;block mapping start&gt;&#x27;</span><br><span class="line">  in &quot;./docker-compose.yml&quot;, line 26, column 4</span><br></pre></td></tr></table></figure>

<p>再次检查 <code>docker-compose.yml</code> 文件发现，只删除 <code>#</code> 会导致缩进不统一，导致对 block 的判断有误。每行在删除 <code>#</code> 的同时，应在行首再删除一个空格。<br>其余步骤根据教程中的命令，一步一步完成即可。</p>
<h3 id="其它魔改"><a href="#其它魔改" class="headerlink" title="其它魔改"></a>其它魔改</h3><p>站点魔改有许多可用的教程，如：<br><a href="http://blog.tantalum.life/posts/how-to-run-your-mastodon-by-docker/">Mastodon | 采用docker建站后的使用与维护</a><br><a href="https://pullopen.github.io/%E7%AB%99%E7%82%B9%E7%BB%B4%E6%8A%A4/2020/11/26/mastodon-manage.html">如何装饰你的站点：自定义CSS、中继站和自定义表情</a><br><a href="https://pullopen.github.io/%E8%BF%9B%E9%98%B6%E9%AD%94%E6%94%B9/2020/11/14/mastodon-modify.html">进阶魔改：修改字数上限、媒体上限、投票上限、添加自定义主题、界面用语、非登陆用户有限显示、优化中文搜索，附阻止本站嘟文流入某站点方法</a>  </p>
]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Build</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
      </tags>
  </entry>
  <entry>
    <title>Computational Deconvolution for More Precise Biological Data</title>
    <url>/2021/12/08/deconmixeddata/</url>
    <content><![CDATA[<center> 文献阅读：解卷积可从混合的生物学数据中解得各细胞类型比例，或估计各细胞类型的表达谱，为研究提供更准确的样本数据 </center>
<span id="more"></span>

<h2 id="Deconvolution"><a href="#Deconvolution" class="headerlink" title="Deconvolution"></a>Deconvolution</h2><p><strong>Deconvolution</strong> 译作反卷积或解卷积。解卷积是一种基于算法的过程，用于反转卷积对记录数据的影响。<br>生物学数据，如 DNA expression、RNA sequencing、Protein expression 等，很难真正得到来自特定组织的“纯数据”。如血液中含有来自不同组织的细胞、外泌体等，由此得来的生物学数据将是不同类型细胞的混合数据。这时就需要通过解卷积，从混合的生物数据中解得不同类型细胞的比例、表达谱。  </p>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>测得的数据为不同类型细胞按照一定比例混合在一起的结果。  </p>
<ul>
<li>测得的表达矩阵为 <em>X</em>，则 x<sub>ij</sub> 表示 gene<sub>i</sub> 在 sample<sub>j</sub> 中的表达量或表达强度  </li>
<li>比例矩阵为 <em>R</em>，则 r<sub>kj</sub> 表示 k 类细胞在 sample<sub>j</sub> 中所占比例  </li>
<li>各细胞真实表达谱组成的矩阵为 <em>S</em>，则 s<sub>ik</sub> 表示表示 gene<sub>i</sub> 在 k 类细胞中的表达量或表达强度  </li>
</ul>
<p><img src="/2021/12/08/deconmixeddata/decon.png">  </p>
<h2 id="解卷积算法"><a href="#解卷积算法" class="headerlink" title="解卷积算法"></a>解卷积算法</h2><p>针对不同情况有不同的算法，根据项目中的先验知识选择合适的解卷积方法以达到最佳效果。<br>生物数据解卷积分为完全解卷积和不完全解卷积。  </p>
<ul>
<li><strong>完全解卷积</strong>：指混合细胞类型数目、比例和各细胞表达谱未知，仅依赖混合表达数据将它们解出来，即已知混合表达矩阵 <em>X</em>，解比例矩阵 <em>R</em> 和各细胞表达矩阵 <em>S</em>。完全解卷积的完全指细胞表达谱和比例都在算法中一次性解得。  </li>
<li><strong>不完全解卷积</strong>：指已知混合表达谱、细胞类型数目、比例，解各细胞表达谱，即已知比例矩阵 <em>R</em> 和混合表达矩阵 <em>X</em>，解矩阵各细胞表达矩阵 <em>S</em>。不完全是相对于完全解卷积而言，仅解得各细胞表达谱。  </li>
</ul>
<h3 id="完全解卷积"><a href="#完全解卷积" class="headerlink" title="完全解卷积"></a>完全解卷积</h3><h4 id="LinSeed"><a href="#LinSeed" class="headerlink" title="LinSeed"></a><a href="https://doi.org/10.1038/s41467-019-09990-5">LinSeed</a></h4><p>通过计算共线性网络 (Collinearity Network) 得到各类型细胞的 markers，利用 markers 对混合数据进行完全解卷积，同时得到各组分的比例和表达谱。<br><img src="/2021/12/08/deconmixeddata/LinSeed.jpg"></p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/ctlab/linseed">https://github.com/ctlab/linseed</a>  </li>
</ul>
<h4 id="Deblender"><a href="#Deblender" class="headerlink" title="Deblender"></a><a href="https://doi.org/10.1186/s12859-018-2442-5">Deblender</a></h4><p>Deblender 是一个灵活的完全去卷积工具。基于用户对已知标记基因列表和细胞/组织组成信息的访问 (access)，以半/无监督模式运行。在没有先验知识的情况下，全局基因表达的变异性被用于混合数据的聚类，以聚类集代替标记集。<br><img src="/2021/12/08/deconmixeddata/Debledner.jpg">  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>MATLAB  </li>
<li><a href="https://github.com/kondim1983/Deblender/">https://github.com/kondim1983/Deblender/</a>  </li>
</ul>
<h4 id="CDSeq"><a href="#CDSeq" class="headerlink" title="CDSeq"></a><a href="https://doi.org/10.1371/journal.pcbi.1007510">CDSeq</a></h4><p>CDSeq 仅使用来自大量组织样本的 RNA-Seq 数据来同时估计细胞类型比例和细胞类型特异性表达谱。<br><img src="/2021/12/08/deconmixeddata/CDSeq1.jpg"><br><img src="/2021/12/08/deconmixeddata/CDSeq2.jpg">  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>MATLAB and Octave  </li>
<li><a href="https://github.com/kkang7/CDSeq">https://github.com/kkang7/CDSeq</a>  </li>
</ul>
<h4 id="Deconf"><a href="#Deconf" class="headerlink" title="Deconf"></a><a href="https://doi.org/10.1186/1471-2105-11-27">Deconf</a></h4><p>Deconf 证明了从单个样本的基因表达数据中预测构成细胞类型的比例的可行性，这是基于去粗取精的分类方法的前提条件。  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://static-content.springer.com/esm/art%3A10.1186%2F1471-2105-11-27/MediaObjects/12859_2009_3484_MOESM1_ESM.ZIP">example data and script</a>  </li>
</ul>
<h3 id="不完全解卷积"><a href="#不完全解卷积" class="headerlink" title="不完全解卷积"></a>不完全解卷积</h3><h4 id="Rodeo"><a href="#Rodeo" class="headerlink" title="Rodeo"></a><a href="https://doi.org/10.1093/nargab/lqaa110">Rodeo</a></h4><p>Rodeo 是一种基于稳健线性回归的方法，可以实现简单而稳健的表达式反卷积。  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/elolab/Rodeo">https://github.com/elolab/Rodeo</a></li>
</ul>
<h4 id="cs-lsfit-amp-cs-qprog"><a href="#cs-lsfit-amp-cs-qprog" class="headerlink" title="cs-lsfit &amp; cs-qprog"></a><a href="https://doi.org/10.1371/journal.pone.0006098">cs-lsfit &amp; cs-qprog</a></h4><p>cs-lsfit 和 cs-qprog 属于 CellMix 中的两个解卷积算法，使用CellMix时可选择使用哪一个来进行解卷积步骤。</p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/r-forge/cellmix/tree/master/pkg/CellMix">https://github.com/r-forge/cellmix/tree/master/pkg/CellMix</a></li>
</ul>
<h4 id="LRCDE"><a href="#LRCDE" class="headerlink" title="LRCDE"></a><a href="https://doi.org/10.1186/s12859-016-1226-z">LRCDE</a></h4><p>LRCDE 在逐个基因的基础上执行基于线性回归的细胞类型特异性差异表达(反卷积)检测。考虑到细胞类型特异性基因表达估计的变异性，它计算差异检测的每个基因 t 统计量、p 值、基于 t 统计量的灵敏度、组特异性均方误差和几个基因特异性诊断指标。  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/ERGlass/lrcde.dev">https://github.com/ERGlass/lrcde.dev</a></li>
</ul>
<h4 id="csSAM"><a href="#csSAM" class="headerlink" title="csSAM"></a><a href="https://doi.org/10.1038/nmeth.1439">csSAM</a></h4><p>csSAM 根据测量的细胞比例计算细胞特异性差异表达。<br><img src="/2021/12/08/deconmixeddata/csSAM.jpg"></p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/shenorrLab/csSAM">https://github.com/shenorrLab/csSAM</a>  </li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Maria K Jaakkola, Laura L Elo, Computational deconvolution to estimate cell type-specific gene expression from bulk data, NAR Genomics and Bioinformatics, Volume 3, Issue 1, March 2021, lqaa110, <a href="https://doi.org/10.1093/nargab/lqaa110">https://doi.org/10.1093/nargab/lqaa110</a><br>[2] 具体算法参考文献见算法介绍部分</p>
]]></content>
      <categories>
        <category>Paper</category>
        <category>DeconvoluteMixedBioData</category>
      </categories>
      <tags>
        <tag>DeconvoluteMixedBioData</tag>
        <tag>Bioinformatics</tag>
      </tags>
  </entry>
  <entry>
    <title>在文章中插入图片的各种方式</title>
    <url>/2021/10/19/imginblog/</url>
    <content><![CDATA[<center>终于还是没能避免想要在文章中用到图片，所以有了本文记录在Hexo博客中插入图片的各种方式</center>  
<span id="more"></span>  

<h2 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>安装插件<code>hexo-asset-image</code></p>
<pre><code>npm install hexo-asset-image --save
</code></pre>
<p>安装成功后，打开<code>/node_modules/hexo-asset-image/index.js</code>，替换成下列内容：</p>
<pre><code>&#39;use strict&#39;;
var cheerio = require(&#39;cheerio&#39;);

// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string
function getPosition(str, m, i) &#123;
return str.split(m, i).join(m).length;
&#125;

var version = String(hexo.version).split(&#39;.&#39;);
hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;
var config = hexo.config;
if(config.post_asset_folder)&#123;
    var link = data.permalink;
if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)
    var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;
else
    var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;
// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.
var endPos = link.lastIndexOf(&#39;/&#39;) + 1;
    link = link.substring(beginPos, endPos);
var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];
for(var i = 0; i &lt; toprocess.length; i++)&#123;
var key = toprocess[i];

var $ = cheerio.load(data[key], &#123;
    ignoreWhitespace: false,
    xmlMode: false,
    lowerCaseTags: false,
    decodeEntities: false
&#125;);

$(&#39;img&#39;).each(function()&#123;
if ($(this).attr(&#39;src&#39;))&#123;
// For windows style path, we replace &#39;\&#39; to &#39;/&#39;.
var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);
if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;
    !/^\s*\//.test(src)) &#123;
    // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.
    // In addition, to support multi-level local directory.
    var linkArray = link.split(&#39;/&#39;).filter(function(elem)&#123;
    return elem != &#39;&#39;;
    &#125;);
    var srcArray = src.split(&#39;/&#39;).filter(function(elem)&#123;
    return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;
    &#125;);
    if(srcArray.length &gt; 1)
    srcArray.shift();
    src = srcArray.join(&#39;/&#39;);
    $(this).attr(&#39;src&#39;, config.root + link + src);
    console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);
&#125;
&#125;else&#123;
console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);
console.info&amp;&amp;console.info($(this));
    &#125;
&#125;);
data[key] = $.html();
    &#125;
&#125;
&#125;);
</code></pre>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>当整个博客图片内容较少时，可将所有的图片都放在<code>source/images</code>文件夹下，通过<code>markdown</code>语法访问。  </p>
<pre><code>![](/images/img1.png)
</code></pre>
<p>对于图片较少切命名清晰的情况，这种方式存放图片足够。</p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>除了将图片存放在<code>source/images</code>文件夹下，还可以将图片存放在文章自己的目录中。文章目录可通过修改配置文件生成：  </p>
<pre><code>post_asset_folder: true  
</code></pre>
<p>将配置文件中<code>post_asset_folder</code>修改为<code>true</code>后，执行命令</p>
<pre><code>hexo new post newblog
</code></pre>
<p>会在<code>source/_posts</code>生成<code>newblog.md</code>和同名文件夹<code>newblog</code>。将图片存在该同名文件夹中，即可通过相对路径的方式在文章中添加图片。</p>
<pre><code>![](img.png)
</code></pre>
<p>这一方法能够在文章中显示图片，但无法在首页正常显示图片，如需在首页显示图片可使用如下方式：</p>
<pre><code>&#123;% asset_img img.png This is an image %&#125;
</code></pre>
<p>当图片内容较多，使用相对路径存放图片的方式更易于整理。</p>
<h4 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h4><p>如遇到修改配置文件后运行<code>hexo new newblog</code>命令无法正常建立一个同名文件夹，可以手动在<code>_POST</code>目录下建立一个同名文件夹，仍能够达到同样的效果。<br>实际上，md文件也可以手动新建。根据使用者的习惯，怎么新建md文件和同名文件夹都是可以的。<br>平时写文章不常用到图片，也可以使用手动建立同名文件夹的方式。  </p>
<h2 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h2><p>将图片上传到一些CDN服务中并使用对应的url地址引用图片也是一个很好的方式。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a><br>[2] <a href="https://fuhailin.github.io/Hexo-images/">在Hexo博客中插入图片的各种方式</a><br>[3] <a href="https://www.cxyzjd.com/article/m0_43401436/107191688">hexo博客中插入图片失败——解决思路及个人最终解决办法</a><br>[4] <a href="http://sdman.tech/2019/07/23/%E8%A7%A3%E5%86%B3Hexo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决 Hexo 框架博客图片不显示的问题</a></p>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>长毛象使用指南</title>
    <url>/2021/09/21/mstdn/</url>
    <content><![CDATA[<center>不少朋友被我安利到长毛象(mastodon)玩耍，本着对他们负责的态度，写下这篇长毛象使用指南。</center>
<span id="more"></span>

<h2 id="什么是mastodon"><a href="#什么是mastodon" class="headerlink" title="什么是mastodon"></a>什么是mastodon</h2><p>Mastodon(长毛象)是一个开源、去中心化的社交平台。简单来说，这里没有屏蔽词，没有限流，没有铺天盖地的营销号，没有Doctor看了都想重启宇宙的混乱时间线，只是一个纯粹的社交平台。长毛象将内容、社交网络交还给用户，更加尊重用户而不是平台“霸权”。<br><strong>如果将联邦宇宙(Fediverse)看做一个宇宙，那么每一个长毛象站点(Mastodon Society)就像一颗颗星球。</strong> 也就是说，你可以选择任何一颗星球定居，哪怕只是居住着一个人，只要它与宇宙相通，那么你就可以联系到宇宙中任何一个人而不会孤单。(摘自pullopen对长毛象的介绍：<a href="https://pullopenbluebox.wordpress.com/2020/06/30/mastodon-introduction/">长毛象（Mastodon）：更尊重用户的社交平台</a> )</p>
<h2 id="如何在mastodon拥有一个账号"><a href="#如何在mastodon拥有一个账号" class="headerlink" title="如何在mastodon拥有一个账号"></a>如何在mastodon拥有一个账号</h2><h3 id="选择站点"><a href="#选择站点" class="headerlink" title="选择站点"></a>选择站点</h3><p>长毛象有各种各样的站点(或称实例)，如二次元相关站、LGBTQ站、艺术类站，或者按照语言划分的小语种站点等等。可以在官网列出的<a href="https://joinmastodon.org/communities">站点列表</a>里找到一个喜欢又适合的站点。<br>一开始使用建议在一些大型的国际站点注册，限制较少，每天都有很多世界各地的人在时间线上灌水，如</p>
<ul>
<li><a href="https://mastodon.social/">https://mastodon.social</a></li>
<li><a href="https://mastodon.online/">https://mastodon.online</a></li>
<li><a href="https://mstdn.social/">https://mstdn.social</a>  </li>
</ul>
<p>使用一段时间，对各项操作都熟悉之后，可进一步选择更适合自己的小站点注册并迁移账号，或者继续呆在国际站点也无妨。<br>也可以在中文站点，或者中文用户较多的站点注册。这样在查看local timeline(本地轴)时都是中文，方便遇到志同道合的朋友。但无论在哪个站点注册，都建议阅读过<strong>服务器规则</strong>和<strong>服务条款</strong>后再进行，这两项通常都放在注册页面。<br>熟悉长毛象后，发现没有一个站点完全符合自己的想法，也可以自建站加入长毛象宇宙。搭建长毛象站点有很多简单易上手的教程可供参考，即使是计算机小白也能拥有属于自己的站点。可参考的教程：</p>
<ul>
<li><a href="https://docs.joinmastodon.org/zh-cn/admin/prerequisites/">官方建站文档</a></li>
<li><a href="https://www.notion.so/Mastodon-042a05ee29a048df8b2c1afd49e4c49b">长毛象（Mastodon）社区搭建详解</a></li>
<li><a href="https://pullopen.github.io/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/2020/07/19/How-to-build-a-mastodon-instance.html">技术小白如何搭建Mastodon实例</a></li>
<li><a href="https://morikka.me/blog/mastodon-personal-instance/">长毛象个人向建站</a></li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>只要在一个站点注册，就可以连上整个长毛象宇宙，看到所有在用户和他们公开可见的嘟文，所以只需选择一个合适的站点注册账号即可。但由于站点服务器大多在中国境外，有被墙掉的风险，很多人会选择在多个站点注册账号，避免一个站点被GFW盯上ban掉就难以连上长毛象宇宙。<br>邮箱是各站点注册的必须品，注册成功后也可以更改。建议使用gmail、protonmail等邮箱服务，避免使用qq邮箱一类能直接指向使用者的邮箱。一些站点还需要填写入站申请或入站理由等以便站长和管理员审核注册人，通过审核之后便可成功注册，在长毛象宇宙自由玩耍。</p>
<h2 id="如何使用mastodon"><a href="#如何使用mastodon" class="headerlink" title="如何使用mastodon"></a>如何使用mastodon</h2><h3 id="Timeline-时间轴"><a href="#Timeline-时间轴" class="headerlink" title="Timeline(时间轴)"></a>Timeline(时间轴)</h3><p>Timeline简称为TL，完全按照时间来排列嘟文，不必担心出现时间线混乱、只给你看热度高的嘟文或塞给你不想看的广告、推广。<br>一般情况下，时间线有三种：</p>
<ul>
<li><strong>Home</strong> timeline，简称HTL，即首页。这是账号持有人自行关注而产生的时间线，能看到public、unlist、followers-only的嘟文(包括回复)以及提到你的direct message。</li>
<li><strong>Local</strong> timeline，简称LTL，即本站(地)轴。这是账号所在站点的时间线，只有该站点的公开嘟文会出现在这里。</li>
<li><strong>Federate</strong> timeline，简称FTL，即跨站轴。这是无论站点、所有账号嘟出的public内容共同组成的时间轴，能够看到世界各地的人都在这里发出自己的嘟嘟。</li>
</ul>
<p>通过设置<code>preferences (首选项) -&gt; other (其它) -&gt; PUBLIC TIMELINES-Filter languages (公共时间轴-语言过滤)</code>，可过滤时间线上的语言，只留下自己想看的语言。但这个过滤并不完全，公共轴或本站轴仍会出现一些应该被过滤掉的语言。 </p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul>
<li><p>发嘟  </p>
<ul>
<li>可见范围<br>发嘟可选择四种可见范围：public (公开)，unlist (公开，但不出现在公共时间轴)，followers-only (仅关注者可见)，direct message (私信，也可用作发仅自己可见的嘟文)。在设置中可以选择默认发嘟可见范围。</li>
<li>cw折叠功能<br>一些不想被直接看到或者含有可能令人不适内容的嘟文推荐使用cw。点击发嘟窗口下方的cw就会出现一个新的小窗口，在这个新的小窗口填上内容提示信息，在发嘟主要窗口填写主要内容。<del>这个功能也很好地被用来讲冷笑话</del>  </li>
<li>标记敏感内容<br>如果发的嘟文/图片含有not safe for work(NSFW，包括色情、暴力、血腥等)的内容，需要在发嘟时将图片标记为敏感信息，且善用cw折叠功能。</li>
</ul>
</li>
<li><p>回复<br>左下角箭头是回复功能，回复也可以设置不同的可见范围。在此处如果设置followers-only，被回复者即使没有关注你，也可以看到。回复的嘟嘟仅会出现在同时关注对话双方的账号首页时间线(Home Timeline)。这样尽最大可能避免参与对话者以外的人的打扰，使对话双方处于平等地位，不会出现因一方粉丝过多看到回复一拥而上的现象。各个时间轴设置(一般在主区域右上角)中可设置该时间轴不显示回复类嘟文。</p>
</li>
<li><p>转发<br>长毛象的转发是仅转发，不能带文字。这样很好的避免了类似微博上转发挂人形成骂战的现象。在账号设置中选择<code>在时间轴中合并转嘟</code>，以避免一篇嘟文被太多人转发刷屏时间轴的情况。各个时间轴设置(一般在主区域右上角)中可设置该时间轴不显示转发类嘟文，公共轴一般默认不显示转发。</p>
</li>
<li><p>喜欢<br>这里的⭐是favourite的意思，类似点赞功能。点赞代表赞同、安慰还是这里有个言论我mark一下就看使用者自己的想法，但通常来说都是<strong>赞</strong>！  </p>
</li>
<li><p>书签<br>bookmark是书签，或者称为收藏功能，这个功能与大多数平台相似，不再赘述。</p>
</li>
</ul>
<h3 id="头像、昵称、profile、标签"><a href="#头像、昵称、profile、标签" class="headerlink" title="头像、昵称、profile、标签"></a>头像、昵称、profile、标签</h3><p>一些站点固定期限内没有头像、昵称和嘟文的“三无账号”会被清除收回，注意阅读站点规则避免注册之后账号被回收。既然已经决定抛弃微博等在用户时间线上搞动作的平台，就不要只是注册个账号放着，用起来！</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ul>
<li><p>锁嘟<br>锁定账号(选项在个人资料页面)，需要手动审核所有关注请求。即每个想要关注你账号的人需要先发送关注请求，你通过之后方可关注你的账号以及看到你的followers-only的嘟文。与instgram的锁账号不同，即使挂上小锁其他人仍能看到公开可见的嘟文。如果有较多敏感嘟文不想随意被人看到，可定期删除或选择followers-only、direct message这两种可见范围。</p>
</li>
<li><p>语言<br>通过<code>Preferences (首选项) -&gt; Appearance (外观) -&gt; Interface language (界面语言)</code>设置平台语言。由于各语种都是志愿者翻译，可能会出现错误或词不达意，但基本不影响使用。</p>
</li>
<li><p>过滤器<br>这里的过滤器是真的过滤掉包含关键字的嘟文，但可能会在原本应该是一条嘟文的地方出现<code>filtered</code>的提醒。过滤器可以设置失效时间、作用场景等。</p>
</li>
<li><p>邮件通知<br><code>Preferences (首选项) -&gt; Notifications (通知)</code>里的邮件提醒建议关掉，避免发送过多邮件给站长的邮件服务造成不必要的负担。</p>
</li>
<li><p>其它<br>界面语言设置为惯用语言后，其它设置可自行探索。</p>
</li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>Mastodon故意弱化了搜索功能，避免形成“广场”，从而导致有人随便搜索一个关键词便前来抬杠或骂人的行为。但这也在一定程度上造成使用者的不便，比如明明有印象一条嘟嘟，但根本找不到，所以需要使用者自己多注意收藏有用的信息。有些站点开了全文搜索，会让搜索结果好一些，如自己的嘟文或转发、点赞过的嘟文能够搜索，但无法实现真正的“搜索”。 </p>
<h3 id="block-mute"><a href="#block-mute" class="headerlink" title="block / mute"></a>block / mute</h3><p>block即拉黑/屏蔽。拉黑后，该账号无法与你互动、关注，嘟文不会出现在你的时间线。<br>mute即隐藏。隐藏后，该账号的嘟文不会出现在你的时间线，但仍可与你互动、关注，而你不会收到任何提醒。</p>
<h3 id="迁移账号"><a href="#迁移账号" class="headerlink" title="迁移账号"></a>迁移账号</h3><p>长毛象的一大优点就是站点多，且类型丰富。如果看上了别的站点，可以在新站点注册账号后将账号迁移过去。迁移账号可以自动将followers/following转移到新账号，但无法迁移旧帐号的嘟文。</p>
<h3 id="账号备份"><a href="#账号备份" class="headerlink" title="账号备份"></a>账号备份</h3><p>长毛象自带的备份功能可以备份follower列表、following列表、mute列表、block列表等。如果想要备份嘟文，可以使用象友提供的<a href="https://github.com/slashyn/mastodon-archive-viewer-modified">备份插件</a>。<br>由于各个站点的维护仅依赖站长和可能有的站点管理员，所以可能会有不稳定、服务器出问题等状况出现，有时整个站点也会关闭不再运行，及时备份账号内容是个好习惯。</p>
<h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>长毛象作为一个去中心化的平台，最佳访问方式是直接浏览器访问，如Chrome、Firefox、safari等。这些浏览器可以在手机主屏幕创建快捷方式，在手机桌面单独形成一个图标和有一个app没有太大差别。<br>如果仍需要一个app，可选择的有：</p>
<ul>
<li><p><strong>Android</strong>: Tusky, Subway Tooter, Fedilab(付费)</p>
</li>
<li><p><strong>iOS</strong>: Metatext, Mercury, iMast, Amaroq, Mast(付费), Toot!(付费)  </p>
</li>
<li><p><strong>tooot</strong>：对于中文用户，推荐使用tooot。这是一个专注于中文社区的简洁、开源长毛象手机客户端，跨平台支持iOS和Android。 </p>
</li>
<li><p><strong>其它</strong>：其它平台应用推荐可查看<a href="https://joinmastodon.org/apps">官网应用推荐</a>。  </p>
</li>
</ul>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>作为一个公共社交网络，这里也可以带话题(tag)发嘟。格式和Instagram一样，只需要一个<code>#</code>，如<code>#tag</code>。<br>长毛象已经有很多有趣或有用的tag，如<code>#长毛象中文使用指南</code>、<code>#长毛象安利交换大会</code>、<code>#资源分享</code>、<code>#菜谱</code>，还有季节性的赏花、赏月tag。也可以创建自己的专属tag，把某类嘟文存在这个tag下，方便自己查看。</p>
<h3 id="一些好玩的账号"><a href="#一些好玩的账号" class="headerlink" title="一些好玩的账号"></a>一些好玩的账号</h3><ul>
<li><p>骰寶機<br>吃喝玩乐都可以找它！想不到晚饭吃什么，发嘟@骰宝问吃什么，不出一分钟就会回复一种食物。问它喝什么同理。还有好玩又有趣的答案之书和对不对判断。具体玩法可查看骰宝账号主页了解。</p>
</li>
<li><p>妙仙包<br>想知道心中之事的结果？找大师求签、塔罗牌都能给你一个奇妙的答案。选择困难症？找包包真普选，轻松治愈选择困难。心中有愿还可对着大师许愿，有机会被大师选中实现。具体玩法查看妙仙包账号主页了解。</p>
</li>
<li><p>sci咖啡屋<br>这里可以点单饮品、套餐，但一定要吃完不可浪费。累了还可以在这里撸猫，猫猫送上缓解疲惫。具体玩法查看sci咖啡屋账号主页了解。</p>
</li>
<li><p>Mature[マツレ]<br>Mature是长毛象上最早的科学期刊之一，也是长毛象最权威及最有名望的学术期刊之一。每周最重要、最前沿的研究结果是在「Mature」中以论文导读的形式发表的。欢迎订阅，支持投稿。投稿方法详见Mature账号主页。</p>
</li>
</ul>
<p>以上有趣账号可通过搜索名称获得，在此不提供具体账号以免给站点造成麻烦。</p>
<h2 id="More-than-Mastodon"><a href="#More-than-Mastodon" class="headerlink" title="More than Mastodon"></a>More than Mastodon</h2><p>其实mastodon只是这个宇宙中的一部分，还有Misskey、pleroma、funkwhale、peertube等和mastodon类似的社交平台共同组成整个联邦宇宙。<br>何必拘泥于处处受限的一隅，这里有更广阔的宇宙等你。<br>Enjoy yourself！</p>
]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Use</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
        <tag>UserGuide</tag>
      </tags>
  </entry>
  <entry>
    <title>Methods to Analyze Multi-Omicis Data</title>
    <url>/2021/12/01/multiomics/</url>
    <content><![CDATA[<center>文献阅读：多组学数据的整合、解读方法及公开可用的多组学数据库</center>
<span id="more"></span>

<h2 id="Multi-Omics"><a href="#Multi-Omics" class="headerlink" title="Multi-Omics"></a>Multi-Omics</h2><p><strong>Multi-Omics</strong>指同时获得两个或两个以上组学数据，如基因组、转录组、蛋白质组等，并将它们结合在一起分析、挖掘，以获得更全面、更系统的生物学解释、分子作用机制等。  </p>
<h2 id="多组学研究的意义"><a href="#多组学研究的意义" class="headerlink" title="多组学研究的意义"></a>多组学研究的意义</h2><p>整合多组学数据，提供不同层次的生物分子信息，有望系统地、整体地理解复杂的生物学。<br>多组学研究以顺序或同时的方式结合各组学数据，以了解分子之间的相互作用。<br>有助于评估从一个组学水平到另一个组学水平的信息流，从而有助于弥合从基因型到表型的差距。<br>多组学数据能够为研究提供整体视角，有助于提高疾病表型的预后和预测准确性，进而帮助更好地治疗和预防。  </p>
<h2 id="多组学研究的困难"><a href="#多组学研究的困难" class="headerlink" title="多组学研究的困难"></a>多组学研究的困难</h2><p>多组学的研究通常与非组学数据相关联，如临床数据等，这导致多组学研究面临许多困难。  </p>
<h3 id="非组学数据复杂且主观定义"><a href="#非组学数据复杂且主观定义" class="headerlink" title="非组学数据复杂且主观定义"></a>非组学数据复杂且主观定义</h3><p>非组学数据通常十分复杂且主观性较强，需要标准化后将其加入预测或分类模型中。流行病学数据受制于调查模式、调查问题标准化以及背景，这可能会影响数据质量和可比性，并最终影响这些变量在结果预测中的贡献。不同研究者或组织由于收集程序不一致，也可能产生差异。临床数据受到其定义复杂性的影响，需要有统一的标准。目前有一些标准化的规则可供使用，如Clinical Data Interchange Standards Consortium (CDISC)，Study Data Tabulation Model (SDTM)，Analysis Data Model (ADaM)。这些非组学数据是基于评估者的技能和先前知识的复杂阐述过程产生的主观评估，这可能会导致报告偏差。  </p>
<h3 id="非组学数据具有异质性"><a href="#非组学数据具有异质性" class="headerlink" title="非组学数据具有异质性"></a>非组学数据具有异质性</h3><p>非组学数据缺乏统一性，如不同尺度测量的定性或定量变量等，在分析之前需要对它们进行数据转换或归一化步骤。  </p>
<h3 id="非组学数据规模大"><a href="#非组学数据规模大" class="headerlink" title="非组学数据规模大"></a>非组学数据规模大</h3><p>目前，许多多组学数据与非组学数据相结合的研究方法基于小尺度、低纬度的数据，而现在的非组学数据已经成为“大数据”——大规模，高维度。可穿戴监测装置和EHR (e-health records)的出现使非组学数据更易获取并向更高维度发展，且在处理客观和主观特征以及结构化和非结构化数据方面也更具有挑战性。<br>非组学数据的高维度也意味着存在</p>
<ul>
<li>变量之间的相关结构  </li>
<li>大规模纵向数据  </li>
<li>数据稀疏性（即药物、实验室或诊断测试）  </li>
<li>与组学数据相比，数据缺失与参与个体无关  </li>
</ul>
<p>这些因素都需要在后续分析建模时，将其考虑在内。  </p>
<h3 id="将组学和非组学数据联系"><a href="#将组学和非组学数据联系" class="headerlink" title="将组学和非组学数据联系"></a>将组学和非组学数据联系</h3><p>在病例对照设计中，组学数据和非组学数据的整合可能会受到确认偏差的影响。<br>组学和非组学数据之间的相互作用也会对研究产生影响。在建模的过程中，重要的是要将这种相互作用考虑在内。这些相互作用也可能非常复杂，如基因表达变化可能意味着表型异常，这导致分子数据和临床数据之间的关系更加复杂。  </p>
<h3 id="其它困难"><a href="#其它困难" class="headerlink" title="其它困难"></a>其它困难</h3><p>每个变量或块对结果的贡献是否应该相等。<br>当与高通量数据集结合时，如何防止临床变量被惩罚(penalized)。<br>亚型的出现会给模型增加复杂性，在建模时是否要将亚型考虑在内。</p>
<h2 id="多组学数据库"><a href="#多组学数据库" class="headerlink" title="多组学数据库"></a>多组学数据库</h2><p>多组学数据覆盖基因组、蛋白组、转录组、代谢组和表观遗传组的数据，含有这些组学数据两种或两种以上的数据库可成为多组学数据库。  </p>
<h3 id="TCGA"><a href="#TCGA" class="headerlink" title="TCGA"></a>TCGA</h3><p>The Cancer Genome Altas (<a href="https://cancergenome.nih.gov/">TCGA</a>) 是最大的多组学数据库之一，涵盖超过 33 种不同类型癌症的20000个个体肿瘤样本。TCGA旨在产生、整合、分析和解释肿瘤样本产生的DNA、RNA、蛋白质及表观遗传数据的特征以及临床和组织学数据。</p>
<h3 id="CPTAC"><a href="#CPTAC" class="headerlink" title="CPTAC"></a>CPTAC</h3><p>Clinical Proteomic Tumor Analysis Consortium (<a href="https://cptac-data-portal.georgetown.edu/cptacPublic/">CPTAC</a>) 是通过对TCGA库中的生物样本通过质谱技术进行分析，获取的蛋白质组数据。如果实验中同时测得基因组数据，也可在该库获得。  </p>
<h3 id="ICGC"><a href="#ICGC" class="headerlink" title="ICGC"></a>ICGC</h3><p>International Cancer Genomics Consortium (<a href="https://icgc.org/">ICGC</a>) 从20383名捐献者的21个原发癌位点的76个癌症项目中协调大规模生成基因组研究。  </p>
<h3 id="CCLE"><a href="#CCLE" class="headerlink" title="CCLE"></a>CCLE</h3><p>Cancer Cell Line Encyclopedia (<a href="https://portals.broadinstitute.org/ccle">CCLE</a>) 包含947种人类细胞系和36种肿瘤的基因表达、拷贝数和测序数据。还包含479种癌细胞系中24种抗癌药物的药理学特征。  </p>
<h3 id="METABRIC"><a href="#METABRIC" class="headerlink" title="METABRIC"></a>METABRIC</h3><p>Molecular Taxonomy of Breast Cancer International Consortium (<a href="http://molonc.bccrc.ca/apariciolab/research/metabric/">METABRIC</a>) 包含来自乳腺肿瘤的临床特征、表达、单核苷酸多态性和拷贝数变异数据。  </p>
<h3 id="TARGET"><a href="#TARGET" class="headerlink" title="TARGET"></a>TARGET</h3><p><a href="https://ocg.cancer.gov/programs/target">TARGET</a> 包含 24 种癌症分子类型的临床信息、基因表达、miRNA 表达、拷贝数和测序数据。  </p>
<h3 id="OmicsDI"><a href="#OmicsDI" class="headerlink" title="OmicsDI"></a>OmicsDI</h3><p>Omics Discovery Index (<a href="https://www.omicsdi.org/">OmicsDI</a>) 包含来自公共数据结构中的 11 个存储库的数据集。是一个开源平台，用于访问、发现和整合基因组学、转录组学、蛋白质组学和代谢组学数据集。包含来自人类、模式生物和非模式生物的数据集。  </p>
<h2 id="多组学数据分析方法"><a href="#多组学数据分析方法" class="headerlink" title="多组学数据分析方法"></a>多组学数据分析方法</h2><p>根据算法思想，可将目前已有的多组学数据分析方法分为几个大类：<br><img src="/2021/12/01/multiomics/methods.png">  </p>
<h3 id="Network-Based"><a href="#Network-Based" class="headerlink" title="Network Based"></a>Network Based</h3><p><strong>SNF</strong> (Similarity network fusion)是一种基于网络的方法，使用网络融合方法整合多组学数据集。它为每种数据类型创建一个单独的网络，然后使用非线性网络融合方法将它们融合成一个单一的相似性网络。 融合步骤基于消息传递理论，使网络在每次迭代中更像其他网络。<br><strong>NetICS</strong> (Network-based integration of multi-omics data)为基于网络的多组学数据集成提供了一个框架，用于癌症基因优先排序。可预测遗传畸变、表观遗传变化和miRNA对相互作用网络中下游基因和蛋白质(表达)的影响。在有向功能交互网络上使用每个样本的网络扩散模型，并通过聚合个体排名得出种群水平的基因排名，并为所有样本提供全局排名。  </p>
<h3 id="Bayesian-approach"><a href="#Bayesian-approach" class="headerlink" title="Bayesian approach"></a>Bayesian approach</h3><p><strong>iCluster</strong>根据多种数据类型同时推断，为样本生成一个单一的聚类分配。这种无监督方法使用联合潜在变量模型进行集成聚类，并在单个框架中结合不同数据类型之间的关联以及数据类型内的方差-协方差结构，同时降低数据集的维度。通过期望最大化算法获得似然推理。<br><strong>iClusterPlus</strong>是iCluster的增强版，使用广义线性回归来确定综合基因组、表观基因组和转录组分析的分类和数字(连续和计数)变量的联合模型。该方法使用一组潜在变量”k”来代表驱动因素，这些因素预测关键的基因组变量，从而捕捉生物变异。此外，使用Lasso回归方法，iClusterPlus确定了有助于亚型之间生物变化的特征子集。<br><strong>LRAcluster</strong>使用概率模型与低秩近似法来寻找主要的低维子空间，以对全基因组数据进行分类。在这种方法中，每个组学数据都以大小匹配的参数矩阵为条件，并且这个低秩参数矩阵可以在低维空间中表示。 用户定义的维度参数(基于数据的解释方差)和聚类数(基于轮廓值)有助于更快地降维和更好地聚类疾病亚型。<br><strong>PSDF</strong> (Patient-specific data fusion)该方法使用贝叶斯非参数模型(Dirichlet 过程混合模型)来整合CNV和基因表达数据，以将样本分层为子组。每个样本根据它们在2个数据集之间的一致性被分配一个二元状态。只有表现出一致性的样本融合在一起，而其他样本保持未融合，因此考虑了患者特定的融合模型。<br><strong>BCC</strong> (Bayesian consensus clustering)提出了一种数据驱动的共识聚类方法，该方法对源特定特征以及使用有限狄利克雷混合模型扩展以解释多个数据源的整体聚类进行建模。<br><strong>Joint Bayesian factor</strong>使用非参数贝叶斯因子分析来整合组学数据集。 这种方法使用 beta-Bernoulli 过程将特征空间分解为共享的和特定于数据的组件。<br><strong>MDI</strong> (Multiple dataset integration)使用 Dirichlet 混合模型对每个数据源进行聚类，同时对聚类之间的成对依赖性进行建模。MDI在分配给组件(如基因组特征)的变量级别链接模型。组件变量级链接允许捕获多组学数据之间的依赖关系。<br><strong>MOFA</strong> (Multi-omics factor analysis)是一种无监督方法，用于在相同或部分重叠的样本上整合多组学数据类型。<br><strong>PARADIGM</strong>的应用可以扩展到对所研究疾病的发现。  </p>
<h3 id="Fusion-based-approaches"><a href="#Fusion-based-approaches" class="headerlink" title="Fusion-based approaches"></a>Fusion-based approaches</h3><p><strong>PFA</strong> (Pattern fusion analysis)允许在低维特征空间中跨异质基因组谱识别集成样本模式。首先使用主成分分析获得局部样本模式。 其后将这些局部样本模式与公共特征空间对齐，并跨大多数数据类型合成全局样本模式。在此过程中，将定量测量每种数据类型(或单个样本)对全局样本频谱的贡献，并迭代降低偏差或系统噪声的影响以更好地拟合数据。  </p>
<h3 id="Similarity-based-approaches"><a href="#Similarity-based-approaches" class="headerlink" title="Similarity-based approaches"></a>Similarity-based approaches</h3><p><strong>PINSPlus</strong> (Perturbation clustering for data integration and disease subtyping)是一种无监督的聚类方法，有助于从多组学数据中识别亚型。为了识别亚型，该算法确定患者在单个集群中分组的频率(1)当数据受到干扰时，(2)使用不同类型的组学数据时，(3)使用不同的聚类技术时。 所有场景中的强关联患者都聚集在一起形成一个亚型。<br><strong>NEMO</strong>(Neighborhood-based multi-omics clustering) 是一种基于相似性的简单多组学聚类方法，它进一步建立在先前建立的聚类方法（如 SNF 和 rMKL-LPP）的基础上。该方法最初为每个输入组学数据集构建基于患者间相似性矩阵的欧几里德距离。然后将每个组学的相似性矩阵整合到一个矩阵中，然后使用光谱聚类方法对其进行聚类。  </p>
<h3 id="Correlation-based-approaches"><a href="#Correlation-based-approaches" class="headerlink" title="Correlation based approaches"></a>Correlation based approaches</h3><p><strong>CNAmet</strong>用于对拷贝数改变、DNA 甲基化和基因表达数据进行综合分析。  </p>
<h3 id="Other-multivariate-approaches"><a href="#Other-multivariate-approaches" class="headerlink" title="Other multivariate approaches"></a>Other multivariate approaches</h3><p><strong>mixOmics</strong>提供了一组有监督和无监督的多元方法来执行多组学数据集的整合，重点是变量选择。<br><strong>moCluster</strong>使用多表多元分析方法来识别跨多组学数据集的模式。<br><strong>MCIA</strong> (Multiple co-inertia analysis)是一种探索性数据分析方法，它捕捉多个高维数据集（如基因表达、miRNA表达、蛋白质表达）之间的相互关系。<br><strong>JIVE</strong> (Joint and individual variation explained)通过分离数据集的联合效应和个体效应来整合多组学数据。<br><strong>MFA</strong> (Multiple factor analysis)是一种通过将其投影到低维变量空间来帮助整合组学数据集的方法。<br><strong>rMKL-LPP</strong> 使用多核学习来集成异构多数据并执行子类型识别。<br><strong>iNMF</strong> (Integrative nonnegative matrix factorization)扩展了NMF框架以在集成多个数据时考虑异构效应。<br><strong>FSMKL</strong> (Feature selection multiple kernel learning)是一种监督分类方法，使用多个内核来捕获数据集之间的相似性，以识别疾病进展的特征。<br><strong>sMBPLS</strong> (Sparse multi-block partial least squares)允许多块输入包含多个调控组学数据集，例如 CNV、DNA 甲基化和调控基因表达的 miRNA 表达。<br><strong>T-SVD</strong> (Thresholding singular value decomposition)有助于识别 2 个组学数据集之间的调控机制，尤其是当调控特征大于测量样本时。<br><strong>Joint NMF</strong> 该分解框架从多个数据集(相同样本)中识别相关模块，以推导出 md 模块，以揭示潜在的多层监管因素。  </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Subramanian I, Verma S, Kumar S, Jere A, Anamika K. Multi-omics Data Integration, Interpretation, and Its Application. Bioinformatics and Biology Insights. January 2020. <a href="doi:10.1177/1177932219899051">doi:10.1177/1177932219899051</a><br>[2] López de Maturana E, Alonso L, Alarcón P, Martín-Antoniano IA, Pineda S, Piorno L, Calle ML, Malats N. Challenges in the Integration of Omics and Non-Omics Data. Genes (Basel). 2019 Mar 20;10(3):238. <a href="doi:10.3390/genes10030238">doi:10.3390/genes10030238</a></p>
]]></content>
      <categories>
        <category>Paper</category>
        <category>MultiOmics</category>
      </categories>
      <tags>
        <tag>Bioinformatics</tag>
        <tag>MultiOmics</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Markdown写博客</title>
    <url>/2021/09/16/writenewblog/</url>
    <content><![CDATA[<center>创建、发布新文章；用vscode + markdown编辑文章；给文章添加分类和标签。</center>
<span id="more"></span>

<h2 id="新建文章-create-a-post"><a href="#新建文章-create-a-post" class="headerlink" title="新建文章 create a post"></a>新建文章 create a post</h2><p>在博客目录运行命令：</p>
<pre><code>$ hexo new [layout] title
# layout有三种:post, draft, page, 默认是post，可以在博客配置文件中更改default_layout来更改默认设置
# Hexo会根据scaffolds文件夹内相对应的文件来建立md文件
# 当创建不同布局的md文件时，它们会存储在不同路径

$ hexo new &quot;My New Post&quot;
#新建一个名为&quot;My New Post&quot;的md文件
</code></pre>
<p>后续编辑这个文件即可。</p>
<h2 id="vscode-markdown写文章"><a href="#vscode-markdown写文章" class="headerlink" title="vscode + markdown写文章"></a>vscode + markdown写文章</h2><p>可按照以下步骤编辑一遍博客文章：</p>
<ol>
<li>从<a href="https://code.visualstudio.com/">官网</a>下载vscode，并安装。  </li>
<li>安装markdown插件：<ul>
<li>Markdown All in One: 组合包，把最常用的Markdown优化全部装好</li>
<li>Markdown Preview Github Styling: 在本地就能预览Markdown文件最终在Github Pages中显示的效果</li>
</ul>
</li>
<li>学习基本的markdown语法，利用vscode编辑文章。同时，利用”Open Preview to the Side”按键或快捷键可同时预览文章</li>
<li>写完这篇文章</li>
</ol>
<h2 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h2><h3 id="生成categories页并修改type属性"><a href="#生成categories页并修改type属性" class="headerlink" title="生成categories页并修改type属性"></a>生成categories页并修改type属性</h3><p>在博客目录运行命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>运行成功后会提示：</p>
<pre><code>INFO  Created: ~/Documents/blog/source/categories/index.md
</code></pre>
<p>根据所给路径找到index.md文件，在文件的框架内添加一行：</p>
<pre><code>type: &quot;categories&quot;
</code></pre>
<h3 id="给文章添加categories"><a href="#给文章添加categories" class="headerlink" title="给文章添加categories"></a>给文章添加categories</h3><p>在文章头的<code>categories:</code>后以<code>-</code>为标志添加标签，如本文的标签：</p>
<pre><code>categories:
- Blog #注意“-”后一定要加空格
</code></pre>
<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><h3 id="生成tag页并修改type属性"><a href="#生成tag页并修改type属性" class="headerlink" title="生成tag页并修改type属性"></a>生成tag页并修改type属性</h3><p>在博客目录运行命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>运行成功后会提示：</p>
<pre><code>INFO  Created: ~/Documents/blog/source/tags/index.md
</code></pre>
<p>根据所给路径找到index.md文件，在文件的框架内添加一行：</p>
<pre><code>type: &quot;tags&quot;
</code></pre>
<h3 id="给文章添加tag"><a href="#给文章添加tag" class="headerlink" title="给文章添加tag"></a>给文章添加tag</h3><p>在文章头的<code>tags:</code>后以<code>-</code>为标志添加标签，如本文的标签：</p>
<pre><code>tags: 
- Blog #注意“-”后一定要加空格
- Hexo
- Markdown
- vscode
</code></pre>
<h2 id="文章的发布"><a href="#文章的发布" class="headerlink" title="文章的发布"></a>文章的发布</h2><p>在博客目录运行命令：</p>
<pre><code>$ hexo generate
$ hexo server  # 本地预查看
$ hexo deploy  # 部署到GitHub Pages

# 此步骤报错可先检查文件头等文章各部分是否缺少空格
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/156915260">Hexo博客写文章及基本操作</a></li>
<li><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo使用攻略-添加分类及标签</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/56943330">[Markdown] 使用vscode开始Markdown写作之旅</a></li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Markdown</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Batch Effects Matter and Avoid Them in Omics Data</title>
    <url>/2021/10/29/BatchEffect/</url>
    <content><![CDATA[<center>文献阅读：关于批次效应的3W1H——什么是批次效应、什么情况下会出现批次效应、为什么要关注批次效应与如何处理批次效应</center>
<span id="more"></span>

<h2 id="什么是批次效应"><a href="#什么是批次效应" class="headerlink" title="什么是批次效应"></a>什么是批次效应</h2><p><strong>批次效应</strong>是指实验子组在不同的实验条件之下具有与研究中的生物学或其它科学变量无关的性质不同的行为，即实验中测量值之间由于技术因素造成的系统性差异。</p>
<br>

<h2 id="什么情况下会有批次效应"><a href="#什么情况下会有批次效应" class="headerlink" title="什么情况下会有批次效应"></a>什么情况下会有批次效应</h2><p>批次效应在生物学实验中广泛存在，无论是microarray expression profiling还是mass spectrometry产生的数据，都观察到明显的批次效应。具体到研究疾病的差异基因/蛋白或变异数据(如拷贝数变异)的研究中同样观察到明显批次效应。<br>造成批次效应的因素有很多，试剂批次不同、实验时间不同、仪器状态变化、实验员不同都可能造成批次效应。其中一些批次效应能够通过规范化实验操作、更好的实验设计避免；另一些则需要通过对所得数据进行处理才能够消除。<br>在Leek等人对已公开数据批次效应的研究发现，已公开的数据中存在明显批次效应。且在许多实验条件和技术中，技术性因素比生物性因素对实验结果更具影响力。当批次效应发生时，常常与生物性因素混淆，导致下游研究结果不准确。  </p>
<br>

<h2 id="为什么要关注批次效应"><a href="#为什么要关注批次效应" class="headerlink" title="为什么要关注批次效应"></a>为什么要关注批次效应</h2><p>当批次效应发生时，可能会</p>
<ul>
<li>增加变化(variability)而掩盖真正生物学信号，导致得到错误的生物学或临床结论  </li>
<li>与特征信号混在一起，导致下游分类器构建困难  </li>
<li>阻碍生物学上重要亚型的发现或与亚型混淆难以区分  </li>
<li>导致实验资源分配不当，结果缺乏可重复性  </li>
</ul>
<p>因此，消除批次效应对得到准确、可重复性高的结论非常重要。</p>
<br>

<h2 id="如何避免或处理批次效应"><a href="#如何避免或处理批次效应" class="headerlink" title="如何避免或处理批次效应"></a>如何避免或处理批次效应</h2><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><p>避免出现批次效应的首要步骤是合理的实验设计。高通量的实验应在实验设计时考虑到批次效应，在实验过程中尽可能避免批次效应的出现。实验分组时也需保证平衡性(balance)，避免非研究目标的生物学因素对实验结果造成影响，进而和批次效应混杂，导致数据难以处理。  </p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>优秀的实验设计是降低批次效应的基础，在此基础之上处理批次效应主要有以下两个步骤：</p>
<ol>
<li>识别并量化数据中潜在的批次效应，包括人为因素  </li>
<li>使用已知或找到的人为因素调整数据以适应下游分析</li>
</ol>
<h4 id="识别并量化批次效应"><a href="#识别并量化批次效应" class="headerlink" title="识别并量化批次效应"></a>识别并量化批次效应</h4><p>识别和量化批次效应主要通过主成分分析(Principal Component Analysis, PCA)或其它数据可视化工具如聚类、多维数据标化等。<br>如果数据处理结果中出现：  </p>
<ul>
<li>样本按处理组或时间聚类</li>
<li>大量特征与处理组或时间高度相关</li>
<li>主成分与批次处理组或时间相关联  </li>
</ul>
<p>则表明数据中极大可能存在批次效应，必须在下游数据处理前考虑到批次效应的影响。</p>
<h4 id="处理批次效应"><a href="#处理批次效应" class="headerlink" title="处理批次效应"></a>处理批次效应</h4><p>根据其算法思想可将消除批次效应的方法分为如下几个大类：  </p>
<ul>
<li><strong>简单线性模型(Simple Linear Models)</strong>: Mean-scaling, zero-centering  </li>
<li><strong>经验贝叶斯方法(Empirical Bayes)</strong>: ComBat  </li>
<li><strong>因子分析(Factor-based analysis)</strong>: Surrogate Variable Analysis (SVA), Removed unwanted variation (RUV)  </li>
<li><strong>深度学习(Deep Learning)</strong>: NormAE</li>
</ul>
<p>其中，前两种消除批次效应的方法需要已知造成批次效应的因素，如实验时间等。  </p>
<p>根据先验知识、实验数据规模、特征空间大小、研究目的等因素，可挑选不同的处理批次效应的方法：</p>
<ul>
<li>大数据；特征空间有限；有限的生物异质性；批次效应或分类影响因子已知；目标是简单分析：<strong>Two-way ANOVA</strong>  </li>
<li>小数据；特征空间有限；有限的生物异质性；批次效应或类影响因子已知；目标是去除批次效应：<strong>ComBat</strong>  </li>
<li>中/大型数据集；大特征空间；存在生物异质性；类因子已知，批次效应影响因素不必已知；目标是移除批次效应且确定批次效应影响因素：<strong>SVA</strong>, <strong>RUV</strong>  </li>
<li>中/大型数据集；大特征空间；存在生物异质性；批次效应或分类影响因子都不必已知；目标是移除批次效应且确定批次效应影响因素但不需直到类因子：<strong>unsupervised methods (PCA)</strong>, <strong>RUV</strong></li>
</ul>
<p>算法补充：<br><img src="/2021/10/29/BatchEffect/Methods.png" alt="算法补充1"><br><img src="/2021/10/29/BatchEffect/Methods2.png" alt="算法补充2">  </p>
<h4 id="批次效应处理评估"><a href="#批次效应处理评估" class="headerlink" title="批次效应处理评估"></a>批次效应处理评估</h4><p>消除批次效应之后，通常会检查处理的效果。常用的方法有PCA、层次聚类等，检查数据是否有与批次相关联的偏移、聚类结果是否更符合生物学先验知识等。<br>评估方法小结：<br><img src="/2021/10/29/BatchEffect/Validation.png" alt="批次效应评估方法">  </p>
<br>

<h2 id="批次效应处理流程"><a href="#批次效应处理流程" class="headerlink" title="批次效应处理流程"></a>批次效应处理流程</h2><p>Jelena Čuklina等人针对批次效应的研究中提供了一个消除蛋白质数据批次效应的处理流程和一个包含所有处理步骤的R包——proBatch (<a href="https://www.bioconductor.org/packages/release/bioc/html/proBatch.html">Bioconductor</a>, <a href="https://hub.docker.com/r/digitalproteomes/probatch">Docker container</a>, <a href="https://github.com/symbioticMe/batch_effects_workflow_code">GitHub repository</a>都可获取该R包)  </p>
<h3 id="流程图总览"><a href="#流程图总览" class="headerlink" title="流程图总览"></a>流程图总览</h3><p><img src="/2021/10/29/BatchEffect/workflow.png" alt="批次效应处理流程图">  </p>
<ol>
<li>初步评估原始数据中是否存在批次效应  </li>
<li>归一化使数据集中所有数据在同一尺度  </li>
<li>归一化后数据评估，以确定数据是否需要进一步处理  </li>
<li>批次效应校正以纠正特征偏移  </li>
<li>质量控制测试：是否在保留有意义信号的同时减少了数据偏差  </li>
</ol>
<h3 id="Raw-Data-Matrix"><a href="#Raw-Data-Matrix" class="headerlink" title="Raw Data Matrix"></a>Raw Data Matrix</h3><p>在进行这一流程之前，应当先对数据进行预处理，如肽段识别、肽段定量、FDR筛选、log-transformed或variance stabilizing transformation。<br>虽然在ion fragment、peptides、protein层面都可以识别并处理批次效应，但因为这个过程改变了对蛋白质推断至关重要的特征丰度，最好针对ion fragment或peptides数据处理批次效应。且在处理过程中应包含尽可能多的数据以保证数据分布最接近真实情况。  </p>
<h3 id="Initial-Assessment"><a href="#Initial-Assessment" class="headerlink" title="Initial Assessment"></a>Initial Assessment</h3><p>这一步骤主要目的是确定数据的偏移程度并确定一个归一化方法。通常情况下，样本间intensity会有一定差异，调整这种差异有助于数据的比较，能够更好地识别出需要进一步处理的因素。主要方法有三种：</p>
<ol>
<li>按照质谱测量或技术批次的顺序绘制样品强度平均值或中值，评估每个批次中的质谱漂移或离散偏差  </li>
<li>箱线图，评估样本方差和异常值  </li>
<li>批次间与批次内样本相关性  </li>
</ol>
<p>通过上述步骤来检验</p>
<ul>
<li>数据分布是否具有一致性  </li>
<li>样本间的相关性  </li>
<li>如果有差异，这种差异是否与批次相关联  </li>
</ul>
<h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>归一化的目的就是将所有样本的数据处于同一尺度，使得跨样本数据能够互相比较。常用的归一化方法有quantile normalization、median normalization和z-transformation，应根据数据的异质性和数据分布情况选择合适的归一化方法。  </p>
<h4 id="数据的异质性"><a href="#数据的异质性" class="headerlink" title="数据的异质性"></a>数据的异质性</h4><ul>
<li><strong>数据相似程度高：</strong> quantile normalization  </li>
<li><strong>数据具有本质差异：</strong> HMM-assisted normalization  </li>
<li><strong>数据会有包含信息的异常值(outliers)：</strong> 选择能够保留异常值与总体数据关系的归一化方法  </li>
</ul>
<h4 id="样本丰度分布"><a href="#样本丰度分布" class="headerlink" title="样本丰度分布"></a>样本丰度分布</h4><ul>
<li>通常情况下，只需调整数据中位数或平均值  </li>
<li>如果出现方差差异较大，也需要将它们调整到同一尺度</li>
</ul>
<p>归一化步骤应尽可能简单直接，对数据的操作越少，越能够保留数据的真实情况。归一化后可通过diagnostic plots和quality control方法对数据进行评估。</p>
<h3 id="Diagnostics-of-normalized-data"><a href="#Diagnostics-of-normalized-data" class="headerlink" title="Diagnostics of normalized data"></a>Diagnostics of normalized data</h3><p>评估归一化后的数据以确定是否需要进一步的处理，主要方法为：</p>
<ul>
<li><strong>Hierarchical clustering：</strong>  将相似的样本分组为树状结构，观察聚类结果是否和批次相关  </li>
<li><strong>Principal Component Analysis(PCA):</strong> 观察主成分是否与批次相关联，对评估聚类依据是生物还是技术因素及检查重复组相似性十分有效  </li>
</ul>
<p>上述方法要求数据中没有缺失值，而蛋白质组数据通常含有缺失值。填补缺失值时应特别注意尽可能保留数据原有的分布，不能盲目填0或一个较小的随机数。<br>蛋白质组通常使用肽段数据检查是否存在与批次相关的偏移。如在DIA数据中加入iRT肽段用于数据特征校正。由于不同肽段对不同批次效应的response不同，有必要检查大量肽段以确定是否存在批次效应。通过检查肽段数据还能够确认跑样顺序是否对数据造成影响，是否有与顺序相关的变化趋势(trends)。<br>还可以用ion fragments的数据校正蛋白数据，但目前针对肽段的方法更加广泛。  </p>
<h3 id="Batch-effect-correction"><a href="#Batch-effect-correction" class="headerlink" title="Batch effect correction"></a>Batch effect correction</h3><p>归一化能够校准数据的全局，而批次效应校正主要针对特征峰和特征组。根据批次效应的形式，可将消除批次效应的方法分为两大类：</p>
<ul>
<li><strong>Continuous</strong><br>消除连续的批次效应主要通过拟合的方式，如LOESS fit，或使用其它连续算法。<br>在质谱大数据(hundreds of samples)中会出现信号漂移现象，这仍是一个亟待解决的问题。  </li>
<li><strong>Discrete</strong><br>消除离散的批次效应时常用mean and median centering。<br>基于贝叶斯模型的ComBat算法也能够用于处理蛋白质数据，但需要已知所有的批次效应影响因素。</li>
</ul>
<h3 id="Quality-control"><a href="#Quality-control" class="headerlink" title="Quality control"></a>Quality control</h3><p>质控步骤主要用于评估归一化和批次效应校正之后的数据质量，好的数据校正应做到消除偏移(negative control)和提升数据(positive control)两方面。  </p>
<ul>
<li><strong>消除偏移的标准</strong>  <ul>
<li>聚类或PCA后，同组数据聚集依据与批次无关，更多地受生物学因素影响  </li>
<li>肽段(或其他特征，如ion fragments)没有与批次相关的偏移  </li>
</ul>
</li>
<li><strong>提升数据</strong><ul>
<li>通常情况下，数据提升的标准为聚类结果更符合生物学先验知识，后续差异检验步骤能够识别出更多差异。但这种标准并不具有足够的客观性，尤其是后一个标准并不一定表明数据提升，还有可能是false positive  </li>
<li>交叉验证：差异表达蛋白或最佳分类特征蛋白列表高度重合。但这种方法依赖于数据集和特征空间的大小，当数据集较小，后一个蛋白列表本身不稳定，会对评估造成影响。在另一篇综述中强调应避免交叉验证来评估数据质量  </li>
<li>检查重复组间的方差：如果数据的归一化和消除批次效应步骤合理，重复组间的方差应降低  </li>
<li>样本间相关性：技术或生物学重复样本间的相关性应明显高于与其它样本的相关性  </li>
<li>距离矩阵：与上一方法的逻辑相似，但通过计算样本间距离来评估数据  </li>
<li>肽段间的相关性：来自同一蛋白的肽段具有正相关或高相关性，而来自不同蛋白或不相关的肽段间的相关性应接近于0  </li>
</ul>
</li>
</ul>
<br>

<h2 id="消除批次效应的方法-工具"><a href="#消除批次效应的方法-工具" class="headerlink" title="消除批次效应的方法/工具"></a>消除批次效应的方法/工具</h2><h3 id="ComBat"><a href="#ComBat" class="headerlink" title="ComBat"></a>ComBat</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>ComBat基于参数和非参数经验贝叶斯框架，用于调整具有批次效应的数据。该方法对小样本中的异常值具有健壮性，并且与大样本的现有方法相当。<br>以Microarray为研究对象。  </p>
<h4 id="经验贝叶斯框架使用基础"><a href="#经验贝叶斯框架使用基础" class="headerlink" title="经验贝叶斯框架使用基础"></a>经验贝叶斯框架使用基础</h4><ul>
<li>已经广泛用于大规模microarray数据：稳定具有极高或极低比率的基因的表达比，缩小所有其他基因的方差来稳定基因方差避免伪影的影响等  </li>
<li>已有批次效应处理方法(如SVD、DWD和L/S method)需要大批量数据，且不能兼容小批次数据的离群值  </li>
<li>对高位效数据组有较强的健壮性  </li>
<li>利用跨基因和跨样本的“借用信息”，以得到更好的估计或更稳定的结果  </li>
</ul>
<h4 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h4><ul>
<li>结合基因间常见的系统批次效应，假设导致批次效应的现象通常以相似的方式影响许多基因  </li>
<li>通过汇集信息(pooling information)来估计代表批次效应的L/S模型参数，在每个批次的基因中缩减(shrink)批次效应参数估计值，使之朝着批次效应估计值的总体平均值(跨基因)发展  </li>
<li>数据已被归一化，所有样本的基因表达值已被估计  </li>
</ul>
<h4 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h4><ol>
<li>Standardize the data  </li>
<li>EB batch effect parameter estimates using parametric empircal priors  </li>
<li>Adjust the data for batch effects  </li>
</ol>
<h3 id="QC-RLSC"><a href="#QC-RLSC" class="headerlink" title="QC-RLSC"></a>QC-RLSC</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>QC-RLSC(quality control-based robust LOESS signal correction)可用于信号校正和整合来自不同实验批次的数据。<br>以Metabolics数据为研究对象。  </p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>LOESS曲线拟合结合了经典的线性最小二乘法回归的简单性和非线性回归的灵活性。它通过对数据的局部子集进行简单的模型拟合来建立一个函数，逐点地描述数据中的确定性变化部分。不需要指定任何形式的全局函数来拟合数据的模型，而只需要拟合数据的片段。<br>对数据的每个子集进行拟合的局部多项式被限制为一阶或二阶(即局部线性或局部二阶)，并使用加权最小二乘法拟合(标准三立方权重函数)。<br>优化平滑参数(或称跨度)以获得更好的回归曲线。不使用过小的平滑参数以避免曲线受到随机误差的影响。<br>留一法交叉验证(leave-one-out cross validation)以避免过拟合。  </p>
<h4 id="关键步骤-1"><a href="#关键步骤-1" class="headerlink" title="关键步骤"></a>关键步骤</h4><ol>
<li>在实验结束、色谱解卷积后，使用QC-RLSC对数据进行标准化(normalize)</li>
<li>依据注入顺序，对质控数据进行LOESS拟合</li>
<li>对整个分析运行的校正曲线进行内插，并对该特征的总数据集进行标准化</li>
</ol>
<p>通过这些步骤，在一次分析中，峰响应的任何衰减都被最小化。</p>
<h3 id="ICA"><a href="#ICA" class="headerlink" title="ICA"></a>ICA</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>使用时空独立成分分析(spatio-temporal independent component analysis)对批次效应建模，并移除这些影响。<br>以microarray datasets为研究对象。  </p>
<h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>对整合的数据集进行因子分解(factorization)，移除与子数据集具有某种相关性的组件，以获得最终数据集。这一过程能够从数据中移除批次效应。<br>去除的成分是可以解释的，很容易检查它们是否与某些感兴趣的生物信息相关。<br>ICA被证明能更好地模拟不同的变异(variables)来源。  </p>
<h4 id="关键步骤-2"><a href="#关键步骤-2" class="headerlink" title="关键步骤"></a>关键步骤</h4><p>假设汇总的数据集是一个按样本划分的基因矩阵<em>X</em>，<em>X</em><sub>i,j</sub> 表明gene <em>i</em> 在样本 <em>j</em> 中的表达量。<br><img src="/2021/10/29/BatchEffect/ICAsteps.png" alt="ICA流程">  </p>
<h3 id="WaveICA"><a href="#WaveICA" class="headerlink" title="WaveICA"></a>WaveICA</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>WaveICA基于带有小波变换的独立成分分析，作为大规模代谢组学数据的阈值处理方法捕获并去除批次效应。<br>研究对象为Metabolics数据。  </p>
<h4 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h4><p>利用样品在注射顺序中的时间趋势，将原始数据分解为具有不同特征的多尺度数据，提取并去除多尺度数据中的批次效应信息，获得干净的数据。<br>在实际问题中DWT有局限性，WaveICA中使用的小波变换为Maximal overlap discrete wavelet transform (MODWT)。  </p>
<h4 id="关键步骤-3"><a href="#关键步骤-3" class="headerlink" title="关键步骤"></a>关键步骤</h4><p><img src="/2021/10/29/BatchEffect/WaveICA.png" alt="WaveICA流程">  </p>
<h3 id="NormAE"><a href="#NormAE" class="headerlink" title="NormAE"></a>NormAE</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>Normlization Autoencoder(NormAE)基于非线性自编码器和对抗性学习的新型深度学习模型。<br>研究对象为Metabolics数据。  </p>
<h4 id="基本原理-3"><a href="#基本原理-3" class="headerlink" title="基本原理"></a>基本原理</h4><p>将非线性自编码器和DNN结合，提高模型的非线性拟合能力，使得批次效应结果和其它因素影响结果分开，以在去除批次效应的同时保留更多生物学特征。<br>在AE模型的训练过程中，训练一个额外的分类器和排序器来对抗性正则化，潜在的特征被编码器提取出来，然后解码器在没有批次效应的情况下重建数据。  </p>
<h4 id="关键步骤-4"><a href="#关键步骤-4" class="headerlink" title="关键步骤"></a>关键步骤</h4><p>黑色实线和红色虚线分别表示反向传播算法的前向和后向计算步骤。蓝色虚线路径表示训练后的批量效应去除步骤。<br><img src="/2021/10/29/BatchEffect/NormAE.png" alt="NormAE原理图">  </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Leek, Jeffrey T et al. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3880143/"><strong>Tackling the widespread and critical impact of batch effects in high-throughput data.</strong></a> Nature reviews. Genetics, vol. 11,10 (2010): 733-9.<br>[2] Čuklina, Jelena et al. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8447595/"><strong>Diagnostics and correction of batch effects in large-scale proteomic studies: a tutorial.</strong></a> Molecular systems biology, vol. 17,8 (2021): e10240.<br>[3] Zhou, Longjian et al. <a href="https://pubmed.ncbi.nlm.nih.gov/31611172/"><strong>Examining the practical limits of batch effect-correction algorithms: When should you care about batch effects?</strong></a>, Journal of Genetics and Genomics, Vol. 46, 9(2019): 433-443.<br>[4] Goh, Wilson Wen Bin et al. <a href="https://pubmed.ncbi.nlm.nih.gov/28351613/"><strong>Why Batch Effects Matter in Omics Data, and How to Avoid Them.</strong></a> Trends Biotechnol, Vol. 35, 6 (2017):498-507.<br>[5] Johnson, WE et al. <a href="https://academic.oup.com/biostatistics/article/8/1/118/252073/"><strong>Adjusting batch effects in microarray expression data using empirical Bayes methods.</strong></a> Biostatistics, Vol. 8, 1 (2007): 118–127.<br>[6] Dunn, W et al. <a href="https://www.nature.com/articles/nprot.2011.335/"><strong>Procedures for large-scale metabolic profiling of serum and plasma using gas chromatography and liquid chromatography coupled to mass spectrometry.</strong></a> Nature Protocol, 6 (2011): 1060–1083.<br>[7] Sompairac, Nicolas et al. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6771121/"><strong>Independent Component Analysis for Unraveling the Complexity of Cancer Omics Datasets.</strong></a> International journal of molecular sciences. vol. 20, 18 (2019): 4414.<br>[8] Deng, Kui et al. <a href="https://www.sciencedirect.com/science/article/abs/pii/S0003267019301849/"><strong>WaveICA: A novel algorithm to remove batch effects for large-scale untargeted metabolomics data based on wavelet analysis.</strong></a> Analytica Chimica Acta, Vol. 1061, (2019): 60-69.<br>[9] Rong, Zhiwei et al. <a href="https://pubs.acs.org/doi/10.1021/acs.analchem.9b05460/"><strong>NormAE: Deep Adversarial Learning Model to Remove Batch Effects in Liquid Chromatography Mass Spectrometry-Based Metabolomics Data.</strong></a> Analytical Chemistry, Vol. 92, 7 (2020): 5082–5090.  </p>
]]></content>
      <categories>
        <category>Paper</category>
        <category>BatchEffects</category>
      </categories>
      <tags>
        <tag>Bioinformatics</tag>
        <tag>BatchEffects</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 3：Transport Layer</title>
    <url>/2022/04/19/computernetworknotes3/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络第三章传输层 </center>
<span id="more"></span>

<br>

<h2 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h2><h3 id="传输服务和协议"><a href="#传输服务和协议" class="headerlink" title="传输服务和协议"></a>传输服务和协议</h3><p>为运行在不同主机上的应用进程提供<strong>逻辑通信</strong>，即进程到进程的远程逻辑通信  </p>
<p>传输协议运行在<strong>端系统</strong>  </p>
<ul>
<li>发送方：将应用层的报文分成<strong>报文段</strong>，然后传递给网络层  </li>
<li>接收方：将报文段重组成报文，然后传递给应用层  </li>
</ul>
<p>有多个传输层协议可供选择  </p>
<ul>
<li>Internet：TCP 和 UDP  </li>
</ul>
<h3 id="传输层-vs-网络层"><a href="#传输层-vs-网络层" class="headerlink" title="传输层 vs 网络层"></a>传输层 vs 网络层</h3><p>网络层服务：主机之间的逻辑通信<br>传输层服务：进程间的逻辑通信  </p>
<ul>
<li>依赖于网络层的服务：延时、带宽 (不可加强)  </li>
<li>加强网络层的服务：弥补可靠性，减少数据丢失、顺序混乱 (不可靠 -&gt; 可靠)；加密 (安全)；复用/解复用  </li>
</ul>
<h3 id="Internet-传输层协议"><a href="#Internet-传输层协议" class="headerlink" title="Internet 传输层协议"></a>Internet 传输层协议</h3><p>可靠地、保序的传输：TCP (字节流)  </p>
<ul>
<li>多路复用、解复用  </li>
<li>拥塞控制  </li>
<li>流量控制  </li>
<li>建立连接  </li>
</ul>
<p>不可靠、不保序的传输：UDP (数据报)  </p>
<ul>
<li>多路复用、解复用  </li>
<li>没有为尽力而为的 IP 服务添加更多的其它额外服务  </li>
</ul>
<p>都不提供的服务：延时保证、带宽保证  </p>
<br>  

<h2 id="多路复用和解复用"><a href="#多路复用和解复用" class="headerlink" title="多路复用和解复用"></a>多路复用和解复用</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>在发送方主机多路复用</strong>：从多个套接字接受来自多个进程的报文，根据套接字对应的 IP 地址和端口号等信息对报文段用头部加以封装，该头部信息用于以后的解复用<br><strong>在接收方主机多路解复用</strong>：根据报文段的头部信息种的 IP 地址和端口号将接收到的报文段发给正确的套接字和对应的应用进程  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPfuyong.png" alt="TCP 复用解复用">  </p>
<p><img src="/2022/04/19/computernetworknotes3/UDPfuyong.png" alt="UDP 复用解复用">  </p>
<h3 id="多路解复用工作原理"><a href="#多路解复用工作原理" class="headerlink" title="多路解复用工作原理"></a>多路解复用工作原理</h3><p><strong>解复用作用</strong>：TCP 或者 UDP 实体采用哪些信息，将报文段的数据部分交给正确的 socket，从而交给正确的进程  </p>
<p>主机收到 IP 数据报  </p>
<ul>
<li>每个数据包有源 IP 地址和目标地址  </li>
<li>每个数据报承载一个传输层报文段  </li>
<li>每个报文段有一个源端口号和目标端口号 (特定应用有著名的端口号)  </li>
</ul>
<p>主机联合使用 <strong>IP 地址</strong>和<strong>端口号</strong>将报文段发送给合适的套接字  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPUDPbaowen.png" alt="TCP/UDP 报文段格式">  </p>
<h4 id="无连接-UDP-多路解复用"><a href="#无连接-UDP-多路解复用" class="headerlink" title="无连接 (UDP) 多路解复用"></a>无连接 (UDP) 多路解复用</h4><p><strong>创建套接字</strong>：  </p>
<ul>
<li>服务器端  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">serverSocket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);  </span><br><span class="line"><span class="built_in">bind</span>(serverSocket, &amp;sad, <span class="built_in"><span class="keyword">sizeof</span></span>(sad));  </span><br><span class="line"><span class="comment">// serverSocket 和 Sad指定的端口号捆绑 (UDP 和 TCP 不同)  </span></span><br></pre></td></tr></table></figure>
</li>
<li>客户端  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClientSocket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM,<span class="number">0</span>);  </span><br><span class="line"><span class="comment">// 没有Bind、ClientSocket 和 OS 为之分配的某个端口号捆绑  </span></span><br><span class="line"><span class="comment">// 客户端使用什么端口号无所谓，客户端主动找服务器  </span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>在接收端，UDP 套接字用二元组标识 (目标 IP 地址、目标端口号)  </p>
<p>当主机收到 UDP 报文段  </p>
<ul>
<li>检查报文段的目标端口号  </li>
<li>用该端口号将报文段定位给套接字  </li>
</ul>
<p>如果两个不同源 IP 地址/源端口号的数据报，但是<strong>有相同的目标 IP 地址和端口号</strong>，则被定位到相同的套接字  </p>
<ul>
<li>创建拥有本地端口号的套接字  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DatagramSocket mySocket1 = <span class="keyword">new</span> <span class="built_in">DatagramSocket</span>(<span class="number">12534</span>);  </span><br></pre></td></tr></table></figure></li>
<li>当创建 UDP 段采用端口号，可以指定：目标 IP 地址、目标端口号  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/UDPfuyongeg.png" alt="无连接多路复用例子">  </p>
<p><img src="/2022/04/19/computernetworknotes3/mianxianglianjiedejiefuyong.png" alt="面向连接的解复用例子">  </p>
<br>

<h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><h3 id="UDP：User-Datagram-Protocol-RFC-768"><a href="#UDP：User-Datagram-Protocol-RFC-768" class="headerlink" title="UDP：User Datagram Protocol [RFC 768]"></a>UDP：User Datagram Protocol [RFC 768]</h3><p>“no frills”, “bare bones” Internet 传输协议<br>“尽力而为”的服务，报文可能丢失、送到应用程序的报文段乱序  </p>
<p><strong>无连接</strong>  </p>
<ul>
<li>UDP 发送端和接收端之间没有握手  </li>
<li>每个 UDP 报文段都被独立地处理  </li>
</ul>
<p>UDP 被用于  </p>
<ul>
<li>流媒体：丢失不敏感，速率敏感、应用可控制传输速率  </li>
<li>DNS  </li>
<li>SNMP  </li>
</ul>
<p>在 UDP 上实现可靠传输：  </p>
<ul>
<li>在应用层增加可靠性  </li>
<li>应用特定的差错恢复  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/UDPform.png" alt="UDP 报文段格式">  </p>
<h3 id="为什么要有-UDP"><a href="#为什么要有-UDP" class="headerlink" title="为什么要有 UDP"></a>为什么要有 UDP</h3><p>不建立连接(会增加延时)<br>简单：在发送端和接收端没有连接状态<br>报文段的头部很小 (开销小)<br>无拥塞控制和流量控制，UDP 可以尽可能快的发送报文段：应用 -&gt; 传输的速率 = 主机 -&gt; 网络的速率  </p>
<h3 id="UDP-校验和-check-sum"><a href="#UDP-校验和-check-sum" class="headerlink" title="UDP 校验和 (check sum)"></a>UDP 校验和 (check sum)</h3><p><strong>目标</strong>：检测在被传输报文段种的差错，如比特反转  </p>
<p>发送方：  </p>
<ul>
<li>将报文段的内容视为 16 比特的整数  </li>
<li>校验和：报文段的加法和 (1 的补运算)  </li>
<li>发送方将校验和放在 UDP 的校验和字段  </li>
</ul>
<p>接收方：  </p>
<ul>
<li>计算接收到的报文段的校验和  </li>
<li>检查计算处的校验和与校验和字段的内容是否相等  <ul>
<li>不相等 —— 检测到差错  </li>
<li>相等 —— 没有检测到差错，但也许还是有差错 (残存错误)  </li>
</ul>
</li>
</ul>
<h4 id="Internet-校验和例子：进位回滚"><a href="#Internet-校验和例子：进位回滚" class="headerlink" title="Internet 校验和例子：进位回滚"></a>Internet 校验和例子：进位回滚</h4><p>当数字相加时，在最高位的进位要回卷，再加到结果上<br>目标端：校验范围 + 校验和 = 1111111111111111 通过校验，否则没有通过校验  </p>
<p><img src="/2022/04/19/computernetworknotes3/jinweihuijuan.png" alt="进位回卷例子"></p>
<p><em>求和时，必须将进位回卷到结果上</em>  </p>
<br>  

<h2 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h2><h3 id="可靠数据传输-RDT"><a href="#可靠数据传输-RDT" class="headerlink" title="可靠数据传输 (RDT)"></a>可靠数据传输 (RDT)</h3><p>RDT 在应用层、传输层和数据链路层都很重要<br>信道的不考考特点决定了可靠数据传输协议的复杂性  </p>
<h4 id="可靠数据传输：问题描述"><a href="#可靠数据传输：问题描述" class="headerlink" title="可靠数据传输：问题描述"></a>可靠数据传输：问题描述</h4><p><img src="/2022/04/19/computernetworknotes3/RDT.png" alt="可靠数据传输：问题描述">  </p>
<p>渐增式地开发可靠数据传输协议 (RDT) 的发送方和接收方<br>只考虑单项数据传输，但控制信息是双向流动的<br>双向的数据传输问题实际上是 2 个单项数据传输问题的综合<br>使用有限状态机 (FSM) 来描述发送方和接收方  </p>
<p><strong>状态</strong>：在该状态时，下一个状态只由下一个事件唯一决定  </p>
<p><img src="/2022/04/19/computernetworknotes3/zhuangtai.png"></p>
<h3 id="可靠数据传输协议：停止-等待"><a href="#可靠数据传输协议：停止-等待" class="headerlink" title="可靠数据传输协议：停止-等待"></a>可靠数据传输协议：停止-等待</h3><h4 id="RDT-1-0：在可靠信道上的可靠数据传输"><a href="#RDT-1-0：在可靠信道上的可靠数据传输" class="headerlink" title="RDT 1.0：在可靠信道上的可靠数据传输"></a>RDT 1.0：在可靠信道上的可靠数据传输</h4><p>下层的信道是完全可靠的  </p>
<ul>
<li>没有比特出错  </li>
<li>没有分组丢失  </li>
</ul>
<p>发送方和接收方的 FSM  </p>
<ul>
<li>发送方将数据发送到下层信道  </li>
<li>接收方从下层信道接收数据  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT1.png">  </p>
<h4 id="RDT-2-0：具有比特差错的信道"><a href="#RDT-2-0：具有比特差错的信道" class="headerlink" title="RDT 2.0：具有比特差错的信道"></a>RDT 2.0：具有比特差错的信道</h4><p>下层信道可能会出错：将分组中的比特翻转  </p>
<ul>
<li>用校验和来检测比特差错  </li>
</ul>
<p>问题：怎样从差错中回复  </p>
<ul>
<li>确认 (ACK)：接收方显示地告诉发送方分组已被正确接收  </li>
<li>否定确认 (NAK)：接收方显示地告诉发送方分组发生了差错；发送方收到 NAK 后，重传分组  </li>
</ul>
<p>RDT 2.0 的新机制：采用差错控制编码进行差错检测  </p>
<ul>
<li>发送方差错控制编码、缓存  </li>
<li>接收方使用编码检错  </li>
<li>接收方的反馈：控制报文 (ACK, NAK)；接收方 -&gt; 发送方  </li>
<li>发送方收到反馈相应的动作  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT2.png">  </p>
<h4 id="缺陷-gt-RDT-2-1"><a href="#缺陷-gt-RDT-2-1" class="headerlink" title="缺陷 (-&gt; RDT 2.1)"></a>缺陷 (-&gt; RDT 2.1)</h4><p>如果 ACK/NAK 出错  </p>
<ul>
<li>发送方不知道接收方发生了什么事情  </li>
<li>发送方重传，可能重复；不重传，可能死锁 (或出错)  </li>
<li>需要引入新的机制：序号 (sequence number)  </li>
</ul>
<p>处理重复  </p>
<ul>
<li>发送方在每个分组中加入序号  </li>
<li>如果 ACK/NAK 出错，发送方<strong>重传</strong>当前分组  </li>
<li>接收方丢弃 (不发给上层) 重复分组  </li>
<li><strong>停等协议</strong>：发送方发送一个分组，然后等待接收方的应答  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT21send.png" alt="RDT 2.1 发送方处理出错的 ACK/NAK">  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT21receive.png" alt="RDT 2.1 接收方处理出错的 ACK/NAK">  </p>
<p>发送方：  </p>
<ul>
<li>在分组中加入序列号  </li>
<li>两个序列号 (0, 1)就足够：一次只发送一个未经确认的分组  </li>
<li>必须检测 ACK/NAK 是否出错 (需要 EDC)  </li>
<li>状态数变成了两倍：必须记住当前分组的序列号是 0 还是 1  </li>
</ul>
<p>接收方：  </p>
<ul>
<li>必须检测接收到的分组是否是重复的：状态会指示希望接收到的分组的序号为 0 还是 1  </li>
<li>接收方并不知道发送方是否正确收到了 ACK/NAK  <ul>
<li>发送方不对收到的 ACK/NAK 给确认，没有安排确认的确认  </li>
<li>接收方发送 ACK，如果后面接收方收到的是老分组 P0，则 ACK 错误；收到下一个分组 P1，则 ACK 正确  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/rdt21ackerror.png" alt="RDT 2.1 ACK error">  </p>
<p><img src="/2022/04/19/computernetworknotes3/rdt21ackright.png" alt="RDT 2.1 ACK right">  </p>
<h4 id="RDT-2-2：无-NAK-的协议"><a href="#RDT-2-2：无-NAK-的协议" class="headerlink" title="RDT 2.2：无 NAK 的协议"></a>RDT 2.2：无 NAK 的协议</h4><p>功能同 RDT 2.1，但只使用 ACK (ACK 要编号)<br>接收方对<strong>最后</strong>正确接收的分组发 ACK，以替代 NAK：接收方必须显示地包含被正确接收分组的<strong>序号</strong><br>当收到重复的 ACK (如再次收到 ACK0) 时，发送方与收到 NAK 采取相同的动作：重传当前分组<br>为后面的一次发送多个数据单位做准备  </p>
<ul>
<li>一次能够发送多个  </li>
<li>每一个的应答都有 ACK/NAK 麻烦  </li>
<li>使用对前一个数据单位的 ACK，代替本数据单位的 NAK  </li>
<li>确认信息减少一半，协议处理简单  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/NAKfree.png" alt="NAK free">  </p>
<p><em>达成不要 NAK 的目标</em>  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT22.png" alt="RDT 2.2 的运行">  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT22xu.png" alt="RDT 2.2 的运行"></p>
<p><img src="/2022/04/19/computernetworknotes3/RDT22SR.png" alt="RDT 2.2：发送方和接收方片段">  </p>
<h4 id="RDT-3-0：具有比特差错和分组丢失的信道"><a href="#RDT-3-0：具有比特差错和分组丢失的信道" class="headerlink" title="RDT 3.0：具有比特差错和分组丢失的信道"></a>RDT 3.0：具有比特差错和分组丢失的信道</h4><p><strong>新的假设</strong>：下层信道可能会丢失分组 (数据或 ACK)  </p>
<ul>
<li>会死锁  </li>
<li>机制还不够处理这种状况：检验和、序列号、ACK、重传</li>
</ul>
<p><strong>方法</strong>：发送方等待 ACK 一段<strong>合理的时间</strong>  </p>
<ul>
<li>发送端超时重传：如果到时没有收到 ACK -&gt; 重传  </li>
<li>问题：如果分组 (或 ACK) 只是被延迟了<ul>
<li>重传会导致数据重复，但利用<strong>序列号</strong>可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号  </li>
</ul>
</li>
<li>需要一个倒数定时器  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT3send.png" alt="RDT 3.0 发送方">  </p>
<p>过早超时 (延迟的 ACK) 也能够正常工作，但是效率较低，一般的分组和确认是重复的<br>设置一个合理的超时时间比较重要  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT3delayedACK.png" alt="RDT 3.0 过早超时">  </p>
<p>性能：  </p>
<ul>
<li>RDT 3.0 可以工作，但链路容量比较大的情况下，性能很差  <ul>
<li>链路容量比较大，一次发一个 PDU 不能充分利用链路的传输能力</li>
<li>瓶颈在于网络协议限制了物理资源的利用  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT3xingneng.png" alt="RDT 3.0 在链路容量大的情况下效率较低">  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT3xingneng2.png" alt="RDT 3.0 停止-等待">  </p>
<h3 id="可靠数据传输协议：流水线"><a href="#可靠数据传输协议：流水线" class="headerlink" title="可靠数据传输协议：流水线"></a>可靠数据传输协议：流水线</h3><h4 id="流水线-pipeline-协议"><a href="#流水线-pipeline-协议" class="headerlink" title="流水线 (pipeline) 协议"></a>流水线 (pipeline) 协议</h4><p><strong>流水线</strong>：允许发送方在<strong>未得到对方确认</strong>的情况下，一次发送多个分组  </p>
<ul>
<li>必须增加序号的范围：用多个 bit 表示分组的序号  </li>
<li>在发送方/接收方要有缓冲区  <ul>
<li>发送方缓冲：未得到确认，可能需要重传  </li>
<li>接收方缓存：上层用户去用数据的速率 ≠ 接收到的数据速率；接收到的数据可能乱序，排序交付 (可靠)  </li>
</ul>
</li>
<li>两种通用的流水线协议：回退 N 步 (GBN) 和选择重传 (SR)  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT3liushuixian.png" alt="流水线：提高链路利用率">  </p>
<h4 id="通用：滑动窗口-slide-window-协议"><a href="#通用：滑动窗口-slide-window-协议" class="headerlink" title="通用：滑动窗口 (slide window) 协议"></a>通用：滑动窗口 (slide window) 协议</h4><p>发送缓冲区  </p>
<ul>
<li>形式：内存中的一个区域，落入缓冲区的分组可以发送  </li>
<li>功能：用于存放已发送，但是没有得到确认的分组  </li>
<li>必要性：需要重发时可用  </li>
</ul>
<p>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组  </p>
<ul>
<li>停止等待协议 = 1  </li>
<li>流水线协议 &gt; 1；合理的值，不能很大，链路的利用率不能超过 100 %  </li>
</ul>
<p>发送缓冲区中的分组  </p>
<ul>
<li>未发送的：落入发送缓冲区中的分组，可以连续发送出去  </li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除  </li>
</ul>
<p>发送窗口滑动过程 - 相对表示方法  </p>
<ul>
<li>采用相对移动方式表示，分组不动  </li>
<li>可缓冲范围移动，代表一段可以发送的权力  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/xiangduihuadong.png" alt="发送滑动窗口过程的相对表示方法">  </p>
<p><strong>滑动窗口协议 - 发送窗口</strong>  </p>
<ul>
<li>发送窗口  <ul>
<li>发送缓冲区内容的一个范围  </li>
<li>那些已发送但是未经确认分组的序号构成的空间  </li>
</ul>
</li>
<li>发送窗口的最大值 ≤ 发送缓冲区的值  </li>
<li>一开始：没有发送任何一个分组  <ul>
<li>后沿 = 前沿  </li>
<li>之间为发送窗口的尺寸 = 0  </li>
</ul>
</li>
<li>每发送一个分组，前沿移动一个单位  </li>
<li>发送窗口前沿移动的极限：不能超过发送缓冲区</li>
<li>发送窗口后沿移动  <ul>
<li>条件：收到老分组的确认  </li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送  </li>
<li>移动的极限：不能超过前沿，即后沿贴到前沿  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/sendingwindow.png" alt="发送窗口 (sending window)"></p>
<p><strong>滑动窗口协议 - 接收窗口</strong>  </p>
<ul>
<li>接收窗口 (receiving window) = 接收缓冲区  </li>
<li>接收窗口用于控制那些分组可以接收  <ul>
<li>只有收到的分组序号落入接收窗口内才允许接收  </li>
<li>若序号再接收窗口之外，则丢弃 </li>
</ul>
</li>
<li>接收窗口尺寸<ul>
<li>接收窗口尺寸 Wr = 1，则只能顺序接收  </li>
<li>接收窗口尺寸 Wr &gt; 1，则可以乱序接收，但提交给上层的分组要按序  </li>
</ul>
</li>
<li>接收窗口的滑动  <ul>
<li>低序号分组的到来，接收窗口移动  </li>
<li>高序号分组乱序到，缓存但不交付 (因为要实现 RDT，不允许失序)，不滑动  </li>
</ul>
</li>
<li>接收窗口的发送确认  <ul>
<li>接收窗口尺寸 = 1：发送连续收到的最大的分组确认 (累计确认)  </li>
<li>接收窗口尺寸 &gt; 1：收到分组，发送那个分组的确认 (非累计确认/独立确认)  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/receivingwindow.png" alt="接收窗口 (receiving window)"></p>
<p><strong>正常情况下的 2 个窗口互动</strong>  </p>
<ul>
<li>发送窗口  <ul>
<li>有新的分组落入发送缓冲区范围，发送 -&gt; 前沿滑动  </li>
<li>来了老的低序号分组的确认 -&gt; 后沿向前滑动 -&gt; 新的分组可以落入发送缓冲区的范围  </li>
</ul>
</li>
<li>接收窗口  <ul>
<li>收到分组，落入到接收窗口范围内，接收  </li>
<li>是低序号，发送确认给对方  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/WWI.png" alt="发送窗口与接收窗口的互动">  </p>
<h4 id="异常情况下-GBN-与-SR-协议中的窗口互动"><a href="#异常情况下-GBN-与-SR-协议中的窗口互动" class="headerlink" title="异常情况下 GBN 与 SR 协议中的窗口互动"></a>异常情况下 GBN 与 SR 协议中的窗口互动</h4><p>异常情况下 GBN 的 2 窗口互动  </p>
<ul>
<li>发送窗口  <ul>
<li>新分组落入发送缓冲区范围，发送 -&gt; 前沿滑动  </li>
<li>超时重发机制让发送端将发送窗口中的所有分组发送出去  </li>
<li>来了老分组的重复确认 -&gt; 后沿不向前滑动 -&gt; 新的分组无法落入发送缓冲区的范围 (如果此时发送缓冲区有新的分组可以发送)  </li>
</ul>
</li>
<li>接收窗口  <ul>
<li>收到乱序分组，没有落入到接收窗口范围内，抛弃  </li>
<li>(重复) 发送老分组的确认，累计确认  </li>
</ul>
</li>
</ul>
<p>异常情况下 SR 的 2 窗口互动  </p>
<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送 -&gt; 前沿滑动  </li>
<li>超时重发机制让发送端将超时的分组重新发送出去  </li>
<li>来了乱序分组的确认 -&gt; 后沿不向前滑动 -&gt; 新的分组无法落入发送缓冲区的范围 (如果此时发送缓冲区有新的分组可以发送)  </li>
</ul>
</li>
<li>接收窗口  <ul>
<li>收到乱序分组，落入到接收窗口范围内，接收  </li>
<li>发送该分组的确认，单独确认  </li>
</ul>
</li>
</ul>
<p><em>每发送一个分组，就要设定一个超时定时器，接收到分组确认时取消定时器</em></p>
<p>GBN 协议和 SR 协议的相同之处    </p>
<ul>
<li>发送窗口 &gt; 1  </li>
<li>一次可发送多个未经确认的分组  </li>
</ul>
<p>GBN 协议和 SR 协议的不同之处 (主要由于接收窗口大小不同)  </p>
<ul>
<li>GBN：接收窗口尺寸 = 1  <ul>
<li>接收端：只能顺序接收  </li>
<li>发送端：从表现来看，一旦一个分组没有发送成功，就要退回重发 (如 0，1，2，3，4 中 1 未成功，234 都发送出去，要返回 1 再发送：GB1)</li>
</ul>
</li>
<li>SR：接收窗口尺寸 &gt; 1  <ul>
<li>接收端：可以乱序接收  </li>
<li>发送端：发送0，1，2，3，4 中 1 未成功，234 都发送出去，无需重发，选择性发送 1  </li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>GO-back-N</strong>  </p>
<ul>
<li>发送端最多在流水线中有 N 个未确认的分组  </li>
<li>接收端只是发送累计型确认 (cumulative ack)：接收端如果发现 gap，不确认信道来的分组  </li>
<li>发送端拥有对最老的未确认分组的定时器  <ul>
<li>秩序设置一个定时器  </li>
<li>当定时器到时时，重传所有未确认分组  </li>
</ul>
</li>
</ul>
<p>GBN：发送方扩展的 FSM  </p>
<p><img src="/2022/04/19/computernetworknotes3/GBNFSM.png" alt="GBN：发送方扩展的 FSM">  </p>
<p>GBN：接收方扩展的 FSM  </p>
<p><img src="/2022/04/19/computernetworknotes3/GBNFSMr.png" alt="GBN：接收方扩展的 FSM">  </p>
<ul>
<li>只发送 ACK：对顺序接收的最高序号的分组  <ul>
<li>可能会产生重复的 ACK  </li>
<li>只需记住 expectedseqnum；接收窗口 = 1；只一个变量就可以表示接收窗口  </li>
</ul>
</li>
<li>对乱序的分组  <ul>
<li>丢弃 (不缓存) -&gt; 在接收方不缓存  </li>
<li>对顺序接收的最高序号的分组进行确认 - 累计确认  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/runningGBN.png" alt="运行中的 GBN"></p>
<p><strong>Selective Repeat</strong>  </p>
<ul>
<li>发送端最多在流水线中有 N 个未确认的分组  </li>
<li>接收方对每个到来的分组单独确认 ACKn (individual ack)：非累计确认  <ul>
<li>接收窗口 &gt; 1，可以缓存乱序的分组  </li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li>发送方为每个未确认的分组保持一个定时器：当超时定时器到时时，只重发到时未确认分组  </li>
<li>发送窗口的最大值 (发送缓冲区) 限制发送未确认分组的个数  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/SRsummary.png">  </p>
<p><img src="/2022/04/19/computernetworknotes3/RunningSR.png" alt="选择重传 SR 的运行"></p>
<p><strong>对比 GBN 和 SR</strong>  </p>
<p><img src="/2022/04/19/computernetworknotes3/GBNvsSR.png">  </p>
<p>适用范围：  </p>
<ul>
<li>出错率低：比较适合 GBN，出错非常罕见，没有必要用复杂的 SR，为罕见的事件做日常准备和复杂处理  </li>
<li>链路容量大 (延迟大、带宽大)：适合 SR 而不是 GBN，否则一点出错代价太大  </li>
</ul>
<br>  

<h2 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h2><h3 id="TCP-概述"><a href="#TCP-概述" class="headerlink" title="TCP 概述"></a>TCP 概述</h3><p><strong>点对点</strong>：一个发送方，一个接收方<br><strong>可靠的、按顺序的字节流</strong>：没有报文边界<br><strong>管道化</strong> **(流水线)**：TCP 拥塞控制和流量控制设置窗口大小<br><strong>发送和接受缓存</strong><br><strong>全双工数据</strong>：在同一连接中数据流双向流动；MSS：最大报文段<br><strong>面向连接</strong>：在数据交换之前，通过握手 (交换控制报文) 初始化发送方、接收方的状态变量<br><strong>有流量控制</strong>：发送方不会淹没接收方  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPform.png" alt="TCP 报文段结构">  </p>
<h4 id="TCP-序号、确认号"><a href="#TCP-序号、确认号" class="headerlink" title="TCP 序号、确认号"></a>TCP 序号、确认号</h4><p><strong>序号</strong>：报文段首字节在字节流的编号<br><strong>确认号</strong>：期望从零乙方收到的下一个字节的序号；累计确认<br>Q：接收方如何处理乱序的报文段 - 没有规定  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPnumber.png">  </p>
<h3 id="TCP-往返延时-RTT-和超时"><a href="#TCP-往返延时-RTT-和超时" class="headerlink" title="TCP 往返延时 (RTT) 和超时"></a>TCP 往返延时 (RTT) 和超时</h3><h4 id="怎样设置-TCP-超时"><a href="#怎样设置-TCP-超时" class="headerlink" title="怎样设置 TCP 超时"></a>怎样设置 TCP 超时</h4><p>比 RTT 要长，但 RTT 是变化的<br>太短：太早超时，不必要的重传<br>太长：对报文段丢失反应太慢，消极  </p>
<h4 id="怎样估计-RTT？"><a href="#怎样估计-RTT？" class="headerlink" title="怎样估计 RTT？"></a>怎样估计 RTT？</h4><p>sampleRTT：测量从报文段发出到收到确认的时间</p>
<ul>
<li>如果又重传，忽略此次测量</li>
<li>定期测量  </li>
<li>sampleRTT 会变化，因此估计的 RTT 应该比较平滑</li>
<li>对几个最近的测量值求平均，而不是仅用当前的 sampleRTT  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/sampleRTT.png">  </p>
<h4 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h4><p>EstimtedRTT + 安全便捷时间：  </p>
<ul>
<li>EstimatedRTT 变化大 (方差大) -&gt; 较大的安全边界时间  </li>
</ul>
<p>SampleRTT 会偏离 EstimatedRTT 多远： </p>
<ul>
<li>DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT|  </li>
<li>推荐值：β = 0.25  </li>
</ul>
<p>超时时间间隔设置为：</p>
<ul>
<li>TimeoutInterval = EstimatedRTT + 4 * DevRTT  </li>
</ul>
<h3 id="TCP：可靠数据传输"><a href="#TCP：可靠数据传输" class="headerlink" title="TCP：可靠数据传输"></a>TCP：可靠数据传输</h3><p>TCP 在 IP 不可靠服务的基础上建立了 RDT  </p>
<ul>
<li>管道化 (pipeline) 的报文段：GBN or SR  </li>
<li>累计确认 (像 GBN)  </li>
<li>单个重传定时器 (像 GBN)  </li>
<li>是否可以接受乱序报文没有规范  </li>
</ul>
<p>通过以下事件触发重传  </p>
<ul>
<li>超时：只重发那个最早的未确认段 (SR)  </li>
<li>重复的确认：收到了 ACK50 之后又收到 3 个 ACK50  </li>
</ul>
<h4 id="简化的-TCP-发送方"><a href="#简化的-TCP-发送方" class="headerlink" title="简化的 TCP 发送方"></a>简化的 TCP 发送方</h4><ul>
<li>忽略重复的确认  </li>
<li>忽略流量控制和拥塞控制  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/TCPsendersimple.png" alt="TCP 发送方 (简化版)"></p>
<h4 id="TCP-发送方事件"><a href="#TCP-发送方事件" class="headerlink" title="TCP 发送方事件"></a>TCP 发送方事件</h4><p>从应用层接收数据：  </p>
<ul>
<li>用 nextseq 创建报文段  </li>
<li>序号 nextseq 为报文段首字节的字节流编号  </li>
<li>如果还没有运行，启动定时器  <ul>
<li>定时器与最早未确认的报文段关联  </li>
<li>过期间隔：TimeOutInterval  </li>
</ul>
</li>
</ul>
<p>超时：  </p>
<ul>
<li>重传后沿最老的报文段  </li>
<li>重新启动定时器  </li>
</ul>
<p>收到确认：  </p>
<ul>
<li>如果是对尚未确认的报文段确认  <ul>
<li>更新已被确认的报文序号  </li>
<li>如果当前还有违背确认的报文段，重新启动定时器  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/TCPsendersimplecode.png" alt="简化的 TCP 发送方伪码">  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPresend.png" alt="TCP 重传">  </p>
<h4 id="产生-TCP-ACK-的建议"><a href="#产生-TCP-ACK-的建议" class="headerlink" title="产生 TCP ACK 的建议"></a>产生 TCP ACK 的建议</h4><p><img src="/2022/04/19/computernetworknotes3/TCPACKsuggestion.png"></p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><ul>
<li>超时周期往往太长：在重传丢失报文段之前的延时太长  </li>
<li>通过重复的 ACK 来检测报文段丢失  <ul>
<li>发送方通常连续发送大量报文段  </li>
<li>如果报文段丢失，通常会引起多个重复的 ACK  </li>
</ul>
</li>
<li>如果发送方收到统一数据的 3 个冗余 ACK，重传最小序号的段  <ul>
<li><strong>快速重传</strong>：在定时器过时之前重发报文段  </li>
<li>它假设跟在呗确认的数据后面的数据丢失了  <ul>
<li>第一个 ACK 是正常的  </li>
<li>收到第二个该段的 ACK，表示接收方到收到一个该段后的乱序段  </li>
<li>收到第 3、4 个该段的 ACK，表示接收方收到该段之后的 2 个、3 个乱序段，可能性非常大段丢失了  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>缓冲区 TCP 往里面写，app 从当中读取  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPstreamcontrol.png" alt="接收方协议栈">  </p>
<p><strong>流量控制</strong>：接收方控制发送方，不让发送方发送太多、太快以至于让接收方的缓冲区溢出  </p>
<p>接收方在其向发送方的 TCP 段头部的 rwnd 字段 “通告” 其空闲 brffer 大小  </p>
<ul>
<li>RcvBuffer 大小通过 socket 选项设置 (典型默认大小为 4096 字节)  </li>
<li>很多操作系统自动调整 RcvBuffer  </li>
</ul>
<p>发送方限制未确认 (in-flight) 字节的个数 ≤ 接收方发送过来的 rwnd 值<br>保证接收方不会被淹没  </p>
<p><img src="/2022/04/19/computernetworknotes3/rcvbuffer.png" alt="接收方 buffer 大小">  </p>
<p><img src="/2022/04/19/computernetworknotes3/rcvwindow.png" alt="接收方 Recieve Window">  </p>
<h3 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h3><p>在正式交换数据之前，发送方和接收方握手建立通信关系：  </p>
<ul>
<li>同意建立连接 (每一方抖直到对方愿意建立连接)  </li>
<li>同意连接参数  </li>
</ul>
<h4 id="同意建立连接"><a href="#同意建立连接" class="headerlink" title="同意建立连接"></a>同意建立连接</h4><p>Q：在网格中，2 次握手建立连接总是可行吗？  </p>
<ul>
<li>变化的延迟 (连接请求的段没有丢，但可能超时)  </li>
<li>由于丢失造成的重传 (eg. req_conn(x))  </li>
<li>报文乱序  </li>
<li>互相看不到对方  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/hellofailure.png" alt="2 次握手失败场景">  </p>
<p>解决方案：变化的初始序号 + 双方确认对方的序号 (3 次握手)</p>
<p><img src="/2022/04/19/computernetworknotes3/3hello.png" alt="TCP 3 次握手">  </p>
<p><img src="/2022/04/19/computernetworknotes3/3hello2.png" alt="TCP 3 次握手">  </p>
<p><img src="/2022/04/19/computernetworknotes3/3helloFSM.png" alt="TCP 3 次握手">  </p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>客户端、服务器分别关闭自己这一侧的连接  </p>
<ul>
<li>发送 FIN bit = 1 的 TCP 段  </li>
</ul>
<p>一旦接收到 FIN，用 ACK 回应  </p>
<ul>
<li>接到 FIN 段，ACK 可以和它自己发出的 FIN 段一起发送</li>
</ul>
<p>可以处理同时的 FIN 交换  </p>
<br>

<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="拥塞"><a href="#拥塞" class="headerlink" title="拥塞"></a>拥塞</h3><p>非正式的定义：太多数据需要网络传输，超过了网络的处理能力<br>与流量控制不同<br>拥塞的表现：  </p>
<ul>
<li>分组丢失 (路由器缓冲区溢出)  </li>
<li>分组经历比较长的延迟 (在路由器的队列中排队)  </li>
</ul>
<h4 id="拥塞的原因-代价：场景-1"><a href="#拥塞的原因-代价：场景-1" class="headerlink" title="拥塞的原因/代价：场景 1"></a>拥塞的原因/代价：场景 1</h4><p><img src="/2022/04/19/computernetworknotes3/jam1.png">  </p>
<h4 id="拥塞的原因-代价：场景-2"><a href="#拥塞的原因-代价：场景-2" class="headerlink" title="拥塞的原因/代价：场景 2"></a>拥塞的原因/代价：场景 2</h4><p><img src="/2022/04/19/computernetworknotes3/jam2.png">  </p>
<p>现实情况：重复  </p>
<ul>
<li>分组可能丢失，由于缓冲器满而被丢弃  </li>
<li>发送端最终超时，发送第二个拷贝，两个分组都被传到  </li>
</ul>
<p>拥塞代价：  </p>
<ul>
<li>为了达到一个有效输出，网络需要做更多的工作 (重传)  </li>
<li>没有必要的重传，链路中包括了多个分组的拷贝：是那些没有丢失，经历的时间比较长 (拥塞状态) 但超时的分组；降低了的 “goodput”  </li>
</ul>
<h4 id="拥塞的原因-代价：场景-3"><a href="#拥塞的原因-代价：场景-3" class="headerlink" title="拥塞的原因/代价：场景 3"></a>拥塞的原因/代价：场景 3</h4><p><img src="/2022/04/19/computernetworknotes3/jam3.png">  </p>
<p>拥塞代价：当分组丢失时，任何 “关于这个分组的上游传输能力” 都被浪费  </p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><h4 id="网络辅助的拥塞控制"><a href="#网络辅助的拥塞控制" class="headerlink" title="网络辅助的拥塞控制"></a>网络辅助的拥塞控制</h4><p>路由器提供给端系统以反馈信息  </p>
<ul>
<li>单个 bit 置位，显示有拥塞 (SNA，DECbit，TCP/IP ECN，ATM)  </li>
<li>显式提供发送端可以采用的速率  </li>
</ul>
<h4 id="端到端拥塞控制"><a href="#端到端拥塞控制" class="headerlink" title="端到端拥塞控制"></a>端到端拥塞控制</h4><p>没有来自网络的显示反馈<br>端系统根据延迟和丢失事件推断是否有拥塞<br>TCP 采用的方法  </p>
<h4 id="ATM-ABR-拥塞控制"><a href="#ATM-ABR-拥塞控制" class="headerlink" title="ATM ABR 拥塞控制"></a>ATM ABR 拥塞控制</h4><p>ABR：available bit rate  </p>
<ul>
<li>弹性服务  </li>
<li>如果发送端的路径 “轻载”：发送方使用可用带宽  </li>
<li>如果发送方的路径用色了，发送方限制其发送的速度到一个最小保障速率上  </li>
</ul>
<p>RM (资源管理) 信元  </p>
<ul>
<li>有发送端发送，在数据心愿中间隔插入  </li>
<li>RM 信元中的比特被交换机设置 (网络辅助)  <ul>
<li>NI bit：no increase in rate (轻微拥塞)速率不要增加了  </li>
<li>CI bit：congestion indication 拥塞指示  </li>
</ul>
</li>
<li>发送端发送的 RM 信元被接收端返回，接收端不做任何改变  </li>
</ul>
<p>在 RM 信元中的 2 个字节 ER (explicit rate) 字段  </p>
<ul>
<li>拥塞的交换机可能会降低信元中 ER 的值  </li>
<li>发送端发送速度因此是最低的可支持速率  </li>
</ul>
<p>数据信元中的 EFCI bit：备用色的交换机设置为 1  </p>
<ul>
<li>如果在管理信元 RM 前面的数据信元 EFCI 被设置成了 1，接收端在返回的 RM 信元中设置 CI bit  </li>
</ul>
<br>

<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><h4 id="端到端的拥塞控制机制"><a href="#端到端的拥塞控制机制" class="headerlink" title="端到端的拥塞控制机制"></a>端到端的拥塞控制机制</h4><p>路由器不向主机有关拥塞反馈信息  </p>
<ul>
<li>路由器的负担较轻  </li>
<li>符合网络核心简单的 TCP/IP 架构远离  </li>
</ul>
<p>端系统根据自身的到的信息，判断是否发生拥塞，从而采取动作  </p>
<h4 id="拥塞控制的几个问题"><a href="#拥塞控制的几个问题" class="headerlink" title="拥塞控制的几个问题"></a>拥塞控制的几个问题</h4><p>如何检测拥塞  </p>
<ul>
<li>轻微拥塞  </li>
<li>拥塞  </li>
</ul>
<p>控制策略  </p>
<ul>
<li>在拥塞发生时如何动作降低速率：轻微拥塞和拥塞分别如何降低  </li>
<li>在拥塞缓解时如何动作增加速率  </li>
</ul>
<h3 id="拥塞感知"><a href="#拥塞感知" class="headerlink" title="拥塞感知"></a>拥塞感知</h3><h4 id="发送端如何探测到拥塞"><a href="#发送端如何探测到拥塞" class="headerlink" title="发送端如何探测到拥塞"></a>发送端如何探测到拥塞</h4><p>某个段超时 (丢失事件)：拥塞  </p>
<ul>
<li>超时时间到，某个段的确认没有来  </li>
<li>原因 1：网络拥塞 (某个路由器缓冲区没空间了，被丢弃)，概率大  </li>
<li>原因 2：出错被丢弃 (各级错误，没有通过校验，被丢弃)，概率小  </li>
<li>一旦超时，就认为拥塞会有一定误判，但总体控制方向是对的  </li>
</ul>
<p>有关某个段的 3 次重复 ACK：轻微拥塞  </p>
<ul>
<li>段的第 1 个 ACK，正常，确认绿段，期待红段  </li>
<li>段的第 2 个重复 ACK，意味着红段的后一段收到了，蓝段乱序到达  </li>
<li>段的第 2、3、4 个 ACK 重复，意味着红段的后第 2、3、4 个段收到了，橙段乱序到达，同时红段丢失的可能性很大 (后面 3 个段都到了，红段还没到)  </li>
<li>网络这时还能够进行一定程度的传输，拥塞但情况比第一种好  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/yongseganzhi.png">  </p>
<h3 id="速率控制方法"><a href="#速率控制方法" class="headerlink" title="速率控制方法"></a>速率控制方法</h3><h4 id="如何控制发送端发送的速率"><a href="#如何控制发送端发送的速率" class="headerlink" title="如何控制发送端发送的速率"></a>如何控制发送端发送的速率</h4><p>维持一个拥塞窗口的值：CongWin<br>发送端限制已发送但是未确认的数据量 (的上限)  </p>
<ul>
<li>LastByteSent-LastByteAcked ≤ CongWin  </li>
</ul>
<p>从而粗略地控制发送方往网络中注入的速率  </p>
<p><img src="/2022/04/19/computernetworknotes3/sulvkongzhi.png"></p>
<p>CongWin 是动态的，是感知到的网络拥塞程度的函数  </p>
<ul>
<li>超时或者 3 个重复 ACK，CongWin：<ul>
<li>超时时：CongWin 降为 1 MSS，进入 SS 阶段然后再倍增到 CongWin / 2 (每个 RTT)，从而进入 CA 阶段  </li>
<li>3 个重复 ACK：CongWin 降为 CongWin / 2，CA 阶段  </li>
</ul>
</li>
<li>否则 (正常收到 ACK，没有发送以上情况)：CongWin 跃跃欲试  <ul>
<li>SS 阶段：加倍增加 (每个 RTT)  </li>
<li>CA 阶段：线性增加 (每个 RTT)</li>
</ul>
</li>
</ul>
<h4 id="TCP-拥塞控制和流量控制的联合动作"><a href="#TCP-拥塞控制和流量控制的联合动作" class="headerlink" title="TCP 拥塞控制和流量控制的联合动作"></a>TCP 拥塞控制和流量控制的联合动作</h4><p>联合控制方法：  </p>
<ul>
<li>发送段控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求  <ul>
<li>SendWin = min{CongWin, RecvWin}  </li>
<li>同时满足拥塞控制和流量控制要求  </li>
</ul>
</li>
</ul>
<h3 id="TCP-拥塞控制：策略概述"><a href="#TCP-拥塞控制：策略概述" class="headerlink" title="TCP 拥塞控制：策略概述"></a>TCP 拥塞控制：策略概述</h3><p>拥塞控制策略：  </p>
<ul>
<li>慢启动  </li>
<li>AIMD：线性增、乘性减少  </li>
<li>超时时间后的保守策略  </li>
</ul>
<h3 id="TCP-慢启动"><a href="#TCP-慢启动" class="headerlink" title="TCP 慢启动"></a>TCP 慢启动</h3><p>当连接开始时，指数性增加 (每个 RTT) 发送速率直到发生丢失事件  </p>
<ul>
<li>每一个 RTT，CongWin 加倍  </li>
<li>每收到一个 ACK 时，CongWin 加 1  </li>
<li>慢启动阶段：只要不超时或 3 个重复 ACK，一个 RTT，CongWin 加倍  </li>
</ul>
<p>总结：初始速率很慢，但加速确是指数性的  </p>
<ul>
<li>指数增加，SS 时间很短，长期来看可以忽略  </li>
</ul>
<h4 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h4><p>乘性减：丢失事件后将 CongWin 降为 1，将 CongWin / 2 作为阈值，进入到慢启动阶段 (倍增直到 CongWin / 2)<br>加性增：当 CongWin &gt; 阈值时，一个 RTT 如没有发生丢失事件，将 CongWin 加 1 MSS (探测)</p>
<p>当收到 3 个重复的 ACKs  </p>
<ul>
<li>CongWin 减半  </li>
<li>窗口 (缓冲区大小) 之后线性增长  </li>
</ul>
<p>当超时事件发生时  </p>
<ul>
<li>CongWin 被设置成 1 MSS，进入 SS 阶段  </li>
<li>之后窗口指数增长  </li>
<li>增长到一个阈值 (上次发生拥塞的窗口的一半) 时，再线性增加  </li>
</ul>
<p>思路：  </p>
<ul>
<li>3 个重复的 ACK 表示网络还有一定的段传输能力  </li>
<li>超时之前的 3 个重复的 ACK 表示 “警报”  </li>
</ul>
<p>改进  </p>
<ul>
<li>什么时候应该将指数性增长变成线性  </li>
<li>在超时之前，当 CongWin 变成上次超时时的窗口的一半  </li>
</ul>
<p>实现  </p>
<ul>
<li>变量：Threshold  </li>
<li>出现丢失，Threshold 设置成 CongWin 的 1/2  </li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当 CongWin &lt; Threshold，发送端处于慢启动阶段 (slow-start)，窗口指数型增长<br>当 CongWin &gt; Threshold，发送端处于拥塞避免阶段 (congestion-avoidance)，窗口线性增长<br>当收到三个重复的 ACKs (triple duplicate ACK)，Threshold 设置成 CongWin / 2，CongWin = Threshold + 3<br>当超时事件发生时 (timeout)，Threshold = CongWin / 2，CongWin = 1 MSS，进入 SS 阶段</p>
<p><img src="/2022/04/19/computernetworknotes3/TCPsendercongcon.png" alt="TCP 发送端拥塞控制"></p>
<h3 id="TCP-吞吐量"><a href="#TCP-吞吐量" class="headerlink" title="TCP 吞吐量"></a>TCP 吞吐量</h3><p>W：发生丢失事件时的窗口尺寸 (单位：字节)  </p>
<ul>
<li>平均窗口尺寸 (#in-filght 字节)：3/4 W  </li>
<li>平均吞吐量：RTT 事件吞吐 3/4 W  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/inout.png" alt="TCP 吞吐量"></p>
<h3 id="TCP-公平性"><a href="#TCP-公平性" class="headerlink" title="TCP 公平性"></a>TCP 公平性</h3><p>公平性目标：如果 K 个 TCP 会话分享一个链路带宽为 R 的瓶颈，每一个绘画的有效带宽为 R/K  </p>
<h4 id="为什么-TCP-是公平的"><a href="#为什么-TCP-是公平的" class="headerlink" title="为什么 TCP 是公平的"></a>为什么 TCP 是公平的</h4><p>2 个竞争的 TCP 会话：  </p>
<ul>
<li>加性增加，斜率为 1，吞吐量增加  </li>
<li>乘性减，吞吐量比例减少  </li>
</ul>
<h4 id="公平性和-UDP"><a href="#公平性和-UDP" class="headerlink" title="公平性和 UDP"></a>公平性和 UDP</h4><p>多媒体应用通常不是 TCP  </p>
<ul>
<li>应用发送的数据速率希望不受拥塞控制的节制  </li>
</ul>
<p>使用 UDP：  </p>
<ul>
<li>音视频应用泵出数据的速率是恒定的，忽略数据的丢失  </li>
</ul>
<p>研究领域：TCP 友好性  </p>
<h4 id="公平性和并行-TCP-连接"><a href="#公平性和并行-TCP-连接" class="headerlink" title="公平性和并行 TCP 连接"></a>公平性和并行 TCP 连接</h4><p>2 个主机间可以打开多个并行的 TCP 连接<br>Web 浏览器  </p>
<p>例如：带宽为 R 的链路支持了 9 个连接  </p>
<ul>
<li>如果新的应用要求建 1 个 TCP 连接，获得带宽 R/10  </li>
<li>如果新的应用要求建 11 个 TCP 连接，获得带宽 R/2  </li>
</ul>
<h3 id="Explicit-Congestion-Notification-ECN"><a href="#Explicit-Congestion-Notification-ECN" class="headerlink" title="Explicit Congestion Notification (ECN)"></a>Explicit Congestion Notification (ECN)</h3><p>网络辅助拥塞控制：  </p>
<ul>
<li>TOS 字段中 2 个 bit 被网络路由器标记，用于只是是否发生拥塞  </li>
<li>拥塞指示被传送到接收主机  </li>
<li>在接受方到发送方的 ACK 中，接收方 (在 IP 数据报中看到了拥塞指示)设置 ECE bit，指示发送方发生了拥塞</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 1：the basic</title>
    <url>/2022/03/14/computernetworknotes1/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络第一章计算机网络概述自学笔记 </center>
<span id="more"></span>

<h2 id="课程来源"><a href="#课程来源" class="headerlink" title="课程来源"></a>课程来源</h2><p>bilibili 网课：<a href="https://www.bilibili.com/video/BV1JV411t7">中科大郑烇、杨坚全套《计算机网络》</a>  </p>
<br>  

<h2 id="什么是-Internet"><a href="#什么是-Internet" class="headerlink" title="什么是 Internet"></a>什么是 Internet</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>由节点和边构成的拓扑结构  </p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>联网的计算机所构成的系统，包括主机节点 (数据源或数据目标)、数据交换节点 (路由器、中继器、交换机等)、链路  </p>
<ul>
<li>节点  <ul>
<li>主机及其上运行的应用程序  </li>
<li>路由器、交换机等网络交换设备  </li>
</ul>
</li>
<li>边：通信链路  <ul>
<li>接入网链路：主机连接到互联网的链路  </li>
<li>主干链路：路由器间链路  </li>
</ul>
</li>
<li>协议  <ul>
<li>对等层实体在通信过程中，应该遵守的规则的集合，包括语义、语法和时序  </li>
</ul>
</li>
</ul>
<h3 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h3><p>数以亿计的、互联的计算设备  </p>
<ul>
<li>主机 = 端系统：end system / host  </li>
<li>运行网络应用程序</li>
</ul>
<p>通信链路  </p>
<ul>
<li>光纤、同轴电缆、无线电、卫星  </li>
<li>传输速率 = 带宽 (bps)  </li>
</ul>
<p>分组交换设备：转发分组 (packets)  </p>
<ul>
<li>路由器和交换机</li>
</ul>
<h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><p>TCP、IP 协议建立起的一个网络，也是一种计算机网络。  </p>
<ul>
<li>协议控制发送、接收消息：TCP、IP、HTTP、FTP、PPP 等  </li>
<li>网络的网络：松散的层次结构，互连的 ISP；公共 Internet vs 专用 intranet  </li>
<li>标准：RFC (Request For Comments)；IETF(Internet Engineering Task Force)  </li>
</ul>
<p><strong>协议</strong>定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和/或接收或其他事件方面所采取的动作。  </p>
<p>从服务角度理解 Internet</p>
<ul>
<li>使用通信设施进行通信的分布式应用：Web、VoIP、email、分布式游戏、电子商务、社交网络  </li>
<li>通信基础设施为 apps 提供编程接口 (通信服务)：将发送和接收数据的 apps 与互联网连接起来；为 apps 提供服务选择，类似于邮件服务，包括无连接不可靠服务和面向连接的可靠服务  </li>
</ul>
<br>  

<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>网络边缘 (edge)  </p>
<ul>
<li>主机  </li>
<li>应用程序：客户端和服务器  </li>
</ul>
<p>网络核心 (core)：数据交换  </p>
<ul>
<li>互连着的路由器  </li>
<li>网络的网络  </li>
</ul>
<p>接入网、物理媒体 (access)  </p>
<ul>
<li>有线或无线通信链路  </li>
</ul>
<h3 id="网络边缘-1"><a href="#网络边缘-1" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>端系统 (主机)：运行应用程序，如 Web、Email，在“网络的边缘”  </p>
<p>客户/服务模式  </p>
<ul>
<li>一种主从模式，可扩展性、可靠性有问题  </li>
<li>客户端向服务器请求、接收服务，如 Web 浏览器/服务器，Email 客户端/服务器  </li>
</ul>
<p>对等 (peer - peer) 模式  </p>
<ul>
<li>每个节点既是客户端有时服务器  </li>
<li>分布式的文件系统  </li>
<li>很少 (甚至没有) 专门的服务器，如 Gmutella、KaZaA、Emule、迅雷、电驴  </li>
</ul>
<h4 id="面向连接的通信服务"><a href="#面向连接的通信服务" class="headerlink" title="面向连接的通信服务"></a>面向连接的通信服务</h4><p>采用网络设施的面向连接服务  </p>
<p><strong>目标</strong>：在端系统之间传输数据  </p>
<ul>
<li>“握手”：在数据传输之前做好准备，为通信准备好相应的资源、设置  </li>
<li>两个通信主机之间为连接建立状态，端系统维护连接，只有端系统“知道”连接  </li>
</ul>
<p><strong>TCP (Transmission Control Protocol) 传输控制协议</strong> [RFC 793]  </p>
<ul>
<li>Internet 上面向连接的服务  </li>
<li>使用 TCP 的应用：HTTP (Web)、FTP (文件传输)、Telnet (远程登陆)、SMTP (Email)  </li>
<li><strong>可靠地、按顺序地传送数据</strong>：确认和重传  </li>
<li><strong>流量控制</strong>：平衡发送方和接收方，发送方不会淹没接收方  </li>
<li><strong>拥塞控制</strong>：了解网络路径情况，当网络拥塞时，发送方降低发送速率  </li>
</ul>
<h4 id="采用基础设施的无连接服务"><a href="#采用基础设施的无连接服务" class="headerlink" title="采用基础设施的无连接服务"></a>采用基础设施的无连接服务</h4><p>目标  </p>
<ul>
<li>在端系统之间传输数据  </li>
<li>无连接服务：直接发送，不打招呼  </li>
</ul>
<p><strong>UDP (User Datagram Protocol) 用户数据报协议</strong> [RFC 768]</p>
<ul>
<li>无连接  </li>
<li>不可靠数据传输  </li>
<li>无流量控制  </li>
<li>无拥塞控制  </li>
<li>使用 UDP 的应用：流媒体、远程会议、DNS、Internet 电话  </li>
</ul>
<br>  

<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>路由器的网状网络  </p>
<h3 id="通过网络传输数据的方式"><a href="#通过网络传输数据的方式" class="headerlink" title="通过网络传输数据的方式"></a>通过网络传输数据的方式</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>为每个预叫预留一条专有电路，如电话网  </p>
<p><img src="/2022/03/14/computernetworknotes1/dianlujiaohuan.png" alt="电路交换">  </p>
<p>为呼叫预留端-端资源  </p>
<ul>
<li>链路带宽，交换能力  </li>
<li>专用资源：不共享  </li>
<li>保证性能  </li>
<li>要求建立呼叫链接  </li>
</ul>
<p>网络资源 (如带宽) 被分成片  </p>
<ul>
<li>可频分 (Frequency-division multiplexing, FDM)，称频段；可时分 (Time-division multiplexing, TDM)，称时间周期片；可波分 (Wave-division multiplexing, WDM)，称波段  </li>
<li>为呼叫分配片  </li>
<li>如果某个呼叫没有数据，则其资源片处于空闲状态 (不共享)  </li>
</ul>
<p>特点  </p>
<ul>
<li>连接建立时间长  </li>
<li>计算机之间的通信具有突发性，若使用电路交换则浪费片较多  </li>
<li>可靠性不高 (维护 piece 间的 mapping 关系，若核心节点损毁则会造成大面积瘫痪)  </li>
</ul>
<h4 id="分组交换-packet-switch"><a href="#分组交换-packet-switch" class="headerlink" title="分组交换 (packet switch)"></a>分组交换 (packet switch)</h4><p>简介  </p>
<ul>
<li>将要传输的数据分成一个个单位：分组  </li>
<li>将分组从一个路由器传到一个相邻的路由器 (hop)，一段段最终从源端到目标端  </li>
<li>每段：采用链路的最大传输能力 (带宽)  </li>
</ul>
<p>以分组为单位存储 - 转发方式  </p>
<ul>
<li>网络带宽资源不再分为一个个片，传输时使用全部带宽  </li>
<li>主机之间传输的数据被分为一个个分组  </li>
</ul>
<p>资源共享，按需使用  </p>
<ul>
<li>存储 - 转发：分组每次移动一跳 (hop)  </li>
<li>在转发之前，节点必须收到整个分组  </li>
<li>延迟比线路交换大有排队时间<br><em>如果到达速率 &gt; 链路的输出速率，分组将会排队，等待传输；如果路由器缓存使用完，分组将被会抛弃。</em>  </li>
</ul>
<p>网络核心的关键功能  </p>
<ul>
<li><strong>路由</strong>：决定分组采用的源到目标的路径 (路由算法)  </li>
<li><strong>转发</strong>：将分组从路由器的输入链路转移到输出链路  </li>
</ul>
<p>分组交换的分组没有固定模式，即统计多路复用。  </p>
<h4 id="分组交换-vs-电路交换"><a href="#分组交换-vs-电路交换" class="headerlink" title="分组交换 vs 电路交换"></a>分组交换 vs 电路交换</h4><ul>
<li>分组交换允许更多用户使用网络<br><img src="/2022/03/14/computernetworknotes1/switchcompare.png" alt="分组交换与电路交换对比">  </li>
</ul>
<center> *网络强度为 1 时，网络会挂，所以分组交换时用户数不能为 10* </center>  

<ul>
<li>分组交换更适合于突发式数据传输：资源共享；简单，不必建立呼叫  </li>
<li>过度使用会造成网络拥堵：分组延时和丢失；对可靠的数据传输需要协议来约束 (拥塞控制)  </li>
</ul>
<h3 id="分组交换网络"><a href="#分组交换网络" class="headerlink" title="分组交换网络"></a>分组交换网络</h3><p>分组的存储 - 转发一段一段从源端传到目标端，按照有无网络层的连接分成：<br>(1) 数据报 (datagram) 网络  </p>
<ul>
<li>分组的目标地址决定下一跳  </li>
<li>在不同的阶段，路由可以改变  </li>
<li>即无连接，每一份都独立传送<ul>
<li>通信之前无需建立连接，有数据就传输</li>
<li>每一个分组都独立路由 (路径不一样，可能会失序)  </li>
<li>路由器根据分组的目标地址进行路由</li>
</ul>
</li>
<li>类似：问路  </li>
<li>eg. Internet  </li>
</ul>
<p>(2) 虚电路 (virtual circuit) 网络  </p>
<ul>
<li>每个分组都带标签，虚电路标识 VC ID，标签决定下一跳  </li>
<li>在呼叫建立时决定路径，在整个呼叫中路径保持不变  </li>
<li>路由器维护每个呼叫的状态信息  </li>
<li>即建立网络层的连接，每个交换节点中有相应标识  </li>
<li>eg. X.25 和 ATM  </li>
</ul>
<br>  

<h2 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a>接入网和物理媒体</h2><h3 id="接入网：怎样将端系统和边缘路由端链接"><a href="#接入网：怎样将端系统和边缘路由端链接" class="headerlink" title="接入网：怎样将端系统和边缘路由端链接"></a>接入网：怎样将端系统和边缘路由端链接</h3><ul>
<li>住宅接入网络  </li>
<li>单位接入网络：学校、公司  </li>
<li>无线接入网络  </li>
</ul>
<p><strong>重要指标</strong>：带宽、共享/专用</p>
<h4 id="住宅接入-modem"><a href="#住宅接入-modem" class="headerlink" title="住宅接入 (modem)"></a>住宅接入 (modem)</h4><p>将上网数据<strong>调制</strong>加载在音频信号上 (能保证的带宽只有 4 kHz)，在电话线上传输，在局端将其中的数据<strong>解调</strong>出来；反之亦然。  </p>
<ul>
<li>调频  </li>
<li>调幅  </li>
<li>调相位  </li>
<li>综合调制  </li>
</ul>
<p><strong>拨号调制解调器</strong>  </p>
<ul>
<li>56 Kbps 的速率直接接入路由器 (通常更低)  </li>
<li>不能同时上网和打电话，且不能总是在线  </li>
<li>利用已有的线路</li>
</ul>
<p><strong>Digital Subscribe Line (DSL)：</strong>采用现存的到交换局 DLSAM 的电话线  </p>
<ul>
<li>语音、数据在专享线路的不同波段传播</li>
<li>DSL 线路上的数据波传到互联网 (&gt; 4 kHz，上下传输带宽分布不均时称为 ADSL)  </li>
<li>DSL 线路上的数据波传到电话网 (&lt; 4 kHz)  </li>
<li>传输速率<ul>
<li>&lt; 2.5 Mbps 上行传输速率 (typically &lt; 1 Mbps)  </li>
<li>&lt; 24 Mbps 下行传输速率 (typically &lt; 10 Mbps)  </li>
</ul>
</li>
</ul>
<p><strong>线缆网络</strong>  </p>
<ul>
<li>有线电视信号线缆双向改造  </li>
<li><strong>FDM</strong>：在不同频段传输不同信道的数据，包括数字电视和上网数据 (上下行)  </li>
<li>类似的也可以使用电网  </li>
<li>HFC (Hybrid Fiber Coax)：非对称，最高 30 Mbps 的下行传输速率，2 Mbps 上行传输速率  </li>
<li>线缆和光纤网络将各个家庭用户接入到 ISP 路由器</li>
<li>个用户<strong>共享</strong>到线缆头端的接入网络 (与 DSL 不同，DSL 每个用户一个专用线路到 CO (Central Office))  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/modem.png" alt="住宅接入：电缆模式">  </p>
<br>  

<p><img src="/2022/03/14/computernetworknotes1/housenetwork.png" alt="接入网：家庭网络">  </p>
<h4 id="企业接入网络-Ethernet"><a href="#企业接入网络-Ethernet" class="headerlink" title="企业接入网络 (Ethernet)"></a>企业接入网络 (Ethernet)</h4><p>经常被弃业或大学等机构采用</p>
<ul>
<li>10 Mbps，100 Mbps，1 Gbps，10 Gbps 传输率  </li>
<li>现在端系统经常直接接到以太网络交换机上  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/Ethernet.png" alt="企业接入网络">  </p>
<h4 id="无线接入网络"><a href="#无线接入网络" class="headerlink" title="无线接入网络"></a>无线接入网络</h4><p>各无线端系统共享无线接入网络 (端系统到无线路由器)  </p>
<ul>
<li>通过基站或接入点  </li>
</ul>
<p>无线 LANs  </p>
<ul>
<li>建筑物内部 (100 ft)  </li>
<li>802.11 b/g (WiFi)：11，54 Mbps 传输速率  </li>
</ul>
<p>广域无线接入  </p>
<ul>
<li>由电信运营商提供 (Cellular)：10’s km  </li>
<li>1 到 10 Mbps  </li>
<li>3 G，4 G：LTE</li>
</ul>
<h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><ul>
<li>Bit：在传输-接收对间传播  </li>
<li>物理链路：在每个传输-接收对间跨越的一种物理媒体  </li>
<li>导引型媒体：信号沿着固体媒介被导引，如同轴电缆、光纤、双绞线  </li>
<li>非导引型媒体：信号自由传播，如无线电  </li>
</ul>
<h4 id="双绞线-TP"><a href="#双绞线-TP" class="headerlink" title="双绞线 (TP)"></a>双绞线 (TP)</h4><ul>
<li>两根绝缘铜线  </li>
<li>5 类：100 Mbps Ethernet、Gbps 以太网  </li>
<li>6 类：10 Gbps </li>
</ul>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><ul>
<li>两根同心的铜导线  </li>
<li>双向  </li>
<li>基带电缆<ul>
<li>电缆上一个单个信道</li>
<li>Ethernet</li>
</ul>
</li>
<li>宽带电缆<ul>
<li>电缆上有多个信道</li>
<li>HFC</li>
</ul>
</li>
</ul>
<h4 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h4><ul>
<li>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输  </li>
<li>高速：点到点的告诉传输，如 10 Gbps ~ 100 Gbps 传输速率  </li>
<li>低误码率：在两个中继器之间可以有很长的距离，不受电磁噪声的干扰  </li>
<li>安全：全反射或垂直 (射入角度为零)；单模光纤或多模光纤  </li>
</ul>
<h4 id="无线链路"><a href="#无线链路" class="headerlink" title="无线链路"></a>无线链路</h4><ul>
<li>开放空间传输电磁波，携带要传输的数据  </li>
<li>无需物理“线缆”  </li>
<li>双向  </li>
<li>传播环境效应：反射、吸收、干扰  </li>
<li>类型  <ul>
<li>地面微波：up to 45 Mbps channels  </li>
<li>LAN：WiFi；11 Mbps，54 Mbps，540 Mbps 等  </li>
<li>wide area：蜂窝；3 G cellular (~ few Mbps)；4 G 10 Mbps；5 G 数 Gbps  </li>
<li>卫星：每个信道 Kbps 到 45 Mbps，或者多个聚集信道；270 msec 端到端延迟 (延迟大)；同步静止卫星和低轨卫星  </li>
</ul>
</li>
</ul>
<br>  

<h2 id="Internet-结构和-ISP"><a href="#Internet-结构和-ISP" class="headerlink" title="Internet 结构和 ISP"></a>Internet 结构和 ISP</h2><h3 id="互联网络结构：网络的网络"><a href="#互联网络结构：网络的网络" class="headerlink" title="互联网络结构：网络的网络"></a>互联网络结构：网络的网络</h3><p>端系统通过接入 ISPs (Internet Service Providers) 连接到互联网  </p>
<ul>
<li>住宅、公司和大学的 ISPs  </li>
</ul>
<p>接入 ISPs 相应的必须是互联的，因此任何两个端系统可相互发送分组到对方。<br>导致“网络的网络”非常复杂，发展和演化通过经济和国家政策来驱动。  </p>
<h3 id="接入-ISPs-的连接方式"><a href="#接入-ISPs-的连接方式" class="headerlink" title="接入 ISPs 的连接方式"></a>接入 ISPs 的连接方式</h3><p>接入 ISPs 之间全连接：即将每两个 ISPs 直接相连，不可扩展，需要 O(n<sup>2</sup>) 连接  </p>
<p>将每个接入 ISP 都连接到<strong>全局 ISP</strong> (全局范围内覆盖)：客户 ISPs 和提供者 ISPs 有经济合约  </p>
<p><img src="/2022/03/14/computernetworknotes1/globalISP.png" alt="将每个接入 ISP 都连接到全局 ISP">  </p>
<p>如果全局 ISP 事可行的业务，则一定会有不同公司<strong>竞争</strong>；通过 ISP 之间的<strong>合作</strong>可以完成业务的扩展，肯定会有互联，对等互联的结算关系  </p>
<p><img src="/2022/03/14/computernetworknotes1/ISPpeerlink.png" alt="ISP 竞争与合作"></p>
<p>业务细分 (全球接入和区域接入)，<strong>区域网络</strong>将出现，用于将接入 ISPs 连接到全局 ISPs  </p>
<p><img src="/2022/03/14/computernetworknotes1/regionalnet.png" alt="局域网络">  </p>
<p><strong>内容提供商网络</strong> (Internet Content Provider, eg. Google, Microsoft, Akamai) 可能会构建它们自己的网络，将它们的服务、内容更加靠近端用户，向用户提供更好的服务，减少自己的运营支出</p>
<ul>
<li>在全球各地部署自己的网络 (或靠近核心 ISP)，连接自己的数据中心机房 (Data Center)，走自己的数据  </li>
<li>连接若干 local ISP 和各级 (包括一层) ISP，更加靠近用户  </li>
<li>少付费，且用户访问更快</li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/CPN.png" alt="内容提供商网络">  </p>
<p>在网络的最中心，有一些为数不多的充分连接大范围网络 (分布广、节点有限，但之间有多重连接)  </p>
<ul>
<li>“tier-1” commercial ISPs (eg. Level 3, Sprint, AT &amp; T, NTT)，国家或者国际的覆盖范围  </li>
<li>content provider network (eg. Google)：将数据中心接入 ISP，方便周边用户的访问；通常私有网络之间用专网绕过第一层 ISP 和区域 ISPs  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/Internetstructure.png" alt="互联网络结构：网络的网络">  </p>
<h3 id="Internet-的结构：松散的层次结构"><a href="#Internet-的结构：松散的层次结构" class="headerlink" title="Internet 的结构：松散的层次结构"></a>Internet 的结构：松散的层次结构</h3><p><strong>中心：第一层 ISP</strong> (如 UUNet，BBN/Genuity，Sprint，AT &amp; T) 国家/国际覆盖，速率极高  </p>
<ul>
<li>直接于其它第一层 ISP 相连  </li>
<li>与大量的第二层 ISP 和其它客户网络相连  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/POP.png" alt="Sprint: point-of-presence">  </p>
<p>second.png：更小些的 (通常是局域性的) ISP  </p>
<ul>
<li>与一个或多个第一层 ISPs 相连，也可能于其它第二层 ISP  </li>
<li>通过合作拓展网络  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/second.png" alt="第二层 ISP">  </p>
<p>第三层 ISP 与其它本地 ISP  </p>
<ul>
<li>接入网 (与端系统最近)  </li>
<li>一个分组要经过许多网络  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/third.png" alt="第三层 ISP">  </p>
<h3 id="ISP-之间的连接"><a href="#ISP-之间的连接" class="headerlink" title="ISP 之间的连接"></a>ISP 之间的连接</h3><p><strong>POP</strong>  </p>
<ul>
<li>高层 ISP 面向客户网络的接入点，涉及费用结算  </li>
<li>多宿 (multi home)：一个低层 ISP 接入多个高层 ISP  </li>
</ul>
<p><strong>对等接入</strong>  </p>
<ul>
<li>2 个 ISP 对等互接，不涉及费用结算  </li>
</ul>
<p><strong>IXP</strong>  </p>
<ul>
<li>多个对等 ISP 互联互通之外，通常不涉及费用结算  </li>
<li>对等接入  </li>
</ul>
<p><strong>ICP</strong>  </p>
<ul>
<li>自己部署的专用网络</li>
<li>同时和各级 ISP 连接  </li>
</ul>
<br>  

<h2 id="分组延时、丢失和吞吐量"><a href="#分组延时、丢失和吞吐量" class="headerlink" title="分组延时、丢失和吞吐量"></a>分组延时、丢失和吞吐量</h2><h3 id="分组丢失和延时如何产生"><a href="#分组丢失和延时如何产生" class="headerlink" title="分组丢失和延时如何产生"></a>分组丢失和延时如何产生</h3><p>在路由器缓冲区的分组队列  </p>
<ul>
<li>分组到达链路的速率超过了链路输出的能力  </li>
<li>分组等待排到队头、被传输  </li>
<li>缓冲区满，无法进入路由器  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/queueNdelay.png" alt="分组延时和丢失">  </p>
<h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a>分组延时</h3><p>(1) 节点处理延时</p>
<ul>
<li>检查 bit 级差错  </li>
<li>检查分组首部和决定将分组导向何处  </li>
</ul>
<p>(2) 排队延时</p>
<ul>
<li>在输出链路上等待传输的时间  </li>
<li>依赖于路由器的拥塞控制  </li>
</ul>
<p>(3) 传输延时</p>
<ul>
<li>R = 链路带宽 (bps)  </li>
<li>L = 分组长度 (bits)  </li>
<li>将分组发送到链路上的时间 = L / R  </li>
<li>存储转发延时  </li>
</ul>
<p>(4) 传播延时</p>
<ul>
<li>d = 物理链路的长度</li>
<li>s = 在媒体上的传播速度 (~ 2 x 10<sup>8</sup> m / sec)  </li>
<li>传播延时 = d / s  </li>
</ul>
<p><em>R and s are very differential quantities</em>  </p>
<p><img src="/2022/03/14/computernetworknotes1/delay.png" alt="四种分组延时"></p>
<p><img src="/2022/03/14/computernetworknotes1/carqueue.png" alt="分组延时与车队类比">  </p>
<p><img src="/2022/03/14/computernetworknotes1/carqueue2.png" alt="分组延时与车队类比">   </p>
<p><em>信道容量大，可容纳的分组数量多</em>  </p>
<h3 id="节点延时"><a href="#节点延时" class="headerlink" title="节点延时"></a>节点延时</h3><p><img src="/2022/03/14/computernetworknotes1/delaytime.png">  </p>
<h3 id="排队延时"><a href="#排队延时" class="headerlink" title="排队延时"></a>排队延时</h3><ul>
<li><p>R = 链路带宽 (bps)  </p>
</li>
<li><p>L = 分组长度 (bits)  </p>
</li>
<li><p>a = 分组到达队列的平均速率  </p>
</li>
<li><p>流量强度 I = La / R  </p>
<ul>
<li>La / R ~ 0：平均排队延时很小  </li>
<li>La / R -&gt; 1：延时变得很大  </li>
<li>La / R &gt; 1：比特到达队列的速率超过了从该队列输出的速率，平均排队延时将趋向无穷大  </li>
</ul>
<p><em>设计系统时流量强度不能大于1</em>  </p>
<p><img src="/2022/03/14/computernetworknotes1/queuedelay.png"></p>
</li>
</ul>
<h3 id="Internet-的延时和路由"><a href="#Internet-的延时和路由" class="headerlink" title="Internet 的延时和路由"></a>Internet 的延时和路由</h3><p><strong>Traceroute 诊断程序</strong>：提供从源端，经过路由器，到目的的延时测量  </p>
<ul>
<li>For all <em>i</em>：<ul>
<li>沿着目的的路径，像每个路由器发送 3 个探测分组  </li>
<li>路由器 <em>i</em> 将向发送方返回一个分组  </li>
<li>发送方队发送和回复之间间隔计时  </li>
</ul>
</li>
<li>ICMP 协议  </li>
</ul>
<h3 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h3><p>链路的队列缓冲区容量有限<br>当分组到达一个满的队列时，该分组将会丢失<br>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传  </p>
<p><img src="/2022/03/14/computernetworknotes1/packagelost.png" alt="分组丢失">  </p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>在源端和目标端之间传输的速度 (数据量 / 单位时间)<br>有效的数量，要从源端确实到达目标端<br>源到端的吞吐量取决于路径上的最小吞吐量，即<strong>瓶颈链路</strong>的吞吐量<br>瓶颈链路：端到端路径上，限制端到端吞吐的链路<br><strong>瞬间吞吐量</strong>：在一个时间点的速率<br><strong>平均吞吐量</strong>：在一个长时间内平均值  </p>
<p><img src="/2022/03/14/computernetworknotes1/tuntuliang.png" alt="吞吐量">  </p>
<p><img src="/2022/03/14/computernetworknotes1/tuntuliang2.png" alt="吞吐量：互联网场景">  </p>
<br>

<h2 id="协议层次和服务模型"><a href="#协议层次和服务模型" class="headerlink" title="协议层次和服务模型"></a>协议层次和服务模型</h2><h3 id="网络是一个复杂系统"><a href="#网络是一个复杂系统" class="headerlink" title="网络是一个复杂系统"></a>网络是一个复杂系统</h3><p><strong>网络功能繁杂</strong>：数字信号的物理信号承载、点到点、路由、rdt、进程区分、应用等<br><strong>网络有许多构成元素和设备</strong>：主机、路由器、各种媒体的链路、应用、协议、硬件、软件等<br>如何规划这样一个复杂系统：模块化、<strong>层次化</strong></p>
<h3 id="层次化方式实现复杂网络功能"><a href="#层次化方式实现复杂网络功能" class="headerlink" title="层次化方式实现复杂网络功能"></a>层次化方式实现复杂网络功能</h3><p>将网络复杂的功能分层功能明确的<strong>层次</strong>，每一层实现了其中一个或一组<strong>功能</strong>，功能中有其上层可以使用的功能：<strong>服务</strong><br>本层协议实体相互交互执行本层的<strong>协议动作</strong>，目的是实现本层功能，通过接口为上层提供更好的服务<br>在实现本层协议时，直接<strong>利用下层所提供的服务</strong><br>本层的服务：借助下层服务实现的本层协议实体之间交互带来的 (上层可以利用的) 新功能 + 更下层所提供的服务  </p>
<h3 id="服务和服务访问点"><a href="#服务和服务访问点" class="headerlink" title="服务和服务访问点"></a>服务和服务访问点</h3><p><strong>服务 (Service)：</strong>低层实体向上层实体提供它们之间通信的能力  </p>
<ul>
<li>服务用户 (service user)  </li>
<li>服务提供者 (service provider)  </li>
</ul>
<p><strong>原语 (primitive)：</strong>上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的 —— <strong>提供服务的形式</strong>  </p>
<p><strong>服务访问点 SAP (Services Access Point)：</strong>上层使用下层提供的服务通过层间的接口 —— <strong>提供服务的地点</strong>  </p>
<ul>
<li>eg. 邮箱  </li>
<li>地址 (address)：下层的一个实体支撑着上层的多个实体，SAP 有标志不同上层实体的作用  </li>
<li>可以有不同的实现，队列  </li>
<li>eg. 传输层的 SAP：端口 (port)<br><em>区分数据要从哪里传到哪里，服务提供者区分不同的服务用户，层间接口</em></li>
</ul>
<h3 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h3><p><strong>面向连接的服务 (Connection-oriented Service)</strong>  </p>
<ul>
<li>连接 (Connection)：两个通信实体为进行通信而建立的一种结合  </li>
<li>面向连接的服务通信过程：建立连接 (通信之前先“握手”，为通信分配资源，做好准备) -&gt; 通信 -&gt; 拆除连接  </li>
<li>例子：网络层的连接被称为虚电路  </li>
<li>适用范围：更适合传输大的数据块，不适合效地零星报文  </li>
<li>特点：保序  </li>
<li>服务类型<ul>
<li>可靠的信息流 传送页面 (可靠的获得，通过接收方的确认：先“握手”)  </li>
<li>可靠的字节流 远程登陆  </li>
<li>不可靠的连接 数字化声音  </li>
</ul>
</li>
</ul>
<p><strong>无连接的服务 (Connectionless Service)</strong>  </p>
<ul>
<li>两个对等层实体在通信钱不需要建立一个连接，不预留资源，不需要通信双方都活跃 (例：寄信；通信之前不“握手”)  </li>
<li>特点：不可靠、可能重复、可能失序  </li>
<li>IP分组，数据包  </li>
<li>适用范围：传送零星数据  </li>
<li>服务类型<ul>
<li>不可靠的数据报 电子方式的函件  </li>
<li>有确认的数据包 挂号信  </li>
<li>请求回答 信息查询  </li>
</ul>
</li>
</ul>
<h3 id="服务和协议"><a href="#服务和协议" class="headerlink" title="服务和协议"></a>服务和协议</h3><p><strong>区别</strong>  </p>
<ul>
<li>服务 (Service)：低层实体向上层实体提供它们之间的通信能力；通过原语 (primitive) 操作；垂直  </li>
<li>协议 (protocol)：对等层实体 (peer entity) 之间在相互通信的过程中；需要遵循的规则的集合；水平  </li>
</ul>
<p><strong>联系</strong>  </p>
<ul>
<li>本层协议的实现要靠下层提供的服务来实现  </li>
<li>本层实体通过协议为上层提供更高级的服务  </li>
</ul>
<h3 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h3><p><img src="/2022/03/14/computernetworknotes1/DU.png" alt="Data Unit">  </p>
<p>SDU：上层要求传输的数据<br>ICI：接口控制信息，为更加顺利地传过层间接口<br>IDU = SDU + ICI<br>PDU：最常见的数据单元；在不同层有不同的名称，如应用报文、分组、数据报、位、帧等  </p>
<p><strong>n-PDU的构成形式</strong><br><em>n-header：与本层交换数据所需的一些控制信息；其中，n 为层数，第 n 层</em>  </p>
<ul>
<li>一对一：SDU + n-header  </li>
<li>一对多：SDU 的一部分 + n-header (PDU 大小有限，需要将 SDU 分为几个部分)  </li>
<li>多对一：若干 SDU + n-header  </li>
</ul>
<h3 id="分层处理队实现复杂系统的好处"><a href="#分层处理队实现复杂系统的好处" class="headerlink" title="分层处理队实现复杂系统的好处"></a>分层处理队实现复杂系统的好处</h3><p>对复杂的系统<br><strong>概念化</strong>：结构清晰，便于标示网络组件，以及描述其相互关系</p>
<ul>
<li>分层参考模型  </li>
</ul>
<p><strong>结构化</strong>：模块化更易于维护和系统升级  </p>
<ul>
<li>改变某一层服务的实现不影响系统中的其它层次，对其它层次而言是透明的  </li>
<li>eg. 如果改变登记程序并不影响系统的其他部分  </li>
</ul>
<p>分层的问题：效率相对较低  </p>
<h3 id="Internet-协议栈"><a href="#Internet-协议栈" class="headerlink" title="Internet 协议栈"></a>Internet 协议栈</h3><p><strong>应用层</strong>：网络应用  </p>
<ul>
<li>为人类用户或其它应用进程提供网络应用服务  </li>
<li>完成应用报文之间的交互  </li>
<li>FTP, SMTP, HTTP, DNS  </li>
<li>协议数据单元：报文 (message)  </li>
</ul>
<p><strong>传输层</strong>：主机之间的数据传输  </p>
<ul>
<li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠的通信  </li>
<li>完成进程到进程的区分  </li>
<li>TCP, UDP  </li>
<li>协议数据单元：报文段 (segment)；eg. TCP 段，UDP 数据报  </li>
</ul>
<p><strong>网络层</strong>：为数据包从源到目的选择路由  </p>
<ul>
<li>主机主机之间的通信，端到端通信，不可靠  </li>
<li>传输以分组为单位的端到端的数据  </li>
<li>IP，路由协议  </li>
<li>协议数据单元：分组 (packet)；如果无连接方式：数据报 (datagram)  </li>
</ul>
<p><strong>链路层</strong>：相邻网络节点间的数据传输  </p>
<ul>
<li>2 个相邻 2 点的通信，点到点通信，可靠或不可靠</li>
<li>在相邻两点之间，传输以帧为单位的数据 (Point to Point, P2P)  </li>
<li>点对点协议 PPP，802.11 (WiFi)，Ethernet  </li>
<li>协议数据单元：帧 (frame)  </li>
</ul>
<p><strong>物理层</strong>：在线路上传送 bit  </p>
<ul>
<li>把数据转换成物理信号承载在媒体上传输出去，接收方将物理信号再转换为数据信息  </li>
<li>协议数据单元：位 (bit)  </li>
</ul>
<p><em>链路层和物理层协议一般封装在同一张网卡中</em>  </p>
<p><img src="/2022/03/14/computernetworknotes1/Internetxieyizhan.png">  </p>
<h3 id="ISO-OSI-参考模型"><a href="#ISO-OSI-参考模型" class="headerlink" title="ISO/OSI 参考模型"></a>ISO/OSI 参考模型</h3><p><strong>表示层</strong>：允许应用解释传输的数据  </p>
<ul>
<li>关心数据语义方面的信息和核心内容，而不是关心具体表达、如何编码</li>
<li>加密、压缩、机器相关的表示转换  </li>
</ul>
<p><strong>会话层</strong>：数据交换的同步，检查点，恢复  </p>
<ul>
<li>会话管理：建立会话、维持会话  </li>
</ul>
<p><em>Internet 协议栈中没有以上两层，但依靠应用层来实现以上两层实现的功能</em>  </p>
<p><img src="/2022/03/14/computernetworknotes1/ISO.png">  </p>
<h3 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a>封装和解封装</h3><p><img src="/2022/03/14/computernetworknotes1/seal.png" alt="封装和解封装">  </p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>识别和消除批次效应的R包proBatch的使用</title>
    <url>/2021/11/08/proBatch/</url>
    <content><![CDATA[<center>proBatch: Tools for Diagnostics and Corrections of Batch Effects in Proteomics</center>
<span id="more"></span>

<h2 id="proBatch简介"><a href="#proBatch简介" class="headerlink" title="proBatch简介"></a>proBatch简介</h2><p>proBatch是便于在高通量实验中进行批量效应分析和校正的分析工具。主要为质谱蛋白质组学(DIA/SWATH)开发，但也可在调整后应用于大多数的Omic数据。<br>proBatch包含  </p>
<ul>
<li>诊断(蛋白质组/基因组范围和特征水平)  </li>
<li>校正(归一化和批次效应校正)  </li>
<li>基于非线性拟合的方法来处理复杂的、质谱特有的信号漂移</li>
<li>质量控制<br>功能。  </li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装所需的其它包"><a href="#安装所需的其它包" class="headerlink" title="安装所需的其它包"></a>安装所需的其它包</h3><p>proBatch主要通过调用其它包中的函数实现功能，因此依赖于许多其它已有的R包。如果其中一些包未安装，则需要在运行proBatch之前安装。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bioc_deps &lt;- <span class="built_in">c</span>(<span class="string">&quot;GO.db&quot;</span>, <span class="string">&quot;impute&quot;</span>, <span class="string">&quot;preprocessCore&quot;</span>, <span class="string">&quot;pvca&quot;</span>,<span class="string">&quot;sva&quot;</span> )</span><br><span class="line">cran_deps &lt;- <span class="built_in">c</span>(<span class="string">&quot;corrplot&quot;</span>, <span class="string">&quot;data.table&quot;</span>, <span class="string">&quot;ggplot2&quot;</span>, <span class="string">&quot;ggfortify&quot;</span>,<span class="string">&quot;lazyeval&quot;</span>, <span class="string">&quot;lubridate&quot;</span>, <span class="string">&quot;pheatmap&quot;</span>, <span class="string">&quot;reshape2&quot;</span>,<span class="string">&quot;readr&quot;</span>, <span class="string">&quot;rlang&quot;</span>, <span class="string">&quot;tibble&quot;</span>, <span class="string">&quot;dplyr&quot;</span>, <span class="string">&quot;tidyr&quot;</span>, <span class="string">&quot;wesanderson&quot;</span>,<span class="string">&quot;WGCNA&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">  install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line">BiocManager::install(bioc_deps)</span><br><span class="line">install.packages(cran_deps)</span><br></pre></td></tr></table></figure>
<h3 id="安装proBatch"><a href="#安装proBatch" class="headerlink" title="安装proBatch"></a>安装proBatch</h3><p>可通过以下三个途径获取proBatch包：  </p>
<ul>
<li><a href="https://www.bioconductor.org/packages/release/bioc/html/proBatch.html">Bioconductor</a>  <figure class="highlight r"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">        install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line"></span><br><span class="line">    BiocManager::install(<span class="string">&quot;proBatch&quot;</span>)</span><br><span class="line">    ```  </span><br><span class="line">- [Docker container](https://hub.docker.com/r/digitalproteomes/probatch)  </span><br><span class="line">- [GitHub repository](https://github.com/symbioticMe/batch_effects_workflow_code)  </span><br><span class="line">  ```R</span><br><span class="line">    library(devtools)</span><br><span class="line">    install_github(<span class="string">&quot;symbioticMe/proBatch&quot;</span>, build_vignettes = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<h2 id="proBatch的使用"><a href="#proBatch的使用" class="headerlink" title="proBatch的使用"></a>proBatch的使用</h2>要查看与系统中安装的proBatch版本相对应的说明文档，启动R并输入:  <figure class="highlight r"><table><tr><td class="code"><pre><span class="line">browseVignettes(<span class="string">&quot;proBatch&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用前的tips"><a href="#使用前的tips" class="headerlink" title="使用前的tips"></a>使用前的tips</h3><ul>
<li>一些基本的数据处理步骤已经完成，如已经完成搜库比对、FDR control、log-transformation等  </li>
<li>数据过滤。应过滤掉诱饵测量值(decoy measurements)以确保正确的样本强度分布对齐。过滤掉低质量的样本(通常通过鉴定肽的总强度或样品的相关性来确定)  </li>
<li>建议在批次效应校正之前不要填补缺失值  </li>
<li>在消除批次效应之后再进行蛋白质定量  </li>
</ul>
<h3 id="Preparing-for-data-analysis"><a href="#Preparing-for-data-analysis" class="headerlink" title="Preparing for data analysis"></a>Preparing for data analysis</h3><h4 id="Loading-the-libraries"><a href="#Loading-the-libraries" class="headerlink" title="Loading the libraries"></a>Loading the libraries</h4><p>加载所需的包，以便后续步骤的使用。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">require(dplyr)</span><br><span class="line">require(tibble)</span><br><span class="line">require(ggplot2)</span><br><span class="line">library(proBatch)</span><br></pre></td></tr></table></figure>
<h4 id="Input-data"><a href="#Input-data" class="headerlink" title="Input data"></a>Input data</h4><p>数据分析需要三个数据表，即：  </p>
<ol>
<li>measurement (data matrix)  </li>
<li>sample annotation  </li>
<li>feature annotation (optional) tables  </li>
</ol>
<p>如果对BioBase数据比较熟悉，则可认为上述的三种数据是：  </p>
<ol>
<li>assayData  </li>
<li>joined phenoData and protocolData  </li>
<li>featureData  </li>
</ol>
<p>三种数据可参考包中给出的示例数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data(<span class="string">&#x27;example_proteome&#x27;</span>, <span class="string">&#x27;example_sample_annotation&#x27;</span>, <span class="string">&#x27;example_peptide_annotation&#x27;</span>, package = <span class="string">&#x27;proBatch&#x27;</span>)  </span><br></pre></td></tr></table></figure>
<p>或<a href="http://www.bioconductor.org/packages/release/bioc/vignettes/proBatch/inst/doc/proBatch.pdf">proBatch overview</a>中的详细说明。  </p>
<h4 id="其它有用的函数"><a href="#其它有用的函数" class="headerlink" title="其它有用的函数"></a>其它有用的函数</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transforming the data to long or wide format</span></span><br><span class="line">example_matrix &lt;- long_to_matrix(example_proteome, feature_id_col = <span class="string">&#x27;peptide_group_label&#x27;</span>, measure_col = <span class="string">&#x27;Intensity&#x27;</span>, sample_id_col = <span class="string">&#x27;FullRunName&#x27;</span>)</span><br><span class="line"><span class="comment"># Transforming the data to log scale</span></span><br><span class="line"><span class="comment"># 零值会被保留为零</span></span><br><span class="line">log_transformed_matrix &lt;- log_transform_dm(example_matrix, log_base = <span class="number">2</span>, offset = <span class="number">1</span>)</span><br><span class="line"><span class="comment"># Defining the color scheme</span></span><br><span class="line">color_list &lt;- sample_annotation_to_colors(example_sample_annotation, factor_columns = <span class="built_in">c</span>(<span class="string">&#x27;MS_batch&#x27;</span>, <span class="string">&#x27;digestion_batch&#x27;</span>, <span class="string">&#x27;EarTag&#x27;</span>, <span class="string">&#x27;Strain&#x27;</span>, <span class="string">&#x27;Diet&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>), numeric_columns = <span class="built_in">c</span>(<span class="string">&#x27;DateTime&#x27;</span>,<span class="string">&#x27;order&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Initial-assessment-of-the-raw-data-matrix"><a href="#Initial-assessment-of-the-raw-data-matrix" class="headerlink" title="Initial assessment of the raw data matrix"></a>Initial assessment of the raw data matrix</h3><h4 id="Plotting-the-sample-mean"><a href="#Plotting-the-sample-mean" class="headerlink" title="Plotting the sample mean"></a>Plotting the sample mean</h4><p>proBatch建议在处理批次效应之后再填补缺失值，但包中没有兼容存在缺失值的情况，如果有缺失值无法计算mean。<br><code>plot_sample_mean</code>函数主要实现的功能为计算样本均值并绘制样本均值散点图，横坐标为样本顺序(order)，纵坐标为样本均值(Mean_Intensity)，并以不同颜色表示样本的batch。可通过自行编写能够兼容缺失值的代码实现这一功能。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot_sample &lt;- data.frame(row.names = colnames(log_transformed_matrix))</span><br><span class="line">colnum &lt;- ncol(log_transformed_matrix)</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">1</span>:colnum))</span><br><span class="line">&#123;</span><br><span class="line">  item &lt;- colnames(log_transformed_matrix)[i]</span><br><span class="line">  plot_sample[item, <span class="string">&quot;mean&quot;</span>] &lt;- mean(log_transformed_matrix[,i], na.rm=<span class="built_in">T</span>)</span><br><span class="line">  plot_sample[item,<span class="string">&quot;MS_batch&quot;</span>] &lt;- sample_anno[i,<span class="string">&quot;MS_batch&quot;</span>]</span><br><span class="line">  plot_sample[item,<span class="string">&quot;order&quot;</span>] &lt;- sample_anno[i,<span class="string">&quot;order&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">ggplot(plot_sample, aes(order, mean, color = MS_batch)) + geom_point() + xlab(<span class="string">&quot;order&quot;</span>) + ylab(<span class="string">&quot;Mean_intensity&quot;</span>) + ylim(<span class="number">0</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Plotting-boxplots"><a href="#Plotting-boxplots" class="headerlink" title="Plotting boxplots"></a>Plotting boxplots</h4><p>绘制箱图观察数据：  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">log_transformed_long &lt;- matrix_to_long(log_transformed_matrix)</span><br><span class="line">batch_col = <span class="string">&#x27;MS_batch&#x27;</span></span><br><span class="line">plot_boxplot(log_transformed_long, example_sample_annotation, batch_col = batch_col, color_scheme = color_list[[batch_col]])</span><br></pre></td></tr></table></figure>
<p>利用PEAKS数据做到这一步时发现产生的箱图向0偏，即含有大量0值。这是PEAKS搜库结果的一个特点，除了缺失值还会有大量intensity被定量为0。在之前处理PEAKS数据时，log-transformation步骤会将0转换为NA，在后续步骤也当作缺失值处理。<br><img src="/2021/11/08/proBatch/value0.png" alt="含有大量0值"><br>而proBatch包针对的是openSWATH产生的tsv数据。该包中的函数<code>log_transform_dm</code>会将0保留为0，导致使用PEAKS数据画箱图时出现问题。返回log-transformation步骤使用自己写的处理代码处理数据后，箱图绘制与预期一致。<br><img src="/2021/11/08/proBatch/valueNA.png" alt="将0转换为NA">  </p>
<h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>包中提供Median Normalization和Quantiles Normalization，可直接使用。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Median Normalization</span></span><br><span class="line"><span class="comment"># If data has been log transformed</span></span><br><span class="line">median_normalized_matrix = normalize_data_dm(log_transformed_matrix, normalize_func = <span class="string">&#x27;medianCentering&#x27;</span>)</span><br><span class="line"><span class="comment"># if data hasn&#x27;t been log transformed</span></span><br><span class="line">median_normalized_matrix = normalize_data_dm(example_matrix, normalize_func = <span class="string">&#x27;medianCentering&#x27;</span>, log_base = <span class="number">2</span>, offset = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Quantile Normalization</span></span><br><span class="line">quantile_normalized_matrix = normalize_data_dm(log_transformed_matrix, normalize_func = <span class="string">&#x27;quantile&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>后续相应的画图观察处理后的数据时，应注意Inf值的影响。数据中如有<code>Inf</code>或<code>-Inf</code>，可通过<code>data[data == Inf] &lt;- NA</code>或<code>data[data == -Inf] &lt;- NA</code>将其替换。Inf出现是因为在log转换时没有处理好0值。  </p>
<h3 id="Diagnostics-of-batch-effects-in-normalized-data"><a href="#Diagnostics-of-batch-effects-in-normalized-data" class="headerlink" title="Diagnostics of batch effects in normalized data"></a>Diagnostics of batch effects in normalized data</h3><h4 id="Hierarchical-clustering-amp-heatmap"><a href="#Hierarchical-clustering-amp-heatmap" class="headerlink" title="Hierarchical clustering &amp; heatmap"></a>Hierarchical clustering &amp; heatmap</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">selected_annotations &lt;- <span class="built_in">c</span>(<span class="string">&#x27;MS_batch&#x27;</span>, <span class="string">&#x27;digestion_batch&#x27;</span>, <span class="string">&#x27;Diet&#x27;</span>)</span><br><span class="line"><span class="comment"># Plot clustering between samples</span></span><br><span class="line">plot_hierarchical_clustering(quantile_normalized_matrix, sample_annotation = example_sample_annotation, color_list = color_list, factors_to_plot = selected_annotations, distance = <span class="string">&#x27;euclidean&#x27;</span>, agglomeration = <span class="string">&#x27;complete&#x27;</span>, label_samples = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment"># Heatmap</span></span><br><span class="line">plot_heatmap_diagnostic(quantile_normalized_matrix, example_sample_annotation, factors_to_plot = selected_annotations, cluster_cols = <span class="literal">TRUE</span>, color_list = color_list, show_rownames = <span class="literal">FALSE</span>, show_colnames = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p>根据报错信息可知color_list一项一直与我的数据不兼容，因此注释行显示不完全。<br>修改color_list或根据数据需要重写聚类绘图函数即可。   </p>
<h4 id="PCA-amp-PVCA"><a href="#PCA-amp-PVCA" class="headerlink" title="PCA &amp; PVCA"></a>PCA &amp; PVCA</h4><p>PCA和PVCA使用时，缺失值会被直接填为-1。<br>PVCA对计算的要求很高，且耗时较长，尤其是数据量大的情况。建议在性能较好的机器上运行这一步骤。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pca</span></span><br><span class="line">pca1 = plot_PCA(median_normalized_matrix, sample_anno, color_by = <span class="string">&#x27;MS_batch&#x27;</span>, plot_title = <span class="string">&#x27;MS batch&#x27;</span>, color_scheme = color_list[[<span class="string">&#x27;MS_batch&#x27;</span>]])</span><br><span class="line">pca2 = plot_PCA(median_normalized_matrix, sample_anno, color_by = <span class="string">&#x27;digestion_batch&#x27;</span>, plot_title = <span class="string">&#x27;Digestion batch&#x27;</span>, color_scheme = color_list[[<span class="string">&#x27;digestion_batch&#x27;</span>]])</span><br><span class="line">pca3 = plot_PCA(median_normalized_matrix, sample_anno, color_by = <span class="string">&#x27;order&#x27;</span>, plot_title = <span class="string">&#x27;order&#x27;</span>, color_scheme = color_list[[<span class="string">&#x27;order&#x27;</span>]])</span><br><span class="line">pca4 = plot_PCA(median_normalized_matrix, sample_anno, color_by = <span class="string">&#x27;DateTime&#x27;</span>, plot_title = <span class="string">&#x27;DateTime&#x27;</span>, color_scheme = color_list[[<span class="string">&#x27;DateTime&#x27;</span>]])</span><br><span class="line">library(ggpubr)</span><br><span class="line">ggarrange(pca1, pca2, pca3, pca4, ncol = <span class="number">2</span>, nrow = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pvca</span></span><br><span class="line">technical_factors = <span class="built_in">c</span>(<span class="string">&#x27;MS_batch&#x27;</span>, <span class="string">&#x27;digestion_batch&#x27;</span>)</span><br><span class="line">biological_factors = <span class="literal">NULL</span></span><br><span class="line">biospecimen_id_col = <span class="string">&#x27;EarTag&#x27;</span></span><br><span class="line">plot_PVCA(median_normalized_matrix, sample_anno, technical_factors = technical_factors, biological_factors = biological_factors)</span><br></pre></td></tr></table></figure>

<h4 id="Peptide-level-diagnostics-and-spike-ins"><a href="#Peptide-level-diagnostics-and-spike-ins" class="headerlink" title="Peptide-level diagnostics and spike-ins"></a>Peptide-level diagnostics and spike-ins</h4><p>这一步骤需要将来自同一蛋白的肽段注释在一起。如果缺少肽段的注释信息，这一步骤无法正常进行。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">median_normalized_long &lt;- matrix_to_long(median_normalized_matrix)</span><br><span class="line">plot_spike_in(median_normalized_long, sample_anno, peptide_annotation = peptide_anno, protein_col = <span class="string">&#x27;Gene&#x27;</span>, spike_ins = <span class="string">&#x27;BOVINE_A1ag&#x27;</span>, plot_title = <span class="string">&#x27;Spike-in BOVINE protein peptides&#x27;</span>, color_by_batch = <span class="literal">TRUE</span>, color_scheme = color_list[[batch_col]])</span><br></pre></td></tr></table></figure>

<h3 id="correction-batch-effect"><a href="#correction-batch-effect" class="headerlink" title="correction batch effect"></a>correction batch effect</h3><h4 id="Continuous-drift-correction"><a href="#Continuous-drift-correction" class="headerlink" title="Continuous drift correction"></a>Continuous drift correction</h4><p>处理连续型批次效应使用LOESS拟合。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">loess_fit_df &lt;- adjust_batch_trend_df(quantile_normalized_long, example_sample_annotation)</span><br><span class="line">loess_fit_70 &lt;- adjust_batch_trend_df(median_normalized_long, sample_anno, span = <span class="number">0.7</span>)</span><br><span class="line">plot_with_fitting_curve(feature_name = <span class="string">&#x27;N(+.98)NATVHEQVGGPSLTSDLQAQSK&#x27;</span>, fit_df = loess_fit_70, fit_value_col = <span class="string">&#x27;fit&#x27;</span>, df_long = median_normalized_long, sample_annotation = sample_anno, color_by_batch = <span class="literal">TRUE</span>, color_scheme = color_list[[batch_col]], plot_title = <span class="string">&#x27;Span = 70%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Discrete-batch-correction"><a href="#Discrete-batch-correction" class="headerlink" title="Discrete batch correction"></a>Discrete batch correction</h4><p>处理离散型批次效应可通过median centering (per feature per batch)和ComBat进行。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># median centering</span></span><br><span class="line">peptide_median_df &lt;- center_feature_batch_medians_df(loess_fit_df, sample_anno)</span><br><span class="line">plot_single_feature(feature_name = <span class="string">&#x27;N(+.98)NATVHEQVGGPSLTSDLQAQSK&#x27;</span>, df_long = peptide_median_df, sample_annotation = sample_anno, measure_col = <span class="string">&#x27;Intensity&#x27;</span>, plot_title = <span class="string">&#x27;Feature-level Median Centered&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ComBat</span></span><br><span class="line">comBat_df &lt;- correct_with_ComBat_df(loess_fit_df, example_sample_annotation)</span><br><span class="line">plot_single_feature(feature_name = <span class="string">&#x27;10231_QDVDVWLWQQEGSSK_2&#x27;</span>, df_long = loess_fit_df, sample_annotation = example_sample_annotation, plot_title = <span class="string">&#x27;Loess Fitted&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Correct-batch-effects-universal-function"><a href="#Correct-batch-effects-universal-function" class="headerlink" title="Correct batch effects: universal function"></a>Correct batch effects: universal function</h4><p>proBatch提供一个方便的多合一的函数来进行批量校正。<br>函数<code>correct_batch_effects_df()</code>能在一次函数调用中可修正MS信号漂移和离散位移。只需在<code>discrete_func</code>中指定首选的离散校正方法，即<code>&quot;ComBat &quot;</code>或 <code>&quot;MedianCentering&quot;</code>。并补充其他参数，如<code>adjust_batch_trend_df()</code>中的<code>span</code>、<code>abs_threshold</code>或<code>pct_threshold</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">batch_corrected_df &lt;- correct_batch_effects_df(df_long = median_normalized_long, sample_annotation = sample_anno,discrete_func = <span class="string">&#x27;ComBat&#x27;</span>,continuous_func = <span class="string">&#x27;loess_regression&#x27;</span>,abs_threshold = <span class="number">5</span>, pct_threshold = <span class="number">0.20</span>)</span><br><span class="line">batch_corrected_matrix &lt;- long_to_matrix(batch_corrected_df)</span><br></pre></td></tr></table></figure>
<h3 id="Quality-control"><a href="#Quality-control" class="headerlink" title="Quality control"></a>Quality control</h3><h4 id="Heatmap-of-selected-replicate-samples"><a href="#Heatmap-of-selected-replicate-samples" class="headerlink" title="Heatmap of selected replicate samples"></a>Heatmap of selected replicate samples</h4><p>挑选重复组计算相关性并绘制热图观察批次效应处理结果。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specify which samples to correlate</span></span><br><span class="line">earTags &lt;- <span class="built_in">c</span>(<span class="string">&#x27;ET1524&#x27;</span>, <span class="string">&#x27;ET2078&#x27;</span>, <span class="string">&#x27;ET1322&#x27;</span>, <span class="string">&#x27;ET1566&#x27;</span>, <span class="string">&#x27;ET1354&#x27;</span>, <span class="string">&#x27;ET1420&#x27;</span>, <span class="string">&#x27;ET2154&#x27;</span>, <span class="string">&#x27;ET1515&#x27;</span>, <span class="string">&#x27;ET1506&#x27;</span>, <span class="string">&#x27;ET2577&#x27;</span>, <span class="string">&#x27;ET1681&#x27;</span>, <span class="string">&#x27;ET1585&#x27;</span>, <span class="string">&#x27;ET1518&#x27;</span>, <span class="string">&#x27;ET1906&#x27;</span>)</span><br><span class="line">replicate_filenames = example_sample_annotation %&gt;% filter(MS_batch %in% <span class="built_in">c</span>(<span class="string">&#x27;Batch_2&#x27;</span>, <span class="string">&#x27;Batch_3&#x27;</span>)) %&gt;% filter(EarTag %in% earTags) %&gt;% pull(!!sym(<span class="string">&#x27;FullRunName&#x27;</span>))</span><br><span class="line"><span class="comment"># plot the ‘exploratory’ correlation matrix, which can be further beautified</span></span><br><span class="line">p1_exp = plot_sample_corr_heatmap(log_transformed_matrix, samples_to_plot = replicate_filenames, plot_title = <span class="string">&#x27;Correlation of selected samples&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># To ensure the color scale for correlation is consistent between two plots, we create a color vector and breaks</span></span><br><span class="line">breaksList &lt;- seq(<span class="number">0.7</span>, <span class="number">1</span>, by = <span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># color scale of pheatmap</span></span><br><span class="line">heatmap_colors = colorRampPalette(rev(RColorBrewer::brewer.pal(n = <span class="number">7</span>, name = <span class="string">&#x27;RdYlBu&#x27;</span>)))(<span class="built_in">length</span>(breaksList) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the heatmap with annotations for the chosen samples</span></span><br><span class="line">factors_to_show = <span class="built_in">c</span>(batch_col, biospecimen_id_col)</span><br><span class="line">p1 = plot_sample_corr_heatmap(log_transformed_matrix, samples_to_plot = replicate_filenames,sample_annotation = example_sample_annotation, factors_to_plot = factors_to_show, plot_title = <span class="string">&#x27;Log transformed correlation matrix of selected replicated samples&#x27;</span>, color_list = color_list, heatmap_color = heatmap_colors, breaks = breaksList, cluster_rows= <span class="literal">FALSE</span>, cluster_cols=<span class="literal">FALSE</span>,fontsize = <span class="number">4</span>, annotation_names_col = <span class="literal">TRUE</span>, annotation_legend = <span class="literal">FALSE</span>, show_colnames = <span class="literal">FALSE</span>)</span><br><span class="line">p2 = plot_sample_corr_heatmap(batch_corrected_matrix, samples_to_plot = replicate_filenames, sample_annotation = example_sample_annotation, factors_to_plot = factors_to_show, plot_title = <span class="string">&#x27;Batch Corrected selected replicated samples&#x27;</span>, color_list = color_list, heatmap_color = heatmap_colors, breaks = breaksList, cluster_rows= <span class="literal">FALSE</span>, cluster_cols=<span class="literal">FALSE</span>,fontsize = <span class="number">4</span>, annotation_names_col = <span class="literal">TRUE</span>, annotation_legend = <span class="literal">FALSE</span>, show_colnames = <span class="literal">FALSE</span>)</span><br><span class="line">library(gridExtra)</span><br><span class="line">grid.arrange(grobs = <span class="built_in">list</span>(p1$gtable, p2$gtable), ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>由于缺失值的存在，直接使用包中函数进行这一步骤失败，自己写代码代替。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(pheatmap)</span><br><span class="line"><span class="comment"># 计算样本间的相关性</span></span><br><span class="line"><span class="comment"># completel.obs: 计算所有样本间overlap的部分，如果某一行有缺失值则这一行不加入计算</span></span><br><span class="line">mcor &lt;- cor(select_replicate_samples, method = <span class="string">&#x27;pearson&#x27;</span>, use = <span class="string">&quot;complete.obs&quot;</span>)</span><br><span class="line">pheatmap(mcor, cellwidth = <span class="number">25</span>, cellheight = <span class="number">25</span>, color = colorRampPalette(<span class="built_in">c</span>(<span class="string">&quot;#ffffff&quot;</span>, <span class="string">&quot;#4682b4&quot;</span>))(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Correlation-distribution-of-samples"><a href="#Correlation-distribution-of-samples" class="headerlink" title="Correlation distribution of samples"></a>Correlation distribution of samples</h4><p>绘制相同或不同批次的生物重复和非生物重复之间的相关分布。<br>样本相关性的比较不应该通过评估重复组内与批次内校正的单个例子来进行，而应该通过比较分布来进行。除非这些例子是在整个分布结构的背景下显示的，否则它们会导致错误的结论。样品相关性经常被用来证明测量的质量，因为它通常是非常高的(重复组相关性超过0.95的例子在质谱分析中很常见)。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sample_cor_raw &lt;- plot_sample_corr_distribution(log_transformed_matrix, example_sample_annotation,repeated_samples = replicate_filenames, batch_col = <span class="string">&#x27;MS_batch&#x27;</span>, biospecimen_id_col = <span class="string">&#x27;EarTag&#x27;</span>, plot_title = <span class="string">&#x27;Correlation of samples (raw)&#x27;</span>, plot_param = <span class="string">&#x27;batch_replicate&#x27;</span>)</span><br><span class="line">raw_corr = sample_cor_raw + theme(axis.text.x = element_text(angle = <span class="number">45</span>, hjust = <span class="number">1</span>)) + ylim(<span class="number">0.7</span>,<span class="number">1</span>) + xlab(<span class="literal">NULL</span>)</span><br><span class="line">sample_cor_batchCor &lt;- plot_sample_corr_distribution(batch_corrected_matrix, example_sample_annotation, batch_col = <span class="string">&#x27;MS_batch&#x27;</span>, plot_title = <span class="string">&#x27;Batch corrected&#x27;</span>, plot_param = <span class="string">&#x27;batch_replicate&#x27;</span>)</span><br><span class="line">corr_corr = sample_cor_batchCor + theme(axis.text.x = element_text(angle = <span class="number">45</span>, hjust = <span class="number">1</span>)) + ylim(<span class="number">0.7</span>, <span class="number">1</span>) + xlab(<span class="literal">NULL</span>)</span><br><span class="line">library(gtable)</span><br><span class="line">library(grid)</span><br><span class="line">g2 &lt;- ggplotGrob(raw_corr)</span><br><span class="line">g3 &lt;- ggplotGrob(corr_corr)</span><br><span class="line">g &lt;- cbind(g2, g3, size = <span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">grid.draw(g)</span><br></pre></td></tr></table></figure>

<h4 id="Correlation-of-peptide-distributions-within-and-between-proteins"><a href="#Correlation-of-peptide-distributions-within-and-between-proteins" class="headerlink" title="Correlation of peptide distributions within and between proteins"></a>Correlation of peptide distributions within and between proteins</h4><p>来自同一蛋白的肽段之间会有更强的相关性，通过计算蛋白内和蛋白间肽段的相关性观察批次效应处理结果。<br>这一步骤对计算的要求较高，且数据量大时耗时较长。建议使用性能较好的电脑进行这一步骤的计算。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">peptide_cor_raw &lt;- plot_peptide_corr_distribution(log_transformed_matrix, example_peptide_annotation, protein_col = <span class="string">&#x27;Gene&#x27;</span>, plot_title = <span class="string">&#x27;Peptide correlation (raw)&#x27;</span>)</span><br><span class="line">peptide_cor_batchCor &lt;- plot_peptide_corr_distribution(batch_corrected_matrix, example_peptide_annotation, protein_col = <span class="string">&#x27;Gene&#x27;</span>, plot_title = <span class="string">&#x27;Peptide correlation (batch correcte)&#x27;</span>)</span><br><span class="line">g2 &lt;- ggplotGrob(peptide_cor_raw+ ylim(<span class="built_in">c</span>(-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">g3 &lt;- ggplotGrob(peptide_cor_batchCor+ ylim(<span class="built_in">c</span>(-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">g &lt;- cbind(g2, g3, size = <span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">grid.draw(g)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://www.bioconductor.org/packages/release/bioc/manuals/proBatch/man/proBatch.pdf">proBatch Manual</a><br>[2] <a href="http://www.bioconductor.org/packages/release/bioc/vignettes/proBatch/inst/doc/proBatch.pdf">proBatch Overview</a>  </p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>proBatch</category>
      </categories>
      <tags>
        <tag>Rpackage</tag>
        <tag>BatchEffect</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 2：Applications</title>
    <url>/2022/03/23/computernetworknotes2/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络第二章应用层自学笔记 </center>
<span id="more"></span>

<br>

<h2 id="本章基本内容"><a href="#本章基本内容" class="headerlink" title="本章基本内容"></a>本章基本内容</h2><p>网络应用的<strong>原理</strong>：网络应用协议的概念和实现方面  </p>
<ul>
<li>传输层的服务模型  </li>
<li>客户-服务器模式  </li>
<li>对等模式 (peer-to-peer)  </li>
<li>内容分发网络  </li>
</ul>
<p>网络应用的<strong>实例</strong>：互联网流行的应用层协议  </p>
<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP / POP3 / IMAP  </li>
<li>DNS  </li>
</ul>
<p><strong>编程</strong>：网络应用程序</p>
<ul>
<li>Socket API  </li>
</ul>
<p>网络应用的例子：E-mail，Web，文本消息，远程登陆，P2P 文件共享，即时通信，多用户网络游戏，流媒体 (YouTube，Hulu，Netflix)，Internet 电话，实时电视会议，社交网络，搜索等  </p>
<br>

<h2 id="创建一个新的网络应用"><a href="#创建一个新的网络应用" class="headerlink" title="创建一个新的网络应用"></a>创建一个新的网络应用</h2><p>编程  </p>
<ul>
<li>在不同端系统上运行  </li>
<li>通过网络基础设施提供的服务，应用进程彼此通信  </li>
<li>eg. Web：Web服务器软件与浏览器软件通信  </li>
</ul>
<p>网络核心中没有应用层软件  </p>
<ul>
<li>网络核心没有应用层  </li>
<li>网络应用只在端系统上存在：快速网络应用开发和部署  </li>
</ul>
<br>

<h2 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h2><h3 id="客户-服务器模式-C-S-client-server"><a href="#客户-服务器模式-C-S-client-server" class="headerlink" title="客户-服务器模式 (C/S: client/server)"></a>客户-服务器模式 (C/S: client/server)</h3><p><strong>服务器</strong>  </p>
<ul>
<li>一直运行  </li>
<li>固定的 IP 地址和周知的端口号 (约定)  </li>
<li>扩展性：服务器场  <ul>
<li>数据中心进行扩展</li>
<li>扩展性差  </li>
<li>可靠性差：服务非常依赖于服务器的状态  </li>
</ul>
</li>
</ul>
<p><strong>客户端</strong>  </p>
<ul>
<li>主动与服务器通信  </li>
<li>与互联网各有间歇性的连接  </li>
<li>可能是动态 IP 地址  </li>
<li>不直接与其它客户端通信  </li>
</ul>
<h3 id="对等模式-P2P-Peer-to-Peer"><a href="#对等模式-P2P-Peer-to-Peer" class="headerlink" title="对等模式 (P2P: Peer to Peer)"></a>对等模式 (P2P: Peer to Peer)</h3><p>(几乎) 没有一直运行的服务器<br>任意端系统之间可以进行通信<br>每一个节点既是客户端又是服务器  </p>
<ul>
<li>自扩展性：新 peer 节点带来新的服务能力，也带来新的服务请求  </li>
</ul>
<p>参与的主机间歇性连接且可以改变 IP 地址  </p>
<ul>
<li>难以管理</li>
</ul>
<p>eg. Gnutella，迅雷  </p>
<h3 id="混合体：客户-服务器和对等体系结构"><a href="#混合体：客户-服务器和对等体系结构" class="headerlink" title="混合体：客户-服务器和对等体系结构"></a>混合体：客户-服务器和对等体系结构</h3><p><strong>Napster</strong>  </p>
<ul>
<li>文件搜索：集中  <ul>
<li>主机在中心服务器上注册其资源  </li>
<li>主机向中心服务器查询资源位置  </li>
</ul>
</li>
<li>文件传输：P2P  <ul>
<li>任意 Peer 节点之间</li>
</ul>
</li>
</ul>
<p><strong>即时通信</strong>  </p>
<ul>
<li>在线检测：集中  <ul>
<li>当用户上线时，向中心服务器注册其 IP 地址  </li>
<li>用户与中心服务器联系，已找到其在线好友的位置  </li>
</ul>
</li>
<li>两个用户之间聊天：P2P  </li>
</ul>
<br>  

<h2 id="应用层原理-进程通信"><a href="#应用层原理-进程通信" class="headerlink" title="应用层原理-进程通信"></a>应用层原理-进程通信</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>进程</strong>：在主机上运行的应用程序  </p>
<ul>
<li>客户端进程：发起通信的进程 (主动)  </li>
<li>服务器进程：等待连接的进程 (被动)  </li>
</ul>
<p><em>P2P 架构的应用也有客户端进程和服务器进程之分</em>  </p>
<p>在同一个主机内，使用<strong>进程间通信机制</strong>通信 (操作系统定义)<br>不同主机，通过交换<strong>报文</strong> (Message) 来通信  </p>
<ul>
<li>使用 OS 提供的通信服务  </li>
<li>按照应用协议交换报文：借助传输层提供的服务  </li>
</ul>
<h3 id="分布式进程通信需要解决的问题"><a href="#分布式进程通信需要解决的问题" class="headerlink" title="分布式进程通信需要解决的问题"></a>分布式进程通信需要解决的问题</h3><ol>
<li>进程标示和寻址问题 (服务用户)  </li>
<li>传输层-应用层如何提供服务 (服务)  <ul>
<li>位置：层间界面的 SAP (TCP/IP: socket)  </li>
<li>形式：应用程序接口 API (TCP/IP: socket API)  </li>
</ul>
</li>
<li>如何使用传输层提供的服务，实现应用进程之间的报文交换，即实现应用 (用户使用服务)  <ul>
<li>定义应用层协议：报文格式、解释、时序等  </li>
<li>编制程序，使用 OS 提供的 API，调用网络基础设施提供通信服务传报文，实现应用时序等  </li>
</ul>
</li>
</ol>
<h4 id="对进程进行编址-addressing"><a href="#对进程进行编址-addressing" class="headerlink" title="对进程进行编址 (addressing)"></a>对进程进行编址 (addressing)</h4><p>进程为了接收报文，必须有一个<strong>标识</strong>，即 SAP (发送也需要标示)  </p>
<ul>
<li>主机：唯一的 32 位 IP 地址  <ul>
<li>仅仅有 IP 地址不能唯一标示一个进程，在一台端系统上有很多应用进程在运行  </li>
</ul>
</li>
<li>所采用的传输层协议：TCP or UDP  </li>
<li>端口号 (Port Numbers)  <ul>
<li>一些知名端口号例子：HTTP TCP 80；Mail TCP 25；ftp TCP 2  </li>
</ul>
</li>
<li>一个进程：用 IP + port 标示，端节点  </li>
<li>本质上，一对主机进程之间的通信由 2 个端节点 (end point) 构成  </li>
</ul>
<h4 id="传输层提供的服务-需要穿过层间的信息"><a href="#传输层提供的服务-需要穿过层间的信息" class="headerlink" title="传输层提供的服务-需要穿过层间的信息"></a>传输层提供的服务-需要穿过层间的信息</h4><p>层间接口必须要携带的信息  </p>
<ul>
<li>要传输的报文 (对于本层来说：SDU)</li>
<li>谁传的：对方应用进程的标示 IP + TCP (UDP) 端口号  </li>
<li>传给谁：对方的应用进程标示 对方的 IP + TCP (UDP) 端口号  </li>
</ul>
<p>传输层实体 (TCP 或 UDP 实体)根据这些信息进行 TCP 报文段 (UDP 数据报)的封装  </p>
<ul>
<li>源端口号，目标端口号，数据等  </li>
<li>将 IP 地址往下交 IP 实体，用于封装 IP 数据报：源 IP，目标 IP  </li>
</ul>
<h4 id="传输层提供的服务-层间信息的代表"><a href="#传输层提供的服务-层间信息的代表" class="headerlink" title="传输层提供的服务-层间信息的代表"></a>传输层提供的服务-层间信息的代表</h4><p>如果 Socket API 每次传输报文都携带如此多的信息，太繁琐易错，不便于管理<br>用代号标示通信双方或单方：socket (代表本地 IP、本地端口和对方 IP、对方端口的一个本地标识)<br>类似 OS 打开文件返回句柄一样，对句柄的操作就是对文件的操作  </p>
<p><strong>TCP</strong> <strong>socket</strong>  </p>
<ul>
<li>TCP 服务，两个进程之间的通信之前需要建立连接  <ul>
<li>两个进程通信会<strong>持续</strong>一段时间，通信关系稳定  </li>
</ul>
</li>
<li>可用一个征数标示两个应用实体之间的通信关系，<strong>本地</strong>标示 (便于本地管理引入的一个标识)  </li>
<li>穿过层间接口的信息量<strong>最小</strong>  </li>
<li>TCP socket：源 IP，源端口，目标IP，目标端口；用于指明应用进程会话的本地标示  </li>
<li>TCP之上的套接字 (socket)：对于使用面向连接的服务 (TCP) 的应用而言，套接字时 4 元组的一个具有<strong>本地意义的标示</strong>  <ul>
<li>4 元组：源 IP、源 port、目标 IP、目标 port  </li>
<li>唯一的制定了一个会话 (2 个进程之间的会话关系)  </li>
<li>应用使用这个标示，与远程的应用进程通信  </li>
<li>不必在每一个报文的发送都要指定这个 4 元组  </li>
<li>类似文件句柄，每次使用文件句柄，而不是使用文件的目录名、文件名等  </li>
<li>简单，便于管理，层间传输的信息较少  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/TCPsocket.png" alt="TCP socket">  </p>
<p><strong>UDP</strong> <strong>socket</strong>  </p>
<ul>
<li>UDP 服务：两个进程之间的通信之前不需要建立连接  <ul>
<li>每个报文都是独立传输的  </li>
<li>前后报文可能给不同的分布式进程  </li>
</ul>
</li>
<li>只能用一个征数标示本应用实体的标示，因为这个报文可能传给另外一个分布式进程  </li>
<li>穿过层间接口的信息量最小  </li>
<li>UDP socket：本IP，本端口；2 元组，本地标示  </li>
<li>传输报文时，必须提供对方 IP、port；接收报文时，传输层需要上传对方的 IP、port  </li>
<li>UDP 之上的套接字 (socket)：对于使用无连接服务 (UDP) 的应用而言，套接字是 2 元组的一个具有<strong>本地意义的标示</strong>  <ul>
<li>2 元组：IP，port (源端指定)  </li>
<li>UDP 套接字指定了应用所在的一个<strong>端节点</strong> (end point)  </li>
<li>在发送数据报时，采用创建好的本地套接字 (标示 ID)，就不必在发送每个报文中指明自己所采用的 IP 和 port  </li>
<li>在发送报文时，必须置顶对方的 IP 和 UDP port (另外一个段节点)  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/UDPsocket.png" alt="UDP socket"></p>
<p><strong>套接字</strong> (Socket)  </p>
<ul>
<li>进程向套接字发送报文，或从套接字接收报文  </li>
<li>套接字 &lt;-&gt; 门户  <ul>
<li>发送进程将报文<strong>推出</strong>门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接收进程  </li>
<li>接收进程从另外一段的门户<strong>收到</strong>报文 (依赖于传输层设施)  </li>
</ul>
</li>
</ul>
<h4 id="如何使用传输层提供的服务实现应用"><a href="#如何使用传输层提供的服务实现应用" class="headerlink" title="如何使用传输层提供的服务实现应用"></a>如何使用传输层提供的服务实现应用</h4><p><strong>应用层协议</strong>  </p>
<ul>
<li>定义了运行在不同端系统上的应用进程如何相互交换报文  <ul>
<li>交换的<strong>报文类型</strong>：请求和应答报文  </li>
<li>各种报文类型的<strong>语法</strong>：报文中的各个字段及其描述  </li>
<li>字段的<strong>语义</strong>：即字段取值的含义  </li>
<li>进程何时、如何发送报文及对报文进行响应的<strong>规则</strong>  </li>
</ul>
</li>
<li>应用协议仅仅是应用的一个组成部分，仅规范通信交互规则<ul>
<li>Web 应用：HTTP 协议、web 客户端、web 服务器、HTML  </li>
</ul>
</li>
<li>公开协议<ul>
<li>由 RFC 文档定义</li>
<li>允许互操作</li>
<li>eg. HTTP、SMTP  </li>
</ul>
</li>
<li>专用 (私有) 协议  <ul>
<li>协议不公开</li>
<li>eg. Skype  </li>
</ul>
</li>
</ul>
<p><strong>应用需要传输层提供什么服务</strong>  </p>
<ul>
<li>数据丢失率  <ul>
<li>有些应用要求 100 % 的可靠数据传输，如文件  </li>
<li>有些应用能容忍一定比例一下的数据丢失，如音频  </li>
</ul>
</li>
<li>延迟  <ul>
<li>一些应用出于有效性考虑，对数据传输有严格的时间限制，如 Internet 电话、交互式游戏</li>
</ul>
</li>
<li>吞吐  <ul>
<li>一些应用必须需要最小限度的吞吐，从而使得应用能够有效运转，如多媒体  </li>
<li>一些应用能充分利用可供使用的吞吐，如弹性应用  </li>
</ul>
</li>
<li>安全性  <ul>
<li>机密性  </li>
<li>完整性</li>
<li>可认证性 (鉴别)  </li>
</ul>
</li>
</ul>
<p><strong>Internet</strong> <strong>传输层提供的服务</strong>  </p>
<ul>
<li>TCP 服务<ul>
<li>可靠的传输服务  </li>
<li>流量控制：发送方不会淹没接收方  </li>
<li>拥塞控制：当网络出现拥塞时，能抑制发送方  </li>
<li>不能提供的服务：时间保证、最小吞吐量保证和安全  </li>
<li>面向连接：要求在客户端进程和服务器进程之间建立连接  </li>
</ul>
</li>
<li>UDP 服务  <ul>
<li>不考考的数据传输  </li>
<li>不提供的服务：可靠、流量控制、拥塞控制、时间、带宽保证、建立连接  </li>
</ul>
</li>
</ul>
<p><em>UDP 存在的必要性</em>  </p>
<ul>
<li>能够区分不同的进程，而 IP 服务不能  <ul>
<li>在 IP 提供的主机到主机端到端功能的基础上，区分了主机的应用进程  </li>
</ul>
</li>
<li>无需建立连接，省去建立连接的时间，适合事务性的应用  </li>
<li>不做可靠性的工作，如检错重发  <ul>
<li>适合对实时性要求较高而对正确性要求不高的应用  </li>
<li>为实现可靠性 (准确性、保序等)，必须付出时间代价 (检错重发)  </li>
</ul>
</li>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据  <ul>
<li>在 TCP 上的应用，应用发送数据的速度和主机向网络发送的实际速度不一致，因为有流量控制和拥塞控制  </li>
</ul>
</li>
</ul>
<p><strong>安全</strong> <strong>TCP</strong>  </p>
<ul>
<li>TCP &amp; UDP  <ul>
<li>都没有加密</li>
<li>明文通过互联网传输，甚至密码</li>
</ul>
</li>
<li>SSL (安全套接字层)  <ul>
<li>在 TCP 上实现，提供加密的 TCP 连接  </li>
<li>私密性  </li>
<li>数据完整性  </li>
<li>端到端的鉴别  </li>
<li>SSL 在应用层：应用采用 SSL 库，SSL 库使用 TCP 通信  </li>
<li>SSL socket API：应用通过 API 将明文交给 socket，SSL 将其加密在互联网上传输  </li>
</ul>
</li>
</ul>
<br>

<h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><h3 id="Web-页"><a href="#Web-页" class="headerlink" title="Web 页"></a>Web 页</h3><p>由一些<strong>对象</strong>组成，对象可以是 HTML 文件、JPEG 图像、Java 小程序、声音剪辑文件等<br>Web 页含有一个基本的 HTML 文件，该基本 HTML 文件又包含若干对象的引用 (链接)<br>通过 URL (通用资源调用符)对每个对象进行引用：访问协议、用户名、口令字、端口等，支持匿名访问，默认端口为 80<br>URL 格式：<br><img src="/2022/03/23/computernetworknotes2/URLform.png">  </p>
<h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>超文本传输协议 (Hyper Text Transform Protocol)，Web 的应用层协议<br>客户/服务器模式  </p>
<ul>
<li>客户：请求、接收和显示 Web 对象的浏览器  </li>
<li>服务器：对请求进行响应，发送对象的 Web 服务器  </li>
</ul>
<p>HTTP 1.0：RFC 1945<br>HTTP 1.1：RFC 2068  </p>
<h4 id="使用-TCP"><a href="#使用-TCP" class="headerlink" title="使用 TCP"></a>使用 TCP</h4><ul>
<li>客户发起一个与服务器的 TCP 连接 (建立套接字)，端口号为 80  </li>
<li>服务器接受客户的 TCP 连接  </li>
<li>在浏览器 (HTTP 客户端) 与 Web 服务器 (HTTP 服务器 server) 交换 HTTP 报文 (应用层协议报文)  </li>
<li>TCP 连接关闭  </li>
</ul>
<p>HTTP 是无状态的：服务器并不维护关于客户的任何信息，不维护客户端的状态<br>维护状态的协议很复杂：  </p>
<ul>
<li>必须维护历史信息 (状态)  </li>
<li>如果服务器/客户端死机，它们的状态信息可能不一致，二者的信息必须是一致的  </li>
<li>无状态的服务器能够支持更多的客户端  </li>
</ul>
<h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h3><h4 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a>响应时间模型</h4><p>往返时间 RTT (round-trip time)：一个小的分组从客户端到服务器，在回到客户端的时间 (传输时间忽略)<br>响应时间：  </p>
<ul>
<li>一个 RTT 用来发起 TCP 连接  </li>
<li>一个 RTT 用来 HTTP 请求并等待 HTTP 响应  </li>
<li>文件传输时间  </li>
</ul>
<p>  <em>共 2 RTT + 传输时间</em>  </p>
<p><img src="/2022/03/23/computernetworknotes2/RTTmodel.png" alt="响应时间模型">  </p>
<h4 id="非持久-HTTP"><a href="#非持久-HTTP" class="headerlink" title="非持久 HTTP"></a>非持久 HTTP</h4><p>最多只有一个对象在 TCP 连接上发送<br>下载多个对象需要多个 TCP 连接<br>HTTP 1.0 使用非持久连接<br>过程：TCP 连接请求 -&gt; TCP 连接确认 -&gt; HTTP 请求 -&gt; 对象回传 -&gt; 连接关闭请求 -&gt; 连接关闭确认  </p>
<p><img src="/2022/03/23/computernetworknotes2/unperHTTP.png" alt="非持久 HTTP 连接"><br><img src="/2022/03/23/computernetworknotes2/unperHTTP2.png" alt="非持久 HTTP 连接">  </p>
<p>非持久 HTTP 的缺点  </p>
<ul>
<li>每个对象要 2 个 RTT  </li>
<li>操作系统必须为每个 TCP 连接分配资源  </li>
<li>浏览器通常打开并行 TCP 连接，以获取引用对象  </li>
</ul>
<h4 id="持久-HTTP"><a href="#持久-HTTP" class="headerlink" title="持久 HTTP"></a>持久 HTTP</h4><p>多个对象可以在一个 (在客户端和服务器之间的) TCP 连接上传输<br>HTTP 1.1 默认使用持久连接<br>过程：TCP 连接请求 -&gt; TCP 连接确认 -&gt; HTTP 请求对象 -&gt; 对象回传；连接不关闭，之后再有请求可直接使用此路径  </p>
<ul>
<li>服务器在发送响应后，仍保持 TCP 连接  </li>
<li>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送  </li>
<li>客户端在遇到一个引用对象时，可以尽快发送该对象的请求</li>
</ul>
<p><em>非流水方式的持久</em> <em>HTTP</em>  </p>
<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求  </li>
<li>每个引用对象花费一个 RTT  </li>
</ul>
<p><em>流水方式的持久</em> <em>HTTP</em>  </p>
<ul>
<li>HTTP 1.1 的默认模式  </li>
<li>客户端遇到一个引用对象就立即产生一个请求  </li>
<li>所有引用 (小) 对象只花费一个 RTT 是可能的</li>
</ul>
<h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><p>两种类型的 HTTP 报文：请求，响应  </p>
<h4 id="HTTP-请求报文："><a href="#HTTP-请求报文：" class="headerlink" title="HTTP 请求报文："></a>HTTP 请求报文：</h4><p>ASCII (人能阅读，readable)<br>  <img src="/2022/03/23/computernetworknotes2/ASCIIrequest.png">  </p>
<p>通用格式<br>  <img src="/2022/03/23/computernetworknotes2/HTTPnormal.png">  </p>
<h4 id="提交表单输入"><a href="#提交表单输入" class="headerlink" title="提交表单输入"></a>提交表单输入</h4><p>Post 方式  </p>
<ul>
<li>网页通常包括表单输入  </li>
<li>包含在实体主体 (entity body) 中的输入被提交到服务器  </li>
</ul>
<p>URL 方式  </p>
<ul>
<li>方法：GET  </li>
<li>输入通过请求行的 URL 字段上载  </li>
</ul>
<h4 id="方法类型"><a href="#方法类型" class="headerlink" title="方法类型"></a>方法类型</h4><p>HTTP 1.0  </p>
<ul>
<li>GET  </li>
<li>POST</li>
<li>HEAD：要求服务器在响应报文中不包含请求对象 -&gt; 故障跟踪</li>
</ul>
<p>HTTP 1.1  </p>
<ul>
<li>GET, POST, HEAD</li>
<li>PUT：将实体主体中的文件上载到 URL 字段规定的路径，通常用于网页内容的维护  </li>
<li>DELETE：删除 URL 字段规定的文件，用于维护网页</li>
</ul>
<h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p><img src="/2022/03/23/computernetworknotes2/HTTPreaction.png" alt="HTTP 响应报文格式">  </p>
<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p><strong>状态行</strong>：协议版本、状态码 (如404、504等)和相应状态信息<br><strong>首部行</strong>：服务器、内容等的相关信息，如服务器系统信息、内容的字节长度等<br><strong>数据</strong>：如请求的 HTML 文件  </p>
<h4 id="HTTP-响应状态码"><a href="#HTTP-响应状态码" class="headerlink" title="HTTP 响应状态码"></a>HTTP 响应状态码</h4><p>位于服务器 -&gt; 客户端的响应报文中的首行<br>例子：  </p>
<ul>
<li>200 OK：请求成功，请求对象包含在响应报文的后续部分  </li>
<li>301 Moved Permanently：请求的对象已经被永久转移，新的 URL 在响应报文的 Location：首部行中指定；客户端软件自动用新的 URL 去获取对象  </li>
<li>400 Bad Request：一个通用的差错代码，表示该请求不能被服务器解读  </li>
<li>404 Not Found：请求的文档在服务器上没有找到  </li>
<li>505 HTTP Version Not Supported  </li>
</ul>
<h3 id="用户-服务器状态-cookies"><a href="#用户-服务器状态-cookies" class="headerlink" title="用户-服务器状态 cookies"></a>用户-服务器状态 cookies</h3><p>大多数主要的门户网站使用cookies，用于维护状态  </p>
<h4 id="4-个组成部分"><a href="#4-个组成部分" class="headerlink" title="4 个组成部分"></a>4 个组成部分</h4><p>在 HTTP 响应报文中有一个 cookie 的首部行<br>在 HTTP 请求报文含有一个 cookie 的首部行<br>在用户段系统中保留有一个 cookie 文件，由用户的浏览器管理<br>在 Web 站点有一个后端数据库<br><em>通过维护 cookie 使得 HTTP 这一无状态服务能够维护状态</em>  </p>
<p><img src="/2022/03/23/computernetworknotes2/cookies.png" alt="Cookies: 维护状态">  </p>
<h4 id="Cookies-的作用"><a href="#Cookies-的作用" class="headerlink" title="Cookies 的作用"></a>Cookies 的作用</h4><p>用户验证<br>购物车<br>推荐<br>用户状态 (Web Email)  </p>
<h4 id="如何维持状态"><a href="#如何维持状态" class="headerlink" title="如何维持状态"></a>如何维持状态</h4><p>协议端节点：在多个事务上，发送端和接收端维持状态<br>cookies：http 报文携带状态信息  </p>
<h4 id="Cookies-与隐私"><a href="#Cookies-与隐私" class="headerlink" title="Cookies 与隐私"></a>Cookies 与隐私</h4><p>Cookies 允许站点知道许多关于用户的信息<br>可能将这些信息卖给第三方<br>使用重定向和 cookie 的搜索引擎还能知道用户更多信息</p>
<ul>
<li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式 (互联网画像)  </li>
</ul>
<p>广告公司从站点获得信息  </p>
<h3 id="Web-缓存-代理服务器"><a href="#Web-缓存-代理服务器" class="headerlink" title="Web 缓存(代理服务器)"></a>Web 缓存(代理服务器)</h3><p>目标：不访问原始服务器，就满足客户的请求<br>用户设置浏览器：通过缓存访问 Web<br>缓存既是客户端又是服务器<br>通常缓存由 ISP 安装：大学、公司、居民区 ISP  </p>
<h4 id="缓存实现的方式"><a href="#缓存实现的方式" class="headerlink" title="缓存实现的方式"></a>缓存实现的方式</h4><p>浏览器将所有的 HTTP 请求发给缓存  </p>
<ul>
<li>在缓存中的对象：缓存直接返回对象 (本地访问)  </li>
<li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回客户端 (远程访问)  </li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/caches.png">  </p>
<h4 id="Web-缓存的优势"><a href="#Web-缓存的优势" class="headerlink" title="Web 缓存的优势"></a>Web 缓存的优势</h4><p>降低客户端的请求响应时间<br>可以大大减少一个机构内部网络与 Internet 接入链路上的流量<br>互联网大量采用缓存：可以使较弱的 ICP 也能有效提供内容  </p>
<h4 id="条件-GET-方法"><a href="#条件-GET-方法" class="headerlink" title="条件 GET 方法"></a>条件 GET 方法</h4><p>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象<br>缓存器：在 HTTP 请求中指定缓存拷贝的日期：<code>If-modified-since: &lt;date&gt;</code><br>服务器：如果缓存拷贝不陈旧，则响应报文没包含对象：HTTP/1.0 304 Not Modified  </p>
<br>

<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h3 id="FTP：文件传输协议"><a href="#FTP：文件传输协议" class="headerlink" title="FTP：文件传输协议"></a>FTP：文件传输协议</h3><p>向远程主机上传输文件或从远程主机接收文件<br>客户/服务器模式  </p>
<ul>
<li>客户端：发起传输的一方  </li>
<li>服务器：远程主机  </li>
</ul>
<p>FTP：RFC 959<br>FTP 服务器：端口号为 21  </p>
<h3 id="控制连接与数据连接分开"><a href="#控制连接与数据连接分开" class="headerlink" title="控制连接与数据连接分开"></a>控制连接与数据连接分开</h3><p>FTP 客户端与 FTP 服务器通过端口 21 联系，并使用 TCP 为传输协议<br>客户端通过控制连接获得身份确认<br>客户端通过控制连接非让送命令浏览远程目录<br>收到一个文件传输命令时，服务器打开一个到客户端的数据连接<br>一个文件传输完成后，服务器关闭连接  </p>
<p><img src="/2022/03/23/computernetworknotes2/FTPconnect.png">  </p>
<p>服务器打开第二个 TCP 数据连接用来传输另一个文件<br>控制连接：带外 (out of band) 传送<br>FTP 服务器维护用户的状态信息：当前路径、用户账户与控制连接对应 (<strong>有状态</strong>)  </p>
<h3 id="FTP-命令、响应"><a href="#FTP-命令、响应" class="headerlink" title="FTP 命令、响应"></a>FTP 命令、响应</h3><p>命令样例：  </p>
<ul>
<li>在控制连接上以 ASCII 文本方式传送  </li>
<li>USER username  </li>
<li>PASS password  </li>
<li>LIST：请服务器返回远程主机当前目录的文件列表  </li>
<li>RETR filename：从远程主机的当年目录检索文件 (gets)，下载  </li>
<li>STOR filename：向远程主机的当前目录存放文件 (puts)，上载  </li>
</ul>
<p><em>上和下的概念以客户端为准</em></p>
<p>返回码样例：  </p>
<ul>
<li>状态码和状态信息 (同 HTTP)  </li>
<li>331 username OK, password required  </li>
<li>125 data connection already open; transfer starting  </li>
<li>425 Can’t open data connection  </li>
<li>452 Error writing file  </li>
</ul>
<br>

<h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>三个主要组成部分：  </p>
<ul>
<li>用户代理  </li>
<li>邮件服务器  </li>
<li>简单邮件传输协议：SMTP  </li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/email.png">  </p>
<h4 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h4><p>又名邮件阅读器<br>撰写、编辑和阅读邮件<br>如 outlook、foxmail<br>输出和输入邮件保存在服务器上  </p>
<h4 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h4><p>邮箱中管理和维护发送给用户的邮件<br>输出报文队列保持待发送邮件报文<br>邮件服务器之间的 SMTP 协议：发送 email 报文  </p>
<ul>
<li>客户：发送方邮件服务器  </li>
<li>服务器：接收方邮件服务器  </li>
</ul>
<h4 id="SMTP-RFC-2821"><a href="#SMTP-RFC-2821" class="headerlink" title="SMTP [RFC 2821]"></a>SMTP [RFC 2821]</h4><p>使用 TCP 在客户端和服务器之间传送报文，端口号为 25<br>直接传输：从发送方服务器到接收方服务器<br>传输的三个阶段  </p>
<ul>
<li>握手  </li>
<li>传输报文  </li>
<li>关闭  </li>
</ul>
<p>命令/响应交互  </p>
<ul>
<li>命令：ASCII 文本  </li>
<li>响应：状态码和状态信息  </li>
</ul>
<p>报文必须为 7 位 ASCII 码：所有内容要在 ASCII 码范围之内  </p>
<p>SMTP 小结  </p>
<ul>
<li>使用持久连接  </li>
<li>要求报文 (首部和主题) 为 7 位 ASCII 编码  </li>
<li>SMTP 服务器使用 CRLF.CRLF 决定报文的尾部  </li>
</ul>
<p>与 HTTP 比较  </p>
<ul>
<li>HTTP：拉 (pull)  </li>
<li>SMTP：推 (push)  </li>
<li>二者都是 ASCII 形式的命令/响应交互、状态码  </li>
<li>HTTP：每个对象封装在各子的响应报文中  </li>
<li>SMTP：多个对象包含在一个报文中  </li>
</ul>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>SMTP：交换 email 报文的协议<br>RFC 822：文本报文的标准  </p>
<ul>
<li>首部行  <ul>
<li>To:  </li>
<li>From: </li>
<li>Subject:  </li>
</ul>
<em>与 SMTP 命令不同</em>  </li>
<li>主体  <ul>
<li>报文，只能是 ASCII 码字符  </li>
</ul>
</li>
</ul>
<p><strong>多媒体扩展</strong>  </p>
<ul>
<li>MIME：多媒体邮件扩展 (multimedia mail extension)，RFC 2045，2056  </li>
<li>在报文首部用额外的行申明 MIME 内容类型</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/MIME.png">  </p>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>SMTP：传送放到接收方的邮件服务器<br>邮件访问协议：从服务器访问邮件  </p>
<ul>
<li>POP<ul>
<li>邮局访问协议 (Post Office Protocol) [RFC 1939]  </li>
<li>用户身份确认 (代理&lt;–&gt;服务器) 并下载  </li>
</ul>
</li>
<li>IMAP  <ul>
<li>Internet 邮件访问协议 (Internet Mail Access Protocol) [RFC 1730]  </li>
<li>更多特性 (更复杂)  </li>
<li>在服务器上处理存储的报文  </li>
</ul>
</li>
<li>HTTP  <ul>
<li>Hotmail，Yahoo！Mail 等  </li>
<li>方便  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/EmailProtocol.png">  </p>
<p><em>前两跳是推，最后一跳是拉</em>  </p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>用户确认阶段  </p>
<ul>
<li>客户端命令：  <ul>
<li>user：申明用户名  </li>
<li>pass：口令  </li>
</ul>
<em>明文</em>  </li>
<li>服务器响应：  <ul>
<li>+OK</li>
<li>-ERR</li>
</ul>
</li>
</ul>
<p>事务处理阶段(客户端)：</p>
<ul>
<li>list：报文号列表  </li>
<li>retr：根据报文号检索报文  </li>
<li>dele：删除  </li>
<li>quit</li>
</ul>
<p>“<strong>下载并删除</strong>” 模式：如果改变客户机，不能阅读邮件<br>“<strong>下载并保留</strong>” 模式：不同客户机上为报文的拷贝<br>POP3 在会话中是无状态的，不支持远程维护，本地管理文件夹  </p>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP 服务器将每个报文与一个文件夹联系起来<br>允许用户用目录来组织报文<br>允许用户读取报文组件<br>IMAP 在会话过程中保留用户状态：用户名、报文 ID 与目录名之间映射<br>远程管理文件夹  </p>
<br>  

<h2 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS (Domain Name System)"></a>DNS (Domain Name System)</h2><h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><p>IP 地址主要用于标识主机、路由器，但不便于人类记忆和使用<br>人类用户提供要访问机器的“字符串”名称，由 DNS 负责转换成二进制的网络地址<br>DNS 主要提供域名和 IP 地址之间的转换<br>分层的命名，分布式的解析  </p>
<h3 id="DNS-总体思路"><a href="#DNS-总体思路" class="headerlink" title="DNS 总体思路"></a>DNS 总体思路</h3><p>分层的、基于域的命名机制<br>若干分布式的数据库完成名字到 IP 地址的转换<br>运行在 UDP 之上端口号为 53 的应用服务<br>核心的 Internet 功能，但以应用层协议实现：在网络边缘处理复杂性  </p>
<h3 id="DNS-主要目的"><a href="#DNS-主要目的" class="headerlink" title="DNS 主要目的"></a>DNS 主要目的</h3><p>实现主机名 - IP 地址的转换 (name/IP translate)<br>主机别名 (便于用户访问) 到规范名字 (便于管理) 的转换：Host aliasing<br>邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing<br>负载均衡：Load Distribution  </p>
<h3 id="DNS-域名结构"><a href="#DNS-域名结构" class="headerlink" title="DNS 域名结构"></a>DNS 域名结构</h3><p>一个层次命名设备会有很多重名<br>DNS 采用层次树状结构的命名方法<br>Internet 被划分为几百个顶级域 (top level domains)  </p>
<ul>
<li>通用的 (generic)<br>.com, .edu, .gov, .int, .mil, .net, .org, .firm, .hsop, .web, .arts, .rec  </li>
<li>国家的 (countries)<br>.cn, .us, .nl, .jp  </li>
</ul>
<p>每个(子)域下面可划分为若干子域 (subdomains)<br>树叶是主机  </p>
<h3 id="DNS-名字空间-The-DNS-Name-Space"><a href="#DNS-名字空间-The-DNS-Name-Space" class="headerlink" title="DNS 名字空间 (The DNS Name Space)"></a>DNS 名字空间 (The DNS Name Space)</h3><p><strong>域名</strong>  </p>
<ul>
<li>从本域往上，直到树根  </li>
<li>中间使用 “.” 间隔不同级别  </li>
<li>域的域名：可以用于表示一个域  </li>
<li>主机的域名：一个域上的一个主机  </li>
</ul>
<p><strong>域名的管理</strong>  </p>
<ul>
<li>一个域管理其下的子域  </li>
<li>创建一个新的域，必须征得它所属的域的同意  </li>
</ul>
<p><strong>域域物理网络无关</strong>  </p>
<ul>
<li>域遵从组织界限，而不是物理网络  <ul>
<li>一个域的主机可以不在一个网络  </li>
<li>一个网络的主机不一定在一个域  </li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的  </li>
</ul>
<h3 id="名字服务器-Name-Server"><a href="#名字服务器-Name-Server" class="headerlink" title="名字服务器 (Name Server)"></a>名字服务器 (Name Server)</h3><p><strong>一个名字服务器的问题</strong>  </p>
<ul>
<li>可靠性：单点故障  </li>
<li>扩展性：通信容量  </li>
<li>维护：远距离的集中式数据库  </li>
</ul>
<p><strong>区域</strong> <strong>(zone)</strong>  </p>
<ul>
<li>区域的划分由区域管理者决定  </li>
<li>将 DNS 名字空间划为互不相交的区域，每个区域都是树的一部分  </li>
<li>名字服务器<ul>
<li>每个区域有一个名字服务器，维护者它所管辖区域的权威信息 (authoritative record)  </li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
</ul>
<h4 id="权威-DNS-服务器"><a href="#权威-DNS-服务器" class="headerlink" title="权威 DNS 服务器"></a>权威 DNS 服务器</h4><p>组织机构的 DNS 服务器<br>提供组织机构服务器 (如 Web 和 Mail) 可访问的主机和 IP 之间的映射<br>组织机构可以选择自己维护或由某个服务提供商来维护  </p>
<h4 id="TLD-服务器"><a href="#TLD-服务器" class="headerlink" title="TLD 服务器"></a>TLD 服务器</h4><p>顶级域 (TLD) 服务器<br>负责顶级域名 (如com, org, net,edu 和 gov) 和所有国家级的顶级域名 (如 cn, uk, fr, ca, jp, de 等)  </p>
<ul>
<li>Network solutions 公司维护 com 服务器</li>
<li>Educause 公司维护 edu TLD 服务器  </li>
</ul>
<h3 id="区域名字服务器维护资源记录"><a href="#区域名字服务器维护资源记录" class="headerlink" title="区域名字服务器维护资源记录"></a>区域名字服务器维护资源记录</h3><p><strong>资源记录</strong> (resource records)  </p>
<ul>
<li>作用：维护域名 - IP 地址(其它)的映射关系  </li>
<li>位置：Name Server 的分布式数据库中  </li>
</ul>
<p><strong>RR 格式</strong>：domain_name, ttl, type, class, Value  </p>
<ul>
<li>Domain_name：域名  </li>
<li>ttl：time to live，生存时间 (权威：长期；缓冲记录：短期，一般为两天)  </li>
<li>class：类别，对于 Internet 值为 IN  </li>
<li>Value：值，可以是数字、域名或 ASCII 串  </li>
<li>Type 类别：资源记录的类型</li>
</ul>
<h3 id="DNS-记录"><a href="#DNS-记录" class="headerlink" title="DNS 记录"></a>DNS 记录</h3><p><strong>DNS</strong>：保存资源记录 (RR) 的分布式数据库<br><strong>RR 格式</strong>：(name, value, type, ttl)<br><strong>Type</strong>  </p>
<ul>
<li>Type = A  <ul>
<li>Name 为主机  </li>
<li>Value 为 IP 地址  </li>
</ul>
</li>
<li>Type = CNAME  <ul>
<li>Name 为规范名字的别名  </li>
<li>Value 为规范名字</li>
</ul>
</li>
<li>Type = NS  <ul>
<li>Name 为子域名 (如 foo.com)  </li>
<li>Value 为该子域名的权威服务器的域名  </li>
</ul>
</li>
<li>Type = MX  <ul>
<li>Value 为 name 对应的邮件服务器的名字</li>
</ul>
</li>
</ul>
<p><strong>TTL</strong>：生存时间，决定了资源记录应当从缓存中删除的时间  </p>
<h3 id="DNS-大致工作过程"><a href="#DNS-大致工作过程" class="headerlink" title="DNS 大致工作过程"></a>DNS 大致工作过程</h3><p>应用调用：解析器 (resolver)<br>解析器作为客户，向 Name Server 发出查询报文 (封装在 UDP 段中)<br>Name Server 返回响应报文 (name/ip)  </p>
<p><img src="/2022/03/23/computernetworknotes2/DNSworkflow.png">  </p>
<h3 id="本地名字服务器-Local-Name-Server"><a href="#本地名字服务器-Local-Name-Server" class="headerlink" title="本地名字服务器 (Local Name Server)"></a>本地名字服务器 (Local Name Server)</h3><p>并不严格属于层次结构<br>每个 ISP (居民区的 ISP、公司、大学) 都有一个本地 DNS 服务器，也称为默认名字服务器<br>当一个主机发起一个 DNS 查询时，查询被送到其本地 DNS 服务器：起着代理的作用，将查询转发到层次结构中  </p>
<h4 id="名字解析过程"><a href="#名字解析过程" class="headerlink" title="名字解析过程"></a>名字解析过程</h4><p>目标名字在 Local Name Server 中  </p>
<ul>
<li>查询名字在该区域内部  </li>
<li>缓存 (cashing)  </li>
</ul>
<p>缓存为了性能，删除为了一致性  </p>
<p>当本地名字服务器不能解析名字时，联系根名字服务器，顺着根 - TLD 一直找到权威名字服务器  </p>
<ul>
<li><strong>递归查询</strong>  <ul>
<li>名字解析负担都放在当前联络的名字服务器上  </li>
<li>问题：根服务器的负担太重  </li>
<li>解决：迭代查询 (iterated queries)  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/diguichaxun.png">  </p>
<ul>
<li><strong>迭代查询</strong>  <ul>
<li>根 (及各级域名) 服务器返回的不是查询结果，而是下一个 NS 的地址  </li>
<li>最后由权威名字服务器给出解析结果  </li>
<li>当前联络的服务器给出可以联系的服务器的名字  </li>
<li>“我不知道这个名字，但可以向这个服务器请求”  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/diedaichaxun.png">  </p>
<h3 id="DNS-协议、报文"><a href="#DNS-协议、报文" class="headerlink" title="DNS 协议、报文"></a>DNS 协议、报文</h3><p>DNS 协议：查询和响应报文的报文格式相同  </p>
<p><img src="/2022/03/23/computernetworknotes2/DNSbaowen.png" alt="DNS 报文格式">  </p>
<p><strong>报文首部</strong>  </p>
<ul>
<li>标识符 (ID)：16 位；实现流水线查询  </li>
<li>flags<ul>
<li>查询/应答</li>
<li>希望递归</li>
<li>递归可用</li>
<li>应答为权威</li>
</ul>
</li>
</ul>
<h3 id="提高性能：缓存"><a href="#提高性能：缓存" class="headerlink" title="提高性能：缓存"></a>提高性能：缓存</h3><p>一旦名字服务器学到一个映射，就将该映射<strong>缓存</strong>起来<br>跟服务器通常都在本地服务器中缓存着，使得根服务器不用经常被访问<br>目的：提高效率<br>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致<br>解决方案：TTL，默认 2 天  </p>
<h3 id="维护问题：新增一个域"><a href="#维护问题：新增一个域" class="headerlink" title="维护问题：新增一个域"></a>维护问题：新增一个域</h3><p>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址<br>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析：名字 -&gt; 地址  </p>
<h3 id="攻击-DNS"><a href="#攻击-DNS" class="headerlink" title="攻击 DNS"></a>攻击 DNS</h3><p>总体而言，DNS 比较健壮  </p>
<h4 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h4><p>对根服务器进行流量轰炸攻击：发送大量 ping  </p>
<ul>
<li>没有成功  </li>
<li>原因 1：根目录服务器配置了流量过滤器，防火墙  </li>
<li>原因 2：Local DNS 服务器缓存了 TLD 服务器的 IP 地址，因此无需查询根服务器  </li>
</ul>
<p>向 TLD 服务器流量轰炸攻击：发送大量查询  </p>
<ul>
<li>可能更危险  </li>
<li>效果一般，大部分 DNS 缓存了 TLD  </li>
</ul>
<h4 id="重定向攻击"><a href="#重定向攻击" class="headerlink" title="重定向攻击"></a>重定向攻击</h4><p>中间人攻击：结果查询，伪造回答，从而攻击某个 (DNS 回答指定的 IP) 站点<br>DNS 中毒：发送伪造的应答给 DNS 服务器，希望它能够缓存这个虚假的结果<br>技术上较困难：分布式截获和伪造利用 DNS 基础设施进行 DDoS<br>伪造某个 IP 进行查询，攻击这个目标 IP<br>查询放大，响应报文比查询报文大<br>效果有限  </p>
<br>  

<h2 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h2><h3 id="纯-P2P-架构"><a href="#纯-P2P-架构" class="headerlink" title="纯 P2P 架构"></a>纯 P2P 架构</h3><p>没有(或极少)一直运行的服务器<br>任意端系统都可以直接通信<br>利用 Peer 的服务能力<br>Peer 节点间歇上网，每次 IP 地址都有可能变化  </p>
<p>例子：</p>
<ul>
<li>文件分发 (BitTorrent)  </li>
<li>流媒体 (KanKan)  </li>
<li>VoIP (Skype)  </li>
</ul>
<h4 id="文件分发：C-S-vs-P2P"><a href="#文件分发：C-S-vs-P2P" class="headerlink" title="文件分发：C/S vs P2P"></a>文件分发：C/S vs P2P</h4><p>Peer 节点上下载能力是有限的<br><strong>C/S 模式</strong>  </p>
<ul>
<li><strong>服务器传输</strong>：都是由服务器发送给 Peer，服务器必须顺序传输 (上载) N 个文件拷贝<ul>
<li>发送一个 copy：F/u<sub>s</sub>  </li>
<li>发送 N 个 copy：NF/u<sub>s</sub>  </li>
</ul>
</li>
<li><strong>客户端</strong>：每个客户端必须下载一个文件拷贝  <ul>
<li>d<sub>min</sub>：客户端最小的下载速率  </li>
<li>下载带宽最小的客户端下载的时间：F/d<sub>min</sub>  </li>
</ul>
</li>
</ul>
<p>采用 C-S 方法将一个 F 大小的文件分发给 N 个客户端耗时 D<sub>c-s</sub> ≥ max<br>{NF/u<sub>s</sub>, F/d<sub>min</sub>}  </p>
<ul>
<li>随着客户端的数目 N 越多，时间越长 (线性增加)  </li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/SCfile.png">  </p>
<p><strong>P2P 模式</strong>  </p>
<ul>
<li><strong>服务器传输</strong>：最少需要上载一份拷贝<ul>
<li>发送一个拷贝的时间：F/u<sub>s</sub>  </li>
</ul>
</li>
<li><strong>客户端</strong>：每个客户端必须下载一个拷贝  <ul>
<li>最小下载带宽客户单耗时：F/d<sub>min</sub>  </li>
</ul>
</li>
<li><strong>客户端</strong>：所有客户端总体下载量 NF  <ul>
<li>最大上载带宽是 u<sub>s</sub> + Σu<sub>i</sub>  </li>
<li>除了服务器可以上载，其它所有的 Peer 节点都可以上载  </li>
</ul>
</li>
</ul>
<p>采用 P2P 方法将一个 F 大小的文件分发给 N 个客户端耗时：D<sub>P2P</sub> ≥ max<br>{F/u<sub>s</sub>, F/d<sub>min</sub>, NF/(u<sub>s</sub> + Σu<sub>i</sub>)}  </p>
<ul>
<li>分子随着 N 线性变化，每个节点需要下载，整体下载量随着 N 增大  </li>
<li>分母也是如此，随着 peer 节点的增多，每个 peer 也带了服务能力  </li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/p2pfile.png">  </p>
<p>P2P 性能更好，可扩展性更强  </p>
<p><img src="/2022/03/23/computernetworknotes2/filevs.png" alt="Client-Server vs P2P 文件分发速度对比">  </p>
<h3 id="P2P-的管理模式"><a href="#P2P-的管理模式" class="headerlink" title="P2P 的管理模式"></a>P2P 的管理模式</h3><h4 id="P2P-文件共享的问题"><a href="#P2P-文件共享的问题" class="headerlink" title="P2P 文件共享的问题"></a>P2P 文件共享的问题</h4><p><strong>问题</strong>：</p>
<ul>
<li>如何定位所需资源  </li>
<li>如何处理对等方的加入与离开  </li>
</ul>
<p><strong>可能的方案</strong>：</p>
<ul>
<li>集中  </li>
<li>分散  </li>
<li>半分散  </li>
</ul>
<h4 id="非结构化-P2P"><a href="#非结构化-P2P" class="headerlink" title="非结构化 P2P"></a>非结构化 P2P</h4><p>节点与节点之间是任意构建起来的 overlay  </p>
<p><strong>集中式目录</strong>  </p>
<ul>
<li>当对等方连接时，告诉中心服务器：IP 地址、内容；peer A 可查询资源；peer A 从 peer B 处请求文件；下线时告诉中心服务器  </li>
<li>存在的问题：文件传输是分散的，而定位内容则是高度集中的；单点故障，如中心服务器出现问题；性能瓶颈；侵犯版权  </li>
</ul>
<p><strong>完全分布式</strong>  </p>
<ul>
<li>没有中心服务器  </li>
<li>全开放文件共享协议  </li>
<li>查询泛洪：Gnutella；许多 Gnutella 客户端实现了 Gnutella 协议，类似 HTTP 有许多的浏览器  </li>
<li>覆盖网络：图  <ul>
<li>如果 X 和 Y 之间有一个 TCP 连接，则二者之间存在一条边  </li>
<li>所有活动的对等方和边就是覆盖网络  </li>
<li>边并不是物理链路  </li>
<li>给定一个对等方，通常所连接的节点少于 10 个  </li>
</ul>
</li>
<li>Gnutella 协议  <ul>
<li>在已有的 TCP 连接上发送查询报文  </li>
<li>对等方转发查询报文  </li>
<li>以反方向返回查询命中报文  </li>
</ul>
</li>
<li>可扩展性  <ul>
<li>限制范围的泛洪查询  </li>
<li>设置 ttl  </li>
<li>让中转节点记忆查询，下次返回不再发送查询  </li>
</ul>
</li>
<li>对等方加入(Gnutella)  <ul>
<li>对等方 X 必须首先发现某些已经在覆盖网络中的其它对等方：使用可用对等方列表；自己维持一张对等方列表(经常开机的对等放的 IP)；联系维持列表的 Gnutella 站点  </li>
<li>X 接着试图与该列表上的对等方建立 TCP 连接，直到与某个对等方 Y 建立连接  </li>
<li>X 向 Y 发送一个 Ping 报文，Y 转发该 Ping 报文  </li>
<li>所有收到 Ping 报文的对等方以 Pong 报文响应：IP 地址、共享文件的数量及总字节数  </li>
<li>X 收到许多 Pong 报文，然后它能建立其它 TCP 连接  </li>
</ul>
</li>
</ul>
<p><strong>混合体</strong>：利用不匀称性 (KaZaA)  </p>
<ul>
<li>每个对等方要么是一个组长，要么隶属于一个组长  <ul>
<li>对等方与其组长之间有 TCP 连接  </li>
<li>组长对之间有 TCP 连接  </li>
</ul>
</li>
<li>组长跟踪器所有的孩子的内容  </li>
<li>组长与其他组长联系  <ul>
<li>转发查询到其他组长  </li>
<li>获得其他组长的数据拷贝  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/Kazaa.png" alt="混合体连接示例"></p>
<ul>
<li>KaZaA：查询<ul>
<li>每个文件有一个散列标识码和一个描述符  </li>
<li>客户端向其组长发送关键字查询  </li>
<li>组长用匹配进行响应：对每个匹配元数据、散列标识码和 IP 地址  </li>
<li>如果组长将查询转发给其他组长，其他组长也以匹配进行响应  </li>
<li>客户端选择要下载的文件：向拥有文件的对等方发送一个带散列标识码的 HTTP 请求  </li>
</ul>
</li>
</ul>
<p><strong>BitTorrent</strong>  </p>
<ul>
<li>文件被分为一个个块 256 KB；每个节点都有一张 Bit map；节点之间定期交互  </li>
<li>网络中的这些 peers 发送接收文件块，相互服务  </li>
<li>tracker：跟踪 torrent 中参与节点  </li>
<li>Torrent (洪流)：节点的组，之间交换文件块  </li>
<li>Peer 加入 torrent  <ul>
<li>一开始没有块，但是将会通过其他节点处累积文件块  </li>
<li>向跟踪服务器注册，获得 peer 节点列表，和部分 peer 节点构成邻居关系 (“<br>连接”)  </li>
</ul>
</li>
<li>当 peer 下载时，该 peer 可以同时向其他节点提供上线服务  </li>
<li>peer 可能会变换用于交换的块的 peer 节点  </li>
<li>扰动 churn：peer 节点可能会上线或者下线，整个洪流具有动态性  </li>
<li>一旦一个 peer 拥有整个文件，他会 (自私的) 离开或者保留 (利他主义) 在 torrent 中  </li>
<li>请求块  <ul>
<li>在任何给定时间，不同 peer 节点拥有一个文件块的子集  </li>
<li>周期性的，某节点向邻居询问他们用有哪些块的信息  </li>
<li>某节点向 peer 节点请求它希望的块、稀缺的块  </li>
</ul>
</li>
<li>发送块：一报还一报 tit-for-tat  <ul>
<li>某节点向 4 个 peer 发送块，这些块向它自己提供最大带宽的服务：其他 peer 被该节点阻塞，将不会从这一节点获得服务；每 10 秒重新评估一次 (前 4 位)  </li>
<li>每 30 秒随机选择其它 peer 节点，向这个节点发送块：“优化疏通”这个节点；新选择的节点可以加入这个 top 4  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/titfortat.png">  </p>
<h4 id="DHT-结构化-P2P"><a href="#DHT-结构化-P2P" class="headerlink" title="DHT (结构化) P2P"></a>DHT (结构化) P2P</h4><p>peer 节点之间构成环、树等关系的有序拓扑 overlay<br><strong>DHT</strong>: Distributed Hash Table<br>节点 IP 和文件都有一个唯一 Hash 值用以标识<br>内容存在哪个节点是约定好的，副本数量不需要很多就可以很快地找到目标内容  </p>
<br>  

<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h3 id="视频流化服务和-CDN：上下文"><a href="#视频流化服务和-CDN：上下文" class="headerlink" title="视频流化服务和 CDN：上下文"></a>视频流化服务和 CDN：上下文</h3><p>视频流量占据互联网大部分带宽<br>挑战  </p>
<ul>
<li>规模性：如何服务着 ~ 1 B 用户；单个超级服务器无法提供服务  </li>
<li>异构性：不同用户拥有不同的能力；如有线接入和移动用户、带宽丰富和受限用户  </li>
</ul>
<p><strong>解决方案</strong>：分布式的、应用层面的基础设施  </p>
<h3 id="多媒体：视频"><a href="#多媒体：视频" class="headerlink" title="多媒体：视频"></a>多媒体：视频</h3><p><strong>视频</strong>：固定速率显示的图像序列<br>网络视频特点：  </p>
<ul>
<li>高码率：&gt; 10 x 于音频，搞得网络带宽需求  </li>
<li>可以被压缩  </li>
<li>90 % 以上的网络流量是视频  </li>
</ul>
<p><strong>数字化图像</strong>：像素的阵列，每个像素被若干 bits 标识<br><strong>编码</strong>：使用图像内和图像间的荣誉来降低编码的比特数  </p>
<ul>
<li>空间冗余 (图像内)  <ul>
<li>如一张图中某颜色大面积重复，不是发送 N 个相同的颜色值，仅仅发送 2 个值：颜色和重复的个数 N  </li>
</ul>
</li>
<li>时间冗余 (相邻的图像间)  <ul>
<li>如不是发送第 i+1 帧的全部编码，而仅发送和第 i 帧差别的地方  </li>
</ul>
</li>
<li>CBR (Constant Bit Rate)：以固定速率编码  </li>
<li>VBR (Variable Bit Rate)：视频编码速率随时间的变化而变化  </li>
</ul>
<h3 id="多媒体流化服务：DASH"><a href="#多媒体流化服务：DASH" class="headerlink" title="多媒体流化服务：DASH"></a>多媒体流化服务：DASH</h3><p><strong>DASH</strong>: Dynamic, Adaptive Streaming over HTTP<br><strong>服务器</strong>  </p>
<ul>
<li>将视频分割成多个块  </li>
<li>每个块独立存储，编码于不同码率 (8 ~ 10 种)  </li>
<li>*告示文件 (manifest file)*：提供不同块的 URL  </li>
</ul>
<p><strong>客户端</strong>  </p>
<ul>
<li>先获取告示文件  </li>
<li>周期性地测量服务器到客户端的带宽  </li>
<li>查询告示文件，在一个时刻请求一个块，HTTP 头部指定字节范围  <ul>
<li>如果带宽足够，选择最大码率的视频块  </li>
<li>会话中的不同时刻，可以切换请求不同的编码块，取决于当时的可用带宽  </li>
</ul>
</li>
</ul>
<p><strong>智能</strong>客户端：客户端自适应决定  </p>
<ul>
<li>什么时候去请求块：不至于缓存挨饿或溢出  </li>
<li>请求什么编码速率的视频块：档带宽够用时，请求高质量的视频块  </li>
<li>那里去请求块：可以向离自己近的服务器发送 URL，或者向高可用带宽的服务器请求  </li>
</ul>
<h3 id="Content-Distribution-Networks"><a href="#Content-Distribution-Networks" class="headerlink" title="Content Distribution Networks"></a>Content Distribution Networks</h3><p><strong>挑战</strong>：服务器如何通过网络向上百万用户同时流化视频内容(上百万视频内容)？  </p>
<h4 id="单个的、大的超级服务中心：mega-server"><a href="#单个的、大的超级服务中心：mega-server" class="headerlink" title="单个的、大的超级服务中心：mega-server"></a>单个的、大的超级服务中心：mega-server</h4><p>服务器到客户端路径上跳数过多，瓶颈链路的带宽小导致停顿<br>“二八定律”决定了网络同时充斥着同一个视频的多个拷贝，效率低、付费高、带宽浪费、效果差<br>单点故障，性能瓶颈<br>周边网络的拥塞会造成影响<br><strong>评述</strong>：实现相当简单，但这个方法不可扩展  </p>
<h4 id="CDN-1"><a href="#CDN-1" class="headerlink" title="CDN"></a>CDN</h4><p>通过 <strong>CDN</strong>，全网部署缓存节点，存储服务内容，就近位用户提供服务，提高用户体验  </p>
<p><em>enter deep</em>：将 CDN 服务器深入到许多接入网  </p>
<ul>
<li>更接近用户，服务器数量多，离用户近，但管理困难  </li>
<li>Akamai，1700 个位置  </li>
</ul>
<p><em>bring home</em>：部署在少数 (10 个左右) <strong>关键位置</strong>，如将服务器簇安装于 POP 附近 (离若干 1st ISP POP 较近)  </p>
<ul>
<li>采用租用线路将服务器簇连接起来</li>
<li>跳数稍微多一些，服务器少  </li>
<li>Limelight  </li>
</ul>
<p>Content Distribution Networks (CDNs) 的<strong>应用过程</strong>：  </p>
<ul>
<li>部署：在 CDN 节点中存储内容的多个拷贝  </li>
<li>用户从 CDN 中请求内容：重定向到最近的拷贝，请求内容；如果网络路径拥塞，可能选择不同的拷贝  </li>
</ul>
<p><em>减少跳数、增加拷贝，让内容靠近用户，总体相当于加速服务</em>  </p>
<p><strong>over the top</strong><br>CDN 运行在应用层、网络边缘<br>互联网络主机-主机之间的通信作为一种服务向用户提供  </p>
<h4 id="OTT-挑战：在拥塞的互联网上复制内容"><a href="#OTT-挑战：在拥塞的互联网上复制内容" class="headerlink" title="OTT 挑战：在拥塞的互联网上复制内容"></a>OTT 挑战：在拥塞的互联网上复制内容</h4><p>？从哪个 CDN 节点中获取内容<br>？用户在网络拥塞时的行为<br>？在哪些 CDN 节点中存储什么内容 (内容、节点部署策略的问题)  </p>
<p><img src="/2022/03/23/computernetworknotes2/Netflix.png" alt="CDN 案例：Netflix"></p>
<br>

<h2 id="TCP-套接字编程"><a href="#TCP-套接字编程" class="headerlink" title="TCP 套接字编程"></a>TCP 套接字编程</h2><h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><p>应用进程使用传输层提供的服务才能交换报文，实现应用协议，实现应用<br>TCP/IP：应用进程使用 Socket API 访问传输服务<br>地点：界面上的 SAP(socket)<br>方式：Socket API<br>socket：分布式应用进程之间的门，传输层协议提供的端到端服务接口  </p>
<p><img src="/2022/03/23/computernetworknotes2/socket.png">  </p>
<p>2 种传输层服务的 socket 类型：  </p>
<ul>
<li>TCP：可靠的、字节流服务 (原原本本，不错不重复不丢失，保证按照流但不保证界限)  </li>
<li>UDP：不可靠 (数据 UDP 数据报) 服务  </li>
</ul>
<h3 id="TCP-套接字编程-1"><a href="#TCP-套接字编程-1" class="headerlink" title="TCP 套接字编程"></a>TCP 套接字编程</h3><p><strong>套接字</strong>：应用进程与端到端传输协议 (TCP 或 UDP) 之间的门户<br><strong>TCP 服务</strong>：从一个进程向另一个进程可靠地传输字节流<br><em>类似文件句柄</em>  </p>
<h4 id="TCP-连接建立流程"><a href="#TCP-连接建立流程" class="headerlink" title="TCP 连接建立流程"></a>TCP 连接建立流程</h4><p><strong>服务器首先运行，等待连接建立</strong>：  </p>
<ol>
<li>服务器进程必须先于运行状态  </li>
</ol>
<ul>
<li><strong>创建</strong>欢迎 socket  </li>
<li>和本地端口<strong>捆绑</strong>   </li>
<li>在欢迎 socket 上阻塞式<strong>等待接收</strong>用户的连接</li>
</ul>
<p>  <em>创建、捆绑、等待等都是 socket 函数</em>  </p>
<p><strong>客户端主动和服务器建立连接</strong>：  </p>
<ol>
<li><strong>创建</strong>客户端本地套接字 (<strong>隐式捆绑</strong>到本地 port)  </li>
</ol>
<ul>
<li>指定服务器进程的 IP 地址和端口号，与服务器进程<strong>连接</strong>  </li>
</ul>
<ol start="3">
<li>当与客户端连接请求到来时，服务器<strong>接受</strong>来自客户端的请求，解除阻塞式等待，返回一个新的 socket (与欢迎 socket 不一样)，与客户端通信  </li>
</ol>
<ul>
<li>允许服务器与多个客户端通信  </li>
<li>使用源 IP 和源端口来区分不同的客户端  </li>
</ul>
<ol start="4">
<li>连接 API 调用有效时，客户端 P 与服务器建立了 TCP 连接</li>
</ol>
<p><strong>从应用进程的角度</strong>：TCP 在客户端和服务器进程之间提供了可靠的、字节流 (管道) 服务  </p>
<h3 id="TCP-socket-编程-C-S-模式应用样例：大小写转换"><a href="#TCP-socket-编程-C-S-模式应用样例：大小写转换" class="headerlink" title="TCP socket 编程 C/S 模式应用样例：大小写转换"></a>TCP socket 编程 C/S 模式应用样例：大小写转换</h3><ol>
<li>客户端从标准输入装置读取一行字符，发送给服务器  </li>
<li>服务器从 socket 读取字符  </li>
<li>服务器将字符转换成大写，然后返回给客户端  </li>
<li>客户端从 socket 中读取一行字符，然后打印出来  </li>
</ol>
<p><img src="/2022/03/23/computernetworknotes2/CSTCPsocket.png">  </p>
<p>实际上，这描述了 C-S 之间交互的动作次序  </p>
<h4 id="数据结构-sockaddr-in"><a href="#数据结构-sockaddr-in" class="headerlink" title="数据结构 sockaddr_in"></a>数据结构 sockaddr_in</h4><p>IP 地址和 port 捆绑关系的数据结构 (标识进程的端节点)  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> sin_family; <span class="comment">//AF_INET</span></span><br><span class="line">  u_short sin_port; <span class="comment">//port  </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//IP address, unsigned long  </span></span><br><span class="line">  <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">//align</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/23/computernetworknotes2/sockaddr_in.png">  </p>
<h4 id="数据结构-hostent"><a href="#数据结构-hostent" class="headerlink" title="数据结构 hostent"></a>数据结构 hostent</h4><p>域名和 IP 地址的数据结构  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *h_name;</span><br><span class="line">  <span class="keyword">char</span> **h_aliases;</span><br><span class="line">  <span class="keyword">int</span> h_addrtype;</span><br><span class="line">  <span class="keyword">int</span> h_length; <span class="comment">//地址长度  </span></span><br><span class="line">  <span class="keyword">char</span> **h_addr_list;  </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/23/computernetworknotes2/host_ent.png">  </p>
<p>作为调用域名解析函数时的参数<br>返回后，将 IP 地址拷贝到 sockaddr_in 的 IP 地址部分  </p>
<h4 id="C-S-socket-交互：TCP"><a href="#C-S-socket-交互：TCP" class="headerlink" title="C/S socket 交互：TCP"></a>C/S socket 交互：TCP</h4><p><img src="/2022/03/23/computernetworknotes2/TCPjiaohu1.png">  </p>
<h4 id="例：客户端-TCP"><a href="#例：客户端-TCP" class="headerlink" title="例：客户端 TCP"></a>例：客户端 TCP</h4><p><img src="/2022/03/23/computernetworknotes2/clientTCP.png"><br><img src="/2022/03/23/computernetworknotes2/clientTCP2.png"></p>
<h4 id="例：服务器-TCP"><a href="#例：服务器-TCP" class="headerlink" title="例：服务器 TCP"></a>例：服务器 TCP</h4><p><img src="/2022/03/23/computernetworknotes2/serverTCP.png"><br><img src="/2022/03/23/computernetworknotes2/serverTCP2.png">  </p>
<br>  

<h2 id="UDP-套接字编程"><a href="#UDP-套接字编程" class="headerlink" title="UDP 套接字编程"></a>UDP 套接字编程</h2><h3 id="UDP-Socket-编程"><a href="#UDP-Socket-编程" class="headerlink" title="UDP Socket 编程"></a>UDP Socket 编程</h3><p>UDP：在客户端和服务器之间没有连接  </p>
<ul>
<li>没有握手  </li>
<li>发送端在每一个报文中明确指定目标的 IP 地址和端口号  </li>
<li>服务器必须从收到的分组中提取出发送端的 IP 地址和端口号  </li>
</ul>
<p>UDP 传送的数据可能乱序也可能丢失<br>进程视角看 UDP 服务：UDP 位客户端和服务器提供<strong>不可靠的</strong>字节组传送服务  </p>
<h3 id="Client-server-socket-交互：UDP"><a href="#Client-server-socket-交互：UDP" class="headerlink" title="Client/server socket 交互：UDP"></a>Client/server socket 交互：UDP</h3><p><img src="/2022/03/23/computernetworknotes2/UDPcs.png"></p>
<p><strong>C 客户端 UDP 代码</strong><br><img src="/2022/03/23/computernetworknotes2/UDPccode1.png" alt="C 客户端 UDP 代码样例">  </p>
<p><img src="/2022/03/23/computernetworknotes2/UDPccode2.png" alt="C 客户端 UDP 代码样例"></p>
<p><strong>C 服务器 UDP 代码</strong><br><img src="/2022/03/23/computernetworknotes2/UDPscode1.png" alt="C 服务器 UDP 代码">  </p>
<p><img src="/2022/03/23/computernetworknotes2/UDPscode2.png" alt="C 服务器 UDP 代码"></p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
</search>
