<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APS 总是能过的</title>
    <url>/2022/11/06/aps/</url>
    <content><![CDATA[<center> 按时间梳理一下这近一年来的 APS 经历，也算是分享一点经验。 </center>
<span id="more"></span>

<br>

<h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>考点：上海审核部<br>专业：生物信息学<br>审核语言：英语  </p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="了解阶段"><a href="#了解阶段" class="headerlink" title="了解阶段"></a>了解阶段</h3><p>年初寒假之前决定要搞 APS，但因为马上就要放假回家过年，所以这段时间，只干了两件事：一个是打印了 APS 官网下载下来的所需资料清单，准备返校后对着清单一个个准备；另一个是报名雅思，希望在 APS 之前有一个相对比较权威的英语成绩。不过英语成绩并不是 APS 的重点，没有也没关系。后面雅思不停取消导致实际上在今年十月才真正第一次成功考上都是后话了。<br>收假返校后，算是一个远离家庭问题又远离老板的安全区，又有些懈怠，甚至开始想是不是在这里继续读下去也可以。所以三月的时候只是在 APS 官网注册、填好所有信息、下载好注册档案，其它的材料犹犹豫豫一直没去。当时以为自己特别聪明，进可继续 APS，退可实验室混吃等死。但这一拖就遇上上海封城、我校封校等等一系列疫情管控，雅思取消取消再取消。不过也是这段日子让我意识到，不行动真的不行了，必须行动起来。  </p>
<h3 id="基本材料"><a href="#基本材料" class="headerlink" title="基本材料"></a>基本材料</h3><p>因为从小内向加社恐，或许还有一点点 ASD，导致很多事情如果没有见过别人做，就无法自己去做，这也是没能在刚返校就去跑材料的原因之一。而经历了一个学期的折磨之后，终于已经到了再不办就要放暑假的紧迫情况，还是很难真正跨出那一步。幸好当时一位朋友也多少感受到我很想让他陪我一起去跑材料，他也觉得如果以后要出国，现在把材料跑了比毕业后再回来方便得多，所以全程都是我们俩一起。<br>五月底六月初，在学校档案馆、教务处之间来回奔波，把成绩单、双证、录取证明等等都搞好中英文版本，并密封盖章。但没有在这个时候汇款寄材料，因为我拖延症又犯了，而且犹豫不知道究竟应不应该选择则换条路。再加上已经本科毕业，需要写简历表明毕业后去向，不知道怎么写。又遇上学校要求放假后所有人都回家，不想在暑假期间专程跑一趟上海面审，只好再次搁置继续 APS 计划。  </p>
<p>再次返校是八月初。根据之前的经验，刚返校的两周最适合干“杂事”，所以返校后火速开始准备简历。查过各种经验之后，意识到这个简历其实不重要，只要是一份表格式、简洁明了说明从本科到现在的学习、就业、实习等经历就好，在审核中也并非重点。大概用了两天时间，就完成简历部分。此时是 8.11。  </p>
<p>之后又经历了一番微微拖延，所有的书面材料都已经准备完毕，只差汇款。但当时又陷入“只要汇款，一切都无法挽回”的迷思之中，总觉得汇款就像后路全无、破釜沉舟。而且当时不懂汇款其实可以手机银行操作，根本不需要道柜台，一想到要自己去柜台和人交流就压力陡增。再加上看到官网说最好在汇款后两周内寄送材料，更加大了材料是否真的完备的焦虑。而后来的事实证明，我的材料并没有准备好，后面会详细说。总之，一直拖到 8.22 才去汇款。  </p>
<p>汇款之后一切都变得简单起来，两千五百块都已经交给审核部了，再怎么样都要面审一次！这次没有怎么拖延，反复检查所有材料之后，在 8.23 就寄往上海审核部。寄的顺丰，第二天下午就显示已签收。<br>顺便这段时间也终于决定不再等虚无缥缈的雅思笔考，转而报名了据说基本不会取消的机考。虽然不能在 APS 交材料时就给出雅思成绩，但至少能考上了。  </p>
<h3 id="第一次补材料"><a href="#第一次补材料" class="headerlink" title="第一次补材料"></a>第一次补材料</h3><p>当我以为一切顺利，可以等邮件通知去面审时，接到了上海审核部的电话 (8.24)。那边的老师问我为什么我的材料寄到了上海，根据出生地和家庭住址，应该是北京审区。我解释说因为还在上学，不在家里，在江浙沪，属于上海部审核区。老师又详细问我是在上什么学，为什么材料里没有体现。我说因为想审核的主要是本科成绩，研究生后面会退学或休学，出国也是读硕。老师严厉指出不应该隐瞒任何一段经历，即使后面要中断，现在在上学就应该在材料里体现出来。告诉我补交研究生的各种证明材料之后，上海审核部才会正式接收我的材料。我又道歉又道谢，第二天就火速去学校档案馆跑材料。<br>因为学校翻译各种证明需要时间，所以第一次补交材料在 9.2 号才寄出。没错，第一次补交。  </p>
<h3 id="第二次补材料"><a href="#第二次补材料" class="headerlink" title="第二次补材料"></a>第二次补材料</h3><p>9.7 接到电话询问是否要完成博士学业，如果完成则可以只审核材料，走博士审核流程。回答要中断，确定走一般申请人流程。  </p>
<p>9.9 又接到电话，研究生阶段成绩单只有最初一年半，后面没有成绩需要写一个无课声明。挂掉电话打开邮箱才发现，审核部发了邮件给我，提醒登录官网查询消息 (<strong>此处提醒，邮件通知一定要打开，没事就去官网看看有没有新消息</strong>)。官网的消息就是无课说明的详细要求，而且这个时候审核号已出。现在回想不太记得是这时才发现审核号已出，还是之前想看看进度登录官网时发现已经有审核号了。<br>当天写完无课说明，提交到指定邮箱。  </p>
<h3 id="预约面审"><a href="#预约面审" class="headerlink" title="预约面审"></a>预约面审</h3><p>这次补交材料之后没多久就收到审核部发来的材料已经审核完毕，可以发邮件预约面审时间的提醒 (9.13)。考虑到雅思考试是在 9 月底，想着给自己留一个月的缓冲时间，就把面审时间定在了 10 月的最后一周， 10.24 ~ 10.30 周。审核部预约面审只能约周，而不能具体到哪一天。<br>9.17 发出预约邮件，9.19 收到预约成功邮件。而且审核部邮件中再次强调无法保证按照申请者意愿安排考位，发邮件约上之后就放心大胆地投入到雅思之中。  </p>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="无-DDL-摆烂期"><a href="#无-DDL-摆烂期" class="headerlink" title="无 DDL 摆烂期"></a>无 DDL 摆烂期</h3><p>考完雅思、经历过一次组会汇报之后的 10.10 周，终于开始准备 APS 的内容，此时仍然没有收到具体的面审时间。因为总觉得在预约周成功面审这种好事不会发生在我身上，复习得也很随意。<br>第一天，只是对着英文成绩单圈出我认为比较重要的课程(6 门课、毕设、企业实习项目、参与的训练项目)。经历过面审之后发现考官认为的重点课程和我认为的有些许偏差，考官在我成绩单上画出的大多是 90+ 的课程和专业课。所以这一步中选择重点课程一定要注意课程名字一看就与专业相关和成绩在 90 分以上的科目。<br>第二天，把专业基础课 (生物信息学) 的 PPT 全部过了一边，并用英语总结了一页“作弊纸”。这是之前考试周发现的高效复习法，把内容尽量提炼整理，能在一张 A4 纸上写完。第一遍背全部，第二遍更加精简这张纸上的内容。这个时候已经达到知识大框架和小细节都在心中，而且知道哪一部分重中之重。所以针对 APS，也用了这种方法。不过此时只是总结，还没有进入背的环节。另外，由于备考间不能使用电子设备，所以复习时建议直接<strong>纸笔</strong>复习，或者一定要记得把材料<strong>打印出来</strong>以便在备考间<del>打发时间</del>还能再看看。<br>第三天，把专业基础课相对应的实践课 (生物数据处理与实践) 的作弊纸总结完。<br>第四天…没有第四天，因为没有 DDL，我躺了，没有继续复习。<br>这一躺就是一周，尤其是 10.17 还没有收到邮件通知面审，更加放松警惕。即使看过有人面审前一周才收到通知的经验，仍然觉得肯定不会顺利在预约时间面审。  </p>
<h3 id="有-DDL-努力期"><a href="#有-DDL-努力期" class="headerlink" title="有 DDL 努力期"></a>有 DDL 努力期</h3><p>10.19 的中午紧张了一下，打开邮箱就看到有新消息提醒。当时就觉得完蛋，躺的报应来得如此之快，竟然要按照原有时间审核了！审核部给出的审核时间是我万万没想到的周五 (10.28)，明明官网上写着审核时间一般在周一、周二和周四，却在这个时候暗杀我一刀 —— 周五有组会，需要向导师请假。不过复习更重要，也没想太多如何请假。当天果断先定了德国中心旁边的住宿，然后火速开始按照计划复习，把所有的重点课程都总结为一页作弊纸。因为专业内容这几年一直在接触，怎么都能说上几句，所以全部总结完之后才开始背东西。  </p>
<p>第一轮复习主要工作就是总结作弊纸、背作弊纸。作弊纸上的内容包括课程的总体框架和细节内容，不建议画思维导图这种华而不实、没什么内容又浪费页面的东西。这个阶段一天一门重点课，具体就是看一遍能找到的该课程的所有 PPT 和当时的课堂笔记，总结一张英文的作弊纸并在当天背一遍。如果内容相对简单，就多看一门课。<br>总结总体框架主要分两种情况：<br><strong>课程本身就是一整套流程</strong>，那就根据流程总结这门课。比如生物数据处理与实践这门课，上课的时候就是理论知识加处理测序数据，所以大框架就是理论知识部分加实践流程。理论知识：R、Python 两个语言和 Linux 操作系统，以及生信实用软件介绍 (学的软件就是后面流程中实际要用的)。流程框架基本和 NGS 数据处理一致：<code>FastQC -&gt; Bowtie -&gt; Samtools -&gt; STAR &amp; DESeq2 -&gt; IGV -&gt; Cytoscape -&gt; MEGA</code>。<br><strong>课程本身没有很强的流程</strong>，可以根据老师每章节的 PPT 主题来定框架。比如生物数据挖掘这门课，就根据 PPT 内容整理出一个大框架：<code>data preprocessing -&gt; frequent pattern -&gt; cluster -&gt; classification and regression -&gt; deep learning (case-based)</code>。<br>大框架定好之后，每个步骤都记几个具体的方法名称和思路、一个比较详尽的算法和一个具体的例子。一轮复习尽可能多看一些东西，不要只随便总结一个大概。尤其是专业课，很可能在笔试中考到非常细节的东西。<br>背诵的要求不用太高，可以缩减一些内容，不需要每个细节都照顾到。但前提是真的已经看过一遍这门课的所有 PPT，心里有个底。这里我对自己的要求是能说出课程框架是什么，框架中每个步骤能讲一两个具体算法或例子，也是在为第二轮复习做精简。  </p>
<p>第二轮复习就是重点课程精简和非重点课程大概回忆，只需要一两天。<br>针对<strong>重点课程</strong>再次总结，用便签纸或一张 A4 纸的 1/6 默写 (默不下来就对着一轮作弊纸精简) 课程框架和重点步骤的一两个算法名字、大致思路。这次的语言要尽可能精简，只留关键词。后面再背东西时，这次的总结可以当作提示。如果对着这张纸想不起来怎么说，再去看第一遍总结的内容。<br><strong>非重点课程</strong>主要是查一查一些专业词汇用英语如何表达，大致写几个关键词作为回答。比如几何与代数这门课并非专业课，就只记录了学过 Basic algebraic structures (groups, vector, matrix, and fields)，linear algebra (linear system, basis and dimension, derterminants)，linear transformations。记录了一个例子是行列式求解。  </p>
<p>二轮结束后还可以有第三轮，只需要几个小时，最多一天的时间。找朋友帮忙指着<strong>英文成绩单</strong>上的课程问这门课讲过什么，模拟面审。或者自己看着<strong>英文成绩单</strong>，针对每门课都说一两句主要学了什么内容。当然我也没有每门课都复习，很多课只是稍微有个印象。而且我根本没有进行第三轮复习，因为当时太焦虑，脑子里只有早考早超生，不行就直接准备二审。还在 26 号晚上才知道面审中还会问家庭情况、为什么要去德国读书、有没有梦校一类仿佛雅思口试题的问题，所以从这个时候到面审前，完全没复习正经东西，反而在纠结这些乱七八糟的问题该怎么回答。  </p>
<h3 id="前往上海再次摆烂"><a href="#前往上海再次摆烂" class="headerlink" title="前往上海再次摆烂"></a>前往上海再次摆烂</h3><p>27 号下午出发去上海，一路上只在进站时查过健康码和核酸，到站后查了“随申办”绿码和外地 48 小时核酸。因为八九月时去过一次上海，没有当地核酸很麻烦，所以原本还预留出在上海本地找核酸的时间。到了上海之后发现，至少上海站是有落地核酸的，无需自己再去找地方做核酸，算是少一件麻烦事。<br>到达住处之后，放完行李就出门走了一边从住处到德国中心的路，为第二天应该几点出门计算时间。住的酒店是如家上海新国际博览中心张江高科地铁站店，和德国中心同在科苑路，步行前往德国中心只需要十分钟。不过后来听同一天面审的一个同学说他老师不推荐这家店，因为太潮了，住着不舒服，所以他住了稍远一些的如家。但当天他是唯一一个迟到的学生，其他四个住在这家店的都早早到达。住哪里就看个人选择了，住的远肯定要更早起，住的近要忍一忍潮。就我个人而言，也不算太潮，就是有蚊子，被我拍死在墙上。<br>当晚原本打算再看一遍一轮复习总结的内容或者二轮的关键词，但实际上完全看不进去该看的，反而在 b 站看游戏直播看得起劲，并在 11 点上床玩手机培养睡觉情绪。  </p>
<h2 id="面审过程"><a href="#面审过程" class="headerlink" title="面审过程"></a>面审过程</h2><h3 id="备考间"><a href="#备考间" class="headerlink" title="备考间"></a>备考间</h3><p>面审时间是 8:30，路程只需 10分钟，所以决定最晚八点出门，预留出迷路找不到审核部办公室的时间，定了 7:17 的闹钟。实际上因为窗帘没拉好，五点被亮醒一次，七点刚过就睡不着直接起床。起床后简单洗漱、随便吃了点东西，慢悠悠出门。<br>到达德国中心时，问了门口保安审核部是不是在 1 号楼，得到肯定回答。直接走向 1 号楼 619 室，也就是当初寄材料的地址。给地址这点审核部做得不够好，面审通知里只说了德国中心 619-620，没有提是几号楼。对我这种没有确切答案根本不敢动的人来说，找房间简直要命。最后到达审核部办公室门口大概是八点零几分，然后陆续有三个同学也到达。但审核部老师直到 8:28 才出现，完全没有理会我们门外的四个期待他至少说一句这里是审核部的小可怜，就直接进去准备东西。大概 8:32 时，老师出来让我们扫码之后进入备考间。  </p>
<p>进入备考间先是给大家一人发了一个快递单，填写审核证书的收件地址，包括审核号之类的信息。不记得审核号也不用担心，老师会依次念一遍所有人的审核号。然后会发一张面审要求，不能作弊等等的警告，要签上名字和拼音，在面审时交给考官。此时会要求大家把所有电子产品收起来，包括手机、平板，但可以留下纸质材料复习。以及强调保密面审内容，这张纸相当于保密协议，如果在互联网透露面审信息将会被收回证书。这些之后再依次被去录个照片就准备完毕，可以看自己的复习材料了。<br>备考间只有五个学生，一开始让我们签名、录照片的老师虽然就坐在旁边，但我们小声聊天互相鼓励也无人在意。当天的五个人五个专业，只能说都是理工科大类，具体谈专业就毫不相干。不过因为大家都很紧张，短时间内结下深厚的革命友谊，互相鼓励互相安慰，氛围很好。  </p>
<p>9:00 叫第一个人去笔试间。具体叫人顺序不明，一开始猜测是按照审核号，但第二个人被叫走就发现不是这样，估计是考官看心情。<br>9:30 左右第二个人笔试，第一位面审。因为这里原本是个大办公室，小房间都是隔出来的，所以隔音很差，隐约能听到隔壁面审的声音。如果想听能听到别人的内容，但需要非常专注听才能听清。而且大家专业不一样，没有太大参考价值。当天唯一一个迟到的同学坐在门口，估计听得更清楚，就一直在注意面审说了什么。我认为这样听非常不礼貌，但也没说什么。等候室的时间非常难熬，度秒如年，看资料也看不进去，你能感受到每个人都想早点面审了事。<br>9:50 第三个人笔试，第二个人面审。我和剩下的迟到同学猜谁会是最后一个，我们都认为是自己。<br>10:15 第四个人笔试，我是剩下的那一个。考官进来叫人说出 Mr 的那一刻我整个人都不太好，为什么我是最后一个！都十点了！但我也只能等。根据时间推测，我会在 10:35~10:40 被叫去笔试，但我真的不知道还能看点什么，只能考乱写东西平静心情。<br>10:35 还没有叫我就有点崩溃了，但幸好听到了上一位同学结束的声音。我听着面审同学结束，考官去笔试间叫人，就开始收拾东西。考官走进来叫我，一句 Mr 出口，我还没来得及纠正他，他就说不好意思搞错了，是 Miss。我笑着点点头说，是的，是 Miss。</p>
<h3 id="正式面审"><a href="#正式面审" class="headerlink" title="正式面审"></a>正式面审</h3><p>笔试题就是生物信息学那门课的内容，完全一致，丝毫没有超纲。而且都是很基础的问题，一些名词解释并要求给出例子。这时，我整个人已经放松了。而且笔试间有笔有纸有词典，甚至还慢悠悠查了一个不确定的单词怎么写。  </p>
<p>面审过程就是类似雅思口试题加课程问题。问了我为什么要去德国读书，有没有梦校。之前准备这里的问题时一直告诉自己这是英审不是德审，要说英语，结果脑子一抽 Munich 没说成 München，反而在 Berlin 的发音上翻车说的德语发音，还把考官逗笑了。而且这里因为太紧张，一直在不停讲，甚至考官都说可以了这里不是重点我们来问一问关于你学过的课程。<br>课程相关的问题也很简单，就是指着成绩单上的科目问这门课讲了什么，再根据回答进一步问一个问题。因为已经毕业，所以问了毕设的标题、具体内容和结果。问到一个专业课，并要求举一个例子。因为毕设刚好用过这门课的一个算法，就直接联动毕设回答这个问题。<br>前面闲聊问题中解释过会中断国内的研究生课程，我以为不会问研究生的内容，万万没想到还是被问了，完全没有准备过。不过幸好那门课和本科一门课很像，就简单解释了一下。接着被问到为什么生信需要这门课，就给了个例子。<br>还被问到一个本科的非专业课，又是没有复习。这种时候其实担心的根本不是内容想不起来，毕竟真的学过，而是想起来了不知道英语怎么讲。这门课刚好专业词汇又很需要，回答得很勉强。中间还沉默了一下，因为我以为说完不是专业课就不用继续说了，副考官提醒我继续再说点什么。<br>后面问到另一门课时他让我画一下细胞结构，我脑子一抽，狂画磷脂双分子层！考官：我从来没有见过这样画细胞的人！因为双分子层真的很难画，最后被考官制止，不要再继续补充细节了，口头表达一下就可以。后面还问我一个问题，我完全没答出来，而且脑子停滞到连解释一下是会中文，但不知道用英文怎么说都忘记了。  </p>
<h2 id="等待结果"><a href="#等待结果" class="headerlink" title="等待结果"></a>等待结果</h2><p>面审之后就没有任何需要做的事情了，只剩下等通知。据说快的话第二天下午就会出结果，考虑到我是周五面审，估计周一就能看结果。但因为面审过程中有问题没回答出来，完全没有勇气打开官网看结果。直到周三，突然要出门，在出门之前突然下定决心点开结果看一看。当时其实已经打开网页好久了，只差点登录。<br>鼠标点击一下之后，目光先落在了平时会显示消息通知的地方，新消息是 0，还以为结果没出。转了一下视线才发现原来结果就在屏幕中间，反复确认好几次写的是“恭喜您已经成功地通过了审核部的审核”。终于松了口气！APS 这道坎还是顺利迈过去了。  </p>
<p><img src="/2022/11/06/aps/APS.png">  </p>
<p>之后一切都很顺利。周四收到顺丰的消息，说有个北京的快递。周五就收到快递，拿到证书。  </p>
<h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><p>面审本身并不算难，问题也都是围绕课程内容展开的，理解考官在问什么并给出答案就好。一定要有自信，你是真的上过课学习了这些课程，但考官没有，相信自己给出的答案。如果考官不明白，就多解释几句。用简单句就可以，这是在告诉考官你学过这门课，而不是科研汇报。<br>不用提前很久准备，像我一样考前十天突击也不是不可以。但前提是对专业本身还算熟悉，有一套适合自己的复习流程和计划，且全程用英语复习。为了 APS 报班更是没必要也浪费钱，不如多看看 PPT。而且因为同时在准备雅思，一直有英语的听说读写。先考雅思再面审也让雅思口试变成了面审的经验 —— 考官会很努力让你懂他在问什么，就算真的没听懂，让考官多解释两句也无妨。<br>整个过程最难的不是面审本身，而是孤独，感觉一旦走上这条路就会逐渐远离熟悉的一切。而且从头到尾没有找同伴一起准备，也没有告诉家人，加深了孤军奋战的感觉。各地疫情防控也加大了复习过程中的焦虑，尤其是从收到面审通知到面审完回来这十天，一直都在担心突然被封控不能面审或面审完被封在上海，晚上做梦都是在虹桥机场流浪。所以如果能找到人一起复习、随时交流，应该对情绪改善有很大帮助。  </p>
]]></content>
      <categories>
        <category>runrunrun</category>
      </categories>
      <tags>
        <tag>APS</tag>
      </tags>
  </entry>
  <entry>
    <title>blastp的本地化使用</title>
    <url>/2021/09/16/blastp/</url>
    <content><![CDATA[<center>blastp在Windows系统电脑上的本地使用</center>
<span id="more"></span>

<br>

<h2 id="下载blast到本地"><a href="#下载blast到本地" class="headerlink" title="下载blast到本地"></a>下载blast到本地</h2><p>在NCBI官网找到blast工具即可找到下载链接，根据提示一步步完成下载即可。<br>官网下载链接：<a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web&PAGE_TYPE=BlastDocs&DOC_TYPE=Download">blast tools</a><br>网站打开速度较慢，挂梯可能会好一点。</p>
<h2 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h2><h3 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h3><p>从uniprot下载所需参考蛋白质组的fast.a文件作为建库文件此处以人类蛋白质组为例  </p>
<pre><code>$ makeblastdb -in uniprot-proteome%3AUP000005640.fasta -dbtype prot -parse_seqids -hash_index -out human
# 在blast-2.6.0/bin文件夹下运行该命令或在makeblastdb前加上该程序所在的路径

# 参数说明
# -in 所需建库的参考蛋白质组
# -out 输出的库名
# -dbtype 蛋白质组用prot，核酸组用nucl
# parse_seqids =&gt; Parse Seq-ids in FASTA input
# -hash_index =&gt; Create index of sequence hash values
</code></pre>
<h3 id="搜库比对"><a href="#搜库比对" class="headerlink" title="搜库比对"></a>搜库比对</h3><p>将query序列比对到参考序列。此处用小鼠蛋白质组和人蛋白质组进行比对，运行如下命令：</p>
<pre><code>$ blastp.exe -query uniprot-proteome%3AUP000000589.fasta -db human -evalue 1e-3 -out blast.xml -outfmt &quot;5&quot; -num_alignments 10 -num_threads 2
#在blast-2.6.0/bin文件夹下运行该命令或在blastp.exe前加上该程序所在的路径

# 参数说明
# -query 输入文件名，也就是需要比对的序列文件
# -db 格式化后的数据库名称
# -evalue 设定输出结果中的e-value阈值
# -out 输出文件名
# -num_alignments 输出比对上的序列的最大值条目数
# -num_threads 线程数
# 此外还有：
# -num_descriptions 对比对上序列的描述信息，一般跟tabular格式连用
# -outfmt
#   0 = pairwise,
#   1 = query-anchored showing identities,
#   2 = query-anchored no identities,
#   3 = flat query-anchored, show identities,
#   4 = flat query-anchored, no identities,
#   5 = XML Blast output,
#   6 = tabular,
#   7 = tabular with comment lines,
#   8 = Text ASN.1,
#   9 = Binary ASN.1
#  10 = Comma-separated values
</code></pre>
<h3 id="提取搜库结果中的信息"><a href="#提取搜库结果中的信息" class="headerlink" title="提取搜库结果中的信息"></a>提取搜库结果中的信息</h3><h2 id="xml文件所含的信息"><a href="#xml文件所含的信息" class="headerlink" title="xml文件所含的信息"></a>xml文件所含的信息</h2><p>使用outfmt 5参数的话，会产生一个xml格式的文件，对比信息很完整。一个序列的完整比对信息如下所示：</p>
<pre><code>&lt;Iteration&gt;
&lt;Iteration_iter-num&gt;1&lt;/Iteration_iter-num&gt;
&lt;Iteration_query-ID&gt;Query_1&lt;/Iteration_query-ID&gt;
&lt;Iteration_query-def&gt;sp|Q62302|TX261_MOUSE Protein TEX261 OS=Mus musculus OX=10090 GN=Tex261 PE=2 SV=1&lt;/Iteration_query-def&gt;
&lt;Iteration_query-len&gt;196&lt;/Iteration_query-len&gt;
&lt;Iteration_hits&gt;
&lt;Hit&gt;
&lt;Hit_num&gt;1&lt;/Hit_num&gt;
&lt;Hit_id&gt;sp|Q6UWH6|TX261_HUMAN&lt;/Hit_id&gt;
&lt;Hit_def&gt;Protein TEX261 OS=Homo sapiens OX=9606 GN=TEX261 PE=2 SV=1&lt;/Hit_def&gt;
&lt;Hit_accession&gt;Q6UWH6&lt;/Hit_accession&gt;
&lt;Hit_len&gt;196&lt;/Hit_len&gt;
&lt;Hit_hsps&gt;
  &lt;Hsp&gt;
    &lt;Hsp_num&gt;1&lt;/Hsp_num&gt;
    &lt;Hsp_bit-score&gt;391.734&lt;/Hsp_bit-score&gt;
    &lt;Hsp_score&gt;1005&lt;/Hsp_score&gt;
    &lt;Hsp_evalue&gt;8.09539e-141&lt;/Hsp_evalue&gt;
    &lt;Hsp_query-from&gt;1&lt;/Hsp_query-from&gt;
    &lt;Hsp_query-to&gt;196&lt;/Hsp_query-to&gt;
    &lt;Hsp_hit-from&gt;1&lt;/Hsp_hit-from&gt;
    &lt;Hsp_hit-to&gt;196&lt;/Hsp_hit-to&gt;
    &lt;Hsp_query-frame&gt;0&lt;/Hsp_query-frame&gt;
    &lt;Hsp_hit-frame&gt;0&lt;/Hsp_hit-frame&gt;
    &lt;Hsp_identity&gt;195&lt;/Hsp_identity&gt;
    &lt;Hsp_positive&gt;196&lt;/Hsp_positive&gt;
    &lt;Hsp_gaps&gt;0&lt;/Hsp_gaps&gt;
    &lt;Hsp_align-len&gt;196&lt;/Hsp_align-len&gt;
    &lt;Hsp_qseq&gt;MWFMYVLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPGDDVVSNYFTKGKRGKRLGILVVFSFIKEAILPSRQKIY&lt;/Hsp_qseq&gt;
    &lt;Hsp_hseq&gt;MWFMYLLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPGDDVVSNYFTKGKRGKRLGILVVFSFIKEAILPSRQKIY&lt;/Hsp_hseq&gt;
    &lt;Hsp_midline&gt;MWFMY+LSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPGDDVVSNYFTKGKRGKRLGILVVFSFIKEAILPSRQKIY&lt;/Hsp_midline&gt;
  &lt;/Hsp&gt;
&lt;/Hit_hsps&gt;
&lt;/Hit&gt;
&lt;Hit&gt;
&lt;Hit_num&gt;2&lt;/Hit_num&gt;
&lt;Hit_id&gt;tr|U3KQ87|U3KQ87_HUMAN&lt;/Hit_id&gt;
&lt;Hit_def&gt;Uncharacterized protein OS=Homo sapiens OX=9606 PE=4 SV=1&lt;/Hit_def&gt;
&lt;Hit_accession&gt;U3KQ87&lt;/Hit_accession&gt;
&lt;Hit_len&gt;197&lt;/Hit_len&gt;
&lt;Hit_hsps&gt;
  &lt;Hsp&gt;
    &lt;Hsp_num&gt;1&lt;/Hsp_num&gt;
    &lt;Hsp_bit-score&gt;312.768&lt;/Hsp_bit-score&gt;
    &lt;Hsp_score&gt;800&lt;/Hsp_score&gt;
    &lt;Hsp_evalue&gt;1.35723e-109&lt;/Hsp_evalue&gt;
    &lt;Hsp_query-from&gt;1&lt;/Hsp_query-from&gt;
    &lt;Hsp_query-to&gt;158&lt;/Hsp_query-to&gt;
    &lt;Hsp_hit-from&gt;1&lt;/Hsp_hit-from&gt;
    &lt;Hsp_hit-to&gt;158&lt;/Hsp_hit-to&gt;
    &lt;Hsp_query-frame&gt;0&lt;/Hsp_query-frame&gt;
    &lt;Hsp_hit-frame&gt;0&lt;/Hsp_hit-frame&gt;
    &lt;Hsp_identity&gt;157&lt;/Hsp_identity&gt;
    &lt;Hsp_positive&gt;158&lt;/Hsp_positive&gt;
    &lt;Hsp_gaps&gt;0&lt;/Hsp_gaps&gt;
    &lt;Hsp_align-len&gt;158&lt;/Hsp_align-len&gt;
    &lt;Hsp_qseq&gt;MWFMYVLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPG&lt;/Hsp_qseq&gt;
    &lt;Hsp_hseq&gt;MWFMYLLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPG&lt;/Hsp_hseq&gt;
    &lt;Hsp_midline&gt;MWFMY+LSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIWFSTAVLIGLYVFERFPTSMIGVGLFTNLVYFGLLQTFPFIMLTSPNFILSCGLVVVNHYLAFQFFAEEYYPFSEVLAYFTFCLWIIPFAFFVSLSAGENVLPSTMQPG&lt;/Hsp_midline&gt;
  &lt;/Hsp&gt;
&lt;/Hit_hsps&gt;
&lt;/Hit&gt;
&lt;Hit&gt;
&lt;Hit_num&gt;3&lt;/Hit_num&gt;
&lt;Hit_id&gt;tr|F8WAR8|F8WAR8_HUMAN&lt;/Hit_id&gt;
&lt;Hit_def&gt;Protein TEX261 OS=Homo sapiens OX=9606 GN=TEX261 PE=4 SV=1&lt;/Hit_def&gt;
&lt;Hit_accession&gt;F8WAR8&lt;/Hit_accession&gt;
&lt;Hit_len&gt;51&lt;/Hit_len&gt;
&lt;Hit_hsps&gt;
  &lt;Hsp&gt;
    &lt;Hsp_num&gt;1&lt;/Hsp_num&gt;
    &lt;Hsp_bit-score&gt;98.5969&lt;/Hsp_bit-score&gt;
    &lt;Hsp_score&gt;244&lt;/Hsp_score&gt;
    &lt;Hsp_evalue&gt;4.07837e-27&lt;/Hsp_evalue&gt;
    &lt;Hsp_query-from&gt;1&lt;/Hsp_query-from&gt;
    &lt;Hsp_query-to&gt;50&lt;/Hsp_query-to&gt;
    &lt;Hsp_hit-from&gt;1&lt;/Hsp_hit-from&gt;
    &lt;Hsp_hit-to&gt;50&lt;/Hsp_hit-to&gt;
    &lt;Hsp_query-frame&gt;0&lt;/Hsp_query-frame&gt;
    &lt;Hsp_hit-frame&gt;0&lt;/Hsp_hit-frame&gt;
    &lt;Hsp_identity&gt;49&lt;/Hsp_identity&gt;
    &lt;Hsp_positive&gt;50&lt;/Hsp_positive&gt;
    &lt;Hsp_gaps&gt;0&lt;/Hsp_gaps&gt;
    &lt;Hsp_align-len&gt;50&lt;/Hsp_align-len&gt;
    &lt;Hsp_qseq&gt;MWFMYVLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_qseq&gt;
    &lt;Hsp_hseq&gt;MWFMYLLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_hseq&gt;
    &lt;Hsp_midline&gt;MWFMY+LSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_midline&gt;
  &lt;/Hsp&gt;
&lt;/Hit_hsps&gt;
&lt;/Hit&gt;
&lt;Hit&gt;
&lt;Hit_num&gt;4&lt;/Hit_num&gt;
&lt;Hit_id&gt;tr|U3KQC7|U3KQC7_HUMAN&lt;/Hit_id&gt;
&lt;Hit_def&gt;Uncharacterized protein (Fragment) OS=Homo sapiens OX=9606 PE=4 SV=1&lt;/Hit_def&gt;
&lt;Hit_accession&gt;U3KQC7&lt;/Hit_accession&gt;
&lt;Hit_len&gt;49&lt;/Hit_len&gt;
&lt;Hit_hsps&gt;
  &lt;Hsp&gt;
    &lt;Hsp_num&gt;1&lt;/Hsp_num&gt;
    &lt;Hsp_bit-score&gt;91.2781&lt;/Hsp_bit-score&gt;
    &lt;Hsp_score&gt;225&lt;/Hsp_score&gt;
    &lt;Hsp_evalue&gt;2.69841e-24&lt;/Hsp_evalue&gt;
    &lt;Hsp_query-from&gt;4&lt;/Hsp_query-from&gt;
    &lt;Hsp_query-to&gt;50&lt;/Hsp_query-to&gt;
    &lt;Hsp_hit-from&gt;2&lt;/Hsp_hit-from&gt;
    &lt;Hsp_hit-to&gt;48&lt;/Hsp_hit-to&gt;
    &lt;Hsp_query-frame&gt;0&lt;/Hsp_query-frame&gt;
    &lt;Hsp_hit-frame&gt;0&lt;/Hsp_hit-frame&gt;
    &lt;Hsp_identity&gt;46&lt;/Hsp_identity&gt;
    &lt;Hsp_positive&gt;47&lt;/Hsp_positive&gt;
    &lt;Hsp_gaps&gt;0&lt;/Hsp_gaps&gt;
    &lt;Hsp_align-len&gt;47&lt;/Hsp_align-len&gt;
    &lt;Hsp_qseq&gt;MYVLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_qseq&gt;
    &lt;Hsp_hseq&gt;MYLLSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_hseq&gt;
    &lt;Hsp_midline&gt;MY+LSWLSLFIQVAFITLAVAAGLYYLAELIEEYTVATSRIIKYMIW&lt;/Hsp_midline&gt;
  &lt;/Hsp&gt;
&lt;/Hit_hsps&gt;
&lt;/Hit&gt;
&lt;/Iteration_hits&gt;
&lt;Iteration_stat&gt;
  &lt;Statistics&gt;
    &lt;Statistics_db-num&gt;95943&lt;/Statistics_db-num&gt;
    &lt;Statistics_db-len&gt;38082498&lt;/Statistics_db-len&gt;
    &lt;Statistics_hsp-len&gt;101&lt;/Statistics_hsp-len&gt;
    &lt;Statistics_eff-space&gt;2697264225&lt;/Statistics_eff-space&gt;
    &lt;Statistics_kappa&gt;0.041&lt;/Statistics_kappa&gt;
    &lt;Statistics_lambda&gt;0.267&lt;/Statistics_lambda&gt;
    &lt;Statistics_entropy&gt;0.14&lt;/Statistics_entropy&gt;
  &lt;/Statistics&gt;
&lt;/Iteration_stat&gt;
&lt;/Iteration&gt;
</code></pre>
<h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>观察序列信息的各种标识，可从中提取有用的信息。下面是以julia语言写的一个简单粗暴提取比对上的两个蛋白(Accession)以及打分信息的脚本。</p>
<pre><code># Julia language
function main()
    ioBlast = open(&quot;blast.xml&quot;, &quot;r&quot;) 
    # 读BLAST结果
    ioBPout = open(&quot;blastresult.txt&quot;, &quot;w&quot;) 
    # 将提取的信息写入该文件
    # 自行选择方便后续步骤的文件格式
    
    write(ioBPout, &quot;Mouse\tHuman\tHsp_bit-score\thspscore\t&quot;) # 信息表头

    global Mouse_P, Human_P, bitscore, hspscore 
    # 声明变量为global，便于后续的步骤

    while !eof(ioBlast)
        # 按行读文件，若有所需信息则提取，没有则继续读取下一行
        line = readline(ioBlast)
        if occursin(r&quot;&lt;Iteration_query-def&gt;&quot;, line)
            (a, Mouse_P, c) = split(line, &quot;|&quot;)
        end
        if occursin(r&quot;&lt;Hit_id&gt;&quot;, line)
            (a, Human_P, c) = split(line, &quot;|&quot;)
        end
        if occursin(r&quot;&lt;Hsp_bit-score&gt;&quot;, line)
            (a, temps) = split(line, &quot;&gt;&quot;)
            (bitscore, c) = split(temps, &quot;&lt;&quot;)
        end
        if occursin(r&quot;&lt;Hsp_score&gt;&quot;, line)
            (a, temps) = split(line, &quot;&gt;&quot;)
            (hspscore, c) = split(temps, &quot;&lt;&quot;)
        end
        if occursin(r&quot;&lt;/Hit&gt;&quot;, line)
            write(ioBPout, Mouse_P, &quot;\t&quot;, Human_P, &quot;\t&quot;, bitscore, &quot;\t&quot;, hspscore, &quot;\n&quot;)
        end
    end

    close(ioBlast)
    close(ioBPout)            
end

main() # 运行上述函数
</code></pre>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="https://www.bioinfo-scrounger.com/archives/77/">BLAST本地化使用</a></li>
<li><a href="https://www.bioinfo-scrounger.com/archives/82/">Blast+ xml格式解读</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>BLAST</category>
      </categories>
      <tags>
        <tag>BLAST</tag>
      </tags>
  </entry>
  <entry>
    <title>Batch Effects Matter and Avoid Them in Omics Data</title>
    <url>/2021/10/29/BatchEffect/</url>
    <content><![CDATA[<center>文献阅读：关于批次效应的3W1H——什么是批次效应、什么情况下会出现批次效应、为什么要关注批次效应与如何处理批次效应</center>
<span id="more"></span>

<br>

<h2 id="什么是批次效应"><a href="#什么是批次效应" class="headerlink" title="什么是批次效应"></a>什么是批次效应</h2><p><strong>批次效应</strong>是指实验子组在不同的实验条件之下具有与研究中的生物学或其它科学变量无关的性质不同的行为，即实验中测量值之间由于技术因素造成的系统性差异。</p>
<br>

<h2 id="什么情况下会有批次效应"><a href="#什么情况下会有批次效应" class="headerlink" title="什么情况下会有批次效应"></a>什么情况下会有批次效应</h2><p>批次效应在生物学实验中广泛存在，无论是microarray expression profiling还是mass spectrometry产生的数据，都观察到明显的批次效应。具体到研究疾病的差异基因/蛋白或变异数据(如拷贝数变异)的研究中同样观察到明显批次效应。<br>造成批次效应的因素有很多，试剂批次不同、实验时间不同、仪器状态变化、实验员不同都可能造成批次效应。其中一些批次效应能够通过规范化实验操作、更好的实验设计避免；另一些则需要通过对所得数据进行处理才能够消除。<br>在Leek等人对已公开数据批次效应的研究发现，已公开的数据中存在明显批次效应。且在许多实验条件和技术中，技术性因素比生物性因素对实验结果更具影响力。当批次效应发生时，常常与生物性因素混淆，导致下游研究结果不准确。  </p>
<br>

<h2 id="为什么要关注批次效应"><a href="#为什么要关注批次效应" class="headerlink" title="为什么要关注批次效应"></a>为什么要关注批次效应</h2><p>当批次效应发生时，可能会</p>
<ul>
<li>增加变化(variability)而掩盖真正生物学信号，导致得到错误的生物学或临床结论  </li>
<li>与特征信号混在一起，导致下游分类器构建困难  </li>
<li>阻碍生物学上重要亚型的发现或与亚型混淆难以区分  </li>
<li>导致实验资源分配不当，结果缺乏可重复性  </li>
</ul>
<p>因此，消除批次效应对得到准确、可重复性高的结论非常重要。</p>
<br>

<h2 id="如何避免或处理批次效应"><a href="#如何避免或处理批次效应" class="headerlink" title="如何避免或处理批次效应"></a>如何避免或处理批次效应</h2><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><p>避免出现批次效应的首要步骤是合理的实验设计。高通量的实验应在实验设计时考虑到批次效应，在实验过程中尽可能避免批次效应的出现。实验分组时也需保证平衡性(balance)，避免非研究目标的生物学因素对实验结果造成影响，进而和批次效应混杂，导致数据难以处理。  </p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>优秀的实验设计是降低批次效应的基础，在此基础之上处理批次效应主要有以下两个步骤：</p>
<ol>
<li>识别并量化数据中潜在的批次效应，包括人为因素  </li>
<li>使用已知或找到的人为因素调整数据以适应下游分析</li>
</ol>
<h4 id="识别并量化批次效应"><a href="#识别并量化批次效应" class="headerlink" title="识别并量化批次效应"></a>识别并量化批次效应</h4><p>识别和量化批次效应主要通过主成分分析(Principal Component Analysis, PCA)或其它数据可视化工具如聚类、多维数据标化等。<br>如果数据处理结果中出现：  </p>
<ul>
<li>样本按处理组或时间聚类</li>
<li>大量特征与处理组或时间高度相关</li>
<li>主成分与批次处理组或时间相关联  </li>
</ul>
<p>则表明数据中极大可能存在批次效应，必须在下游数据处理前考虑到批次效应的影响。</p>
<h4 id="处理批次效应"><a href="#处理批次效应" class="headerlink" title="处理批次效应"></a>处理批次效应</h4><p>根据其算法思想可将消除批次效应的方法分为如下几个大类：  </p>
<ul>
<li><strong>简单线性模型(Simple Linear Models)</strong>: Mean-scaling, zero-centering  </li>
<li><strong>经验贝叶斯方法(Empirical Bayes)</strong>: ComBat  </li>
<li><strong>因子分析(Factor-based analysis)</strong>: Surrogate Variable Analysis (SVA), Removed unwanted variation (RUV)  </li>
<li><strong>深度学习(Deep Learning)</strong>: NormAE</li>
</ul>
<p>其中，前两种消除批次效应的方法需要已知造成批次效应的因素，如实验时间等。  </p>
<p>根据先验知识、实验数据规模、特征空间大小、研究目的等因素，可挑选不同的处理批次效应的方法：</p>
<ul>
<li>大数据；特征空间有限；有限的生物异质性；批次效应或分类影响因子已知；目标是简单分析：<strong>Two-way ANOVA</strong>  </li>
<li>小数据；特征空间有限；有限的生物异质性；批次效应或类影响因子已知；目标是去除批次效应：<strong>ComBat</strong>  </li>
<li>中/大型数据集；大特征空间；存在生物异质性；类因子已知，批次效应影响因素不必已知；目标是移除批次效应且确定批次效应影响因素：<strong>SVA</strong>, <strong>RUV</strong>  </li>
<li>中/大型数据集；大特征空间；存在生物异质性；批次效应或分类影响因子都不必已知；目标是移除批次效应且确定批次效应影响因素但不需直到类因子：<strong>unsupervised methods (PCA)</strong>, <strong>RUV</strong></li>
</ul>
<p>算法补充：<br><img src="/2021/10/29/BatchEffect/Methods.png" alt="算法补充1"><br><img src="/2021/10/29/BatchEffect/Methods2.png" alt="算法补充2">  </p>
<h4 id="批次效应处理评估"><a href="#批次效应处理评估" class="headerlink" title="批次效应处理评估"></a>批次效应处理评估</h4><p>消除批次效应之后，通常会检查处理的效果。常用的方法有PCA、层次聚类等，检查数据是否有与批次相关联的偏移、聚类结果是否更符合生物学先验知识等。<br>评估方法小结：<br><img src="/2021/10/29/BatchEffect/Validation.png" alt="批次效应评估方法">  </p>
<br>

<h2 id="批次效应处理流程"><a href="#批次效应处理流程" class="headerlink" title="批次效应处理流程"></a>批次效应处理流程</h2><p>Jelena Čuklina等人针对批次效应的研究中提供了一个消除蛋白质数据批次效应的处理流程和一个包含所有处理步骤的R包——proBatch (<a href="https://www.bioconductor.org/packages/release/bioc/html/proBatch.html">Bioconductor</a>, <a href="https://hub.docker.com/r/digitalproteomes/probatch">Docker container</a>, <a href="https://github.com/symbioticMe/batch_effects_workflow_code">GitHub repository</a>都可获取该R包)  </p>
<h3 id="流程图总览"><a href="#流程图总览" class="headerlink" title="流程图总览"></a>流程图总览</h3><p><img src="/2021/10/29/BatchEffect/workflow.png" alt="批次效应处理流程图">  </p>
<ol>
<li>初步评估原始数据中是否存在批次效应  </li>
<li>归一化使数据集中所有数据在同一尺度  </li>
<li>归一化后数据评估，以确定数据是否需要进一步处理  </li>
<li>批次效应校正以纠正特征偏移  </li>
<li>质量控制测试：是否在保留有意义信号的同时减少了数据偏差  </li>
</ol>
<h3 id="Raw-Data-Matrix"><a href="#Raw-Data-Matrix" class="headerlink" title="Raw Data Matrix"></a>Raw Data Matrix</h3><p>在进行这一流程之前，应当先对数据进行预处理，如肽段识别、肽段定量、FDR筛选、log-transformed或variance stabilizing transformation。<br>虽然在ion fragment、peptides、protein层面都可以识别并处理批次效应，但因为这个过程改变了对蛋白质推断至关重要的特征丰度，最好针对ion fragment或peptides数据处理批次效应。且在处理过程中应包含尽可能多的数据以保证数据分布最接近真实情况。  </p>
<h3 id="Initial-Assessment"><a href="#Initial-Assessment" class="headerlink" title="Initial Assessment"></a>Initial Assessment</h3><p>这一步骤主要目的是确定数据的偏移程度并确定一个归一化方法。通常情况下，样本间intensity会有一定差异，调整这种差异有助于数据的比较，能够更好地识别出需要进一步处理的因素。主要方法有三种：</p>
<ol>
<li>按照质谱测量或技术批次的顺序绘制样品强度平均值或中值，评估每个批次中的质谱漂移或离散偏差  </li>
<li>箱线图，评估样本方差和异常值  </li>
<li>批次间与批次内样本相关性  </li>
</ol>
<p>通过上述步骤来检验</p>
<ul>
<li>数据分布是否具有一致性  </li>
<li>样本间的相关性  </li>
<li>如果有差异，这种差异是否与批次相关联  </li>
</ul>
<h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>归一化的目的就是将所有样本的数据处于同一尺度，使得跨样本数据能够互相比较。常用的归一化方法有quantile normalization、median normalization和z-transformation，应根据数据的异质性和数据分布情况选择合适的归一化方法。  </p>
<h4 id="数据的异质性"><a href="#数据的异质性" class="headerlink" title="数据的异质性"></a>数据的异质性</h4><ul>
<li><strong>数据相似程度高：</strong> quantile normalization  </li>
<li><strong>数据具有本质差异：</strong> HMM-assisted normalization  </li>
<li><strong>数据会有包含信息的异常值(outliers)：</strong> 选择能够保留异常值与总体数据关系的归一化方法  </li>
</ul>
<h4 id="样本丰度分布"><a href="#样本丰度分布" class="headerlink" title="样本丰度分布"></a>样本丰度分布</h4><ul>
<li>通常情况下，只需调整数据中位数或平均值  </li>
<li>如果出现方差差异较大，也需要将它们调整到同一尺度</li>
</ul>
<p>归一化步骤应尽可能简单直接，对数据的操作越少，越能够保留数据的真实情况。归一化后可通过diagnostic plots和quality control方法对数据进行评估。</p>
<h3 id="Diagnostics-of-normalized-data"><a href="#Diagnostics-of-normalized-data" class="headerlink" title="Diagnostics of normalized data"></a>Diagnostics of normalized data</h3><p>评估归一化后的数据以确定是否需要进一步的处理，主要方法为：</p>
<ul>
<li><strong>Hierarchical clustering：</strong>  将相似的样本分组为树状结构，观察聚类结果是否和批次相关  </li>
<li><strong>Principal Component Analysis(PCA):</strong> 观察主成分是否与批次相关联，对评估聚类依据是生物还是技术因素及检查重复组相似性十分有效  </li>
</ul>
<p>上述方法要求数据中没有缺失值，而蛋白质组数据通常含有缺失值。填补缺失值时应特别注意尽可能保留数据原有的分布，不能盲目填0或一个较小的随机数。<br>蛋白质组通常使用肽段数据检查是否存在与批次相关的偏移。如在DIA数据中加入iRT肽段用于数据特征校正。由于不同肽段对不同批次效应的response不同，有必要检查大量肽段以确定是否存在批次效应。通过检查肽段数据还能够确认跑样顺序是否对数据造成影响，是否有与顺序相关的变化趋势(trends)。<br>还可以用ion fragments的数据校正蛋白数据，但目前针对肽段的方法更加广泛。  </p>
<h3 id="Batch-effect-correction"><a href="#Batch-effect-correction" class="headerlink" title="Batch effect correction"></a>Batch effect correction</h3><p>归一化能够校准数据的全局，而批次效应校正主要针对特征峰和特征组。根据批次效应的形式，可将消除批次效应的方法分为两大类：</p>
<ul>
<li><strong>Continuous</strong><br>消除连续的批次效应主要通过拟合的方式，如LOESS fit，或使用其它连续算法。<br>在质谱大数据(hundreds of samples)中会出现信号漂移现象，这仍是一个亟待解决的问题。  </li>
<li><strong>Discrete</strong><br>消除离散的批次效应时常用mean and median centering。<br>基于贝叶斯模型的ComBat算法也能够用于处理蛋白质数据，但需要已知所有的批次效应影响因素。</li>
</ul>
<h3 id="Quality-control"><a href="#Quality-control" class="headerlink" title="Quality control"></a>Quality control</h3><p>质控步骤主要用于评估归一化和批次效应校正之后的数据质量，好的数据校正应做到消除偏移(negative control)和提升数据(positive control)两方面。  </p>
<ul>
<li><strong>消除偏移的标准</strong>  <ul>
<li>聚类或PCA后，同组数据聚集依据与批次无关，更多地受生物学因素影响  </li>
<li>肽段(或其他特征，如ion fragments)没有与批次相关的偏移  </li>
</ul>
</li>
<li><strong>提升数据</strong><ul>
<li>通常情况下，数据提升的标准为聚类结果更符合生物学先验知识，后续差异检验步骤能够识别出更多差异。但这种标准并不具有足够的客观性，尤其是后一个标准并不一定表明数据提升，还有可能是false positive  </li>
<li>交叉验证：差异表达蛋白或最佳分类特征蛋白列表高度重合。但这种方法依赖于数据集和特征空间的大小，当数据集较小，后一个蛋白列表本身不稳定，会对评估造成影响。在另一篇综述中强调应避免交叉验证来评估数据质量  </li>
<li>检查重复组间的方差：如果数据的归一化和消除批次效应步骤合理，重复组间的方差应降低  </li>
<li>样本间相关性：技术或生物学重复样本间的相关性应明显高于与其它样本的相关性  </li>
<li>距离矩阵：与上一方法的逻辑相似，但通过计算样本间距离来评估数据  </li>
<li>肽段间的相关性：来自同一蛋白的肽段具有正相关或高相关性，而来自不同蛋白或不相关的肽段间的相关性应接近于0  </li>
</ul>
</li>
</ul>
<br>

<h2 id="消除批次效应的方法-工具"><a href="#消除批次效应的方法-工具" class="headerlink" title="消除批次效应的方法/工具"></a>消除批次效应的方法/工具</h2><h3 id="ComBat"><a href="#ComBat" class="headerlink" title="ComBat"></a>ComBat</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>ComBat基于参数和非参数经验贝叶斯框架，用于调整具有批次效应的数据。该方法对小样本中的异常值具有健壮性，并且与大样本的现有方法相当。<br>以Microarray为研究对象。  </p>
<h4 id="经验贝叶斯框架使用基础"><a href="#经验贝叶斯框架使用基础" class="headerlink" title="经验贝叶斯框架使用基础"></a>经验贝叶斯框架使用基础</h4><ul>
<li>已经广泛用于大规模microarray数据：稳定具有极高或极低比率的基因的表达比，缩小所有其他基因的方差来稳定基因方差避免伪影的影响等  </li>
<li>已有批次效应处理方法(如SVD、DWD和L/S method)需要大批量数据，且不能兼容小批次数据的离群值  </li>
<li>对高位效数据组有较强的健壮性  </li>
<li>利用跨基因和跨样本的“借用信息”，以得到更好的估计或更稳定的结果  </li>
</ul>
<h4 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h4><ul>
<li>结合基因间常见的系统批次效应，假设导致批次效应的现象通常以相似的方式影响许多基因  </li>
<li>通过汇集信息(pooling information)来估计代表批次效应的L/S模型参数，在每个批次的基因中缩减(shrink)批次效应参数估计值，使之朝着批次效应估计值的总体平均值(跨基因)发展  </li>
<li>数据已被归一化，所有样本的基因表达值已被估计  </li>
</ul>
<h4 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h4><ol>
<li>Standardize the data  </li>
<li>EB batch effect parameter estimates using parametric empircal priors  </li>
<li>Adjust the data for batch effects  </li>
</ol>
<h3 id="QC-RLSC"><a href="#QC-RLSC" class="headerlink" title="QC-RLSC"></a>QC-RLSC</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>QC-RLSC(quality control-based robust LOESS signal correction)可用于信号校正和整合来自不同实验批次的数据。<br>以Metabolics数据为研究对象。  </p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>LOESS曲线拟合结合了经典的线性最小二乘法回归的简单性和非线性回归的灵活性。它通过对数据的局部子集进行简单的模型拟合来建立一个函数，逐点地描述数据中的确定性变化部分。不需要指定任何形式的全局函数来拟合数据的模型，而只需要拟合数据的片段。<br>对数据的每个子集进行拟合的局部多项式被限制为一阶或二阶(即局部线性或局部二阶)，并使用加权最小二乘法拟合(标准三立方权重函数)。<br>优化平滑参数(或称跨度)以获得更好的回归曲线。不使用过小的平滑参数以避免曲线受到随机误差的影响。<br>留一法交叉验证(leave-one-out cross validation)以避免过拟合。  </p>
<h4 id="关键步骤-1"><a href="#关键步骤-1" class="headerlink" title="关键步骤"></a>关键步骤</h4><ol>
<li>在实验结束、色谱解卷积后，使用QC-RLSC对数据进行标准化(normalize)</li>
<li>依据注入顺序，对质控数据进行LOESS拟合</li>
<li>对整个分析运行的校正曲线进行内插，并对该特征的总数据集进行标准化</li>
</ol>
<p>通过这些步骤，在一次分析中，峰响应的任何衰减都被最小化。</p>
<h3 id="ICA"><a href="#ICA" class="headerlink" title="ICA"></a>ICA</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>使用时空独立成分分析(spatio-temporal independent component analysis)对批次效应建模，并移除这些影响。<br>以microarray datasets为研究对象。  </p>
<h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>对整合的数据集进行因子分解(factorization)，移除与子数据集具有某种相关性的组件，以获得最终数据集。这一过程能够从数据中移除批次效应。<br>去除的成分是可以解释的，很容易检查它们是否与某些感兴趣的生物信息相关。<br>ICA被证明能更好地模拟不同的变异(variables)来源。  </p>
<h4 id="关键步骤-2"><a href="#关键步骤-2" class="headerlink" title="关键步骤"></a>关键步骤</h4><p>假设汇总的数据集是一个按样本划分的基因矩阵<em>X</em>，<em>X</em><sub>i,j</sub> 表明gene <em>i</em> 在样本 <em>j</em> 中的表达量。<br><img src="/2021/10/29/BatchEffect/ICAsteps.png" alt="ICA流程">  </p>
<h3 id="WaveICA"><a href="#WaveICA" class="headerlink" title="WaveICA"></a>WaveICA</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>WaveICA基于带有小波变换的独立成分分析，作为大规模代谢组学数据的阈值处理方法捕获并去除批次效应。<br>研究对象为Metabolics数据。  </p>
<h4 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h4><p>利用样品在注射顺序中的时间趋势，将原始数据分解为具有不同特征的多尺度数据，提取并去除多尺度数据中的批次效应信息，获得干净的数据。<br>在实际问题中DWT有局限性，WaveICA中使用的小波变换为Maximal overlap discrete wavelet transform (MODWT)。  </p>
<h4 id="关键步骤-3"><a href="#关键步骤-3" class="headerlink" title="关键步骤"></a>关键步骤</h4><p><img src="/2021/10/29/BatchEffect/WaveICA.png" alt="WaveICA流程">  </p>
<h3 id="NormAE"><a href="#NormAE" class="headerlink" title="NormAE"></a>NormAE</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>Normlization Autoencoder(NormAE)基于非线性自编码器和对抗性学习的新型深度学习模型。<br>研究对象为Metabolics数据。  </p>
<h4 id="基本原理-3"><a href="#基本原理-3" class="headerlink" title="基本原理"></a>基本原理</h4><p>将非线性自编码器和DNN结合，提高模型的非线性拟合能力，使得批次效应结果和其它因素影响结果分开，以在去除批次效应的同时保留更多生物学特征。<br>在AE模型的训练过程中，训练一个额外的分类器和排序器来对抗性正则化，潜在的特征被编码器提取出来，然后解码器在没有批次效应的情况下重建数据。  </p>
<h4 id="关键步骤-4"><a href="#关键步骤-4" class="headerlink" title="关键步骤"></a>关键步骤</h4><p>黑色实线和红色虚线分别表示反向传播算法的前向和后向计算步骤。蓝色虚线路径表示训练后的批量效应去除步骤。<br><img src="/2021/10/29/BatchEffect/NormAE.png" alt="NormAE原理图">  </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Leek, Jeffrey T et al. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3880143/"><strong>Tackling the widespread and critical impact of batch effects in high-throughput data.</strong></a> Nature reviews. Genetics, vol. 11,10 (2010): 733-9.<br>[2] Čuklina, Jelena et al. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8447595/"><strong>Diagnostics and correction of batch effects in large-scale proteomic studies: a tutorial.</strong></a> Molecular systems biology, vol. 17,8 (2021): e10240.<br>[3] Zhou, Longjian et al. <a href="https://pubmed.ncbi.nlm.nih.gov/31611172/"><strong>Examining the practical limits of batch effect-correction algorithms: When should you care about batch effects?</strong></a>, Journal of Genetics and Genomics, Vol. 46, 9(2019): 433-443.<br>[4] Goh, Wilson Wen Bin et al. <a href="https://pubmed.ncbi.nlm.nih.gov/28351613/"><strong>Why Batch Effects Matter in Omics Data, and How to Avoid Them.</strong></a> Trends Biotechnol, Vol. 35, 6 (2017):498-507.<br>[5] Johnson, WE et al. <a href="https://academic.oup.com/biostatistics/article/8/1/118/252073/"><strong>Adjusting batch effects in microarray expression data using empirical Bayes methods.</strong></a> Biostatistics, Vol. 8, 1 (2007): 118–127.<br>[6] Dunn, W et al. <a href="https://www.nature.com/articles/nprot.2011.335/"><strong>Procedures for large-scale metabolic profiling of serum and plasma using gas chromatography and liquid chromatography coupled to mass spectrometry.</strong></a> Nature Protocol, 6 (2011): 1060–1083.<br>[7] Sompairac, Nicolas et al. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6771121/"><strong>Independent Component Analysis for Unraveling the Complexity of Cancer Omics Datasets.</strong></a> International journal of molecular sciences. vol. 20, 18 (2019): 4414.<br>[8] Deng, Kui et al. <a href="https://www.sciencedirect.com/science/article/abs/pii/S0003267019301849/"><strong>WaveICA: A novel algorithm to remove batch effects for large-scale untargeted metabolomics data based on wavelet analysis.</strong></a> Analytica Chimica Acta, Vol. 1061, (2019): 60-69.<br>[9] Rong, Zhiwei et al. <a href="https://pubs.acs.org/doi/10.1021/acs.analchem.9b05460/"><strong>NormAE: Deep Adversarial Learning Model to Remove Batch Effects in Liquid Chromatography Mass Spectrometry-Based Metabolomics Data.</strong></a> Analytical Chemistry, Vol. 92, 7 (2020): 5082–5090.  </p>
]]></content>
      <categories>
        <category>Paper</category>
        <category>BatchEffects</category>
      </categories>
      <tags>
        <tag>BatchEffects</tag>
        <tag>Bioinformatics</tag>
      </tags>
  </entry>
  <entry>
    <title>Mastodon 建站笔记</title>
    <url>/2022/03/02/buildmastodon/</url>
    <content><![CDATA[<center> mastodon 建站笔记：慢慢来，6 月之前搞完就行；不要怕，不行就重启试试 </center>
<span id="more"></span>

<br>

<h2 id="一点说明"><a href="#一点说明" class="headerlink" title="一点说明"></a>一点说明</h2><p>本文所记录的搭建非常缓慢，开始于二月，但给自己设定的 DDL 在六月。搭建过程完全碎片化，每次推进都基于“这会儿没什么事情不如搞一搞建站”，且超过一小时就会先放着下次再说，非常随性随意。每一步完成于哪一天、大概耗时都有记录，给想搭建却又嫌麻烦、觉得需要特意安排时间的朋友提供一个佛系搭建参考。  </p>
<h2 id="参考与致谢"><a href="#参考与致谢" class="headerlink" title="参考与致谢"></a>参考与致谢</h2><p>参考：蓝盒子站长的<a href="https://pullopen.github.io/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/2020/10/19/Mastodon-on-Docker.html">利用 docker 搭建 Mastodon 实例</a>和塔塔的<a href="https://mantyke.icu/2021/mastodon-bulid/">小球飞象建站笔记</a>。  </p>
<p>感谢嘎嘎、塔塔和其他写下详细教程和笔记的朋友！因为你们和你们的教程，我这种没有参考不敢做事的人才能一点点把实例搭建起来。<br>特别感谢塔塔，给我每完成一步的嘟嘟点星星，给予我很大鼓励！  </p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>前期准备主要是花钱，大多数运营商都支持 Visa、MasterCard 或 PayPal，godaddy 支持支付宝付款。<br>为能有更多选择，个人建议开通 PayPal，比办信用卡方便一些。本文中除 Scaleway 以外，所有支付都通过 PayPal 完成。如使用 PayPal 付款，建议付款时直接使用目标货币，而不使用 PayPal 提供的转换为人民币付款。这种情况下付款使用的是银行汇率，会比 PayPal 划算。  </p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>常用的域名提供商很多，比如 <a href="https://www.namecheap.com/">NameCheap</a>，<a href="https://sg.godaddy.com/">godaddy</a> 和 <a href="https://www.dynadot.com/">dynadot</a>。可参考o3o站长给出的<a href="https://www.notion.so/c66e3332f4824f71b9d7d1dc8db410c7">域名选购指南</a>。<br>本站根据蓝盒子站长的推荐，在 NameCheap 购买域名。由于之前给博客换域名已经在 NameCheap 买过一次，而且很早就想好要买什么域名，所以这一步成为这个跨越几个月的搭建过程中最简单、最快速的一步。  </p>
<p>该步骤完成于 2022.02.17。约耗时 15 分钟，主要在犹豫到底要不要这天买，实际操作只用掉两三分钟。以及早知道我这么快就要自建站，博客就换个域名了！两年后我博客必换域名！</p>
<h3 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h3><p>使用 Zoho Mail 提供的 Business Mail 服务中的 Forever Free Plan。<br>由于本人需要很详细的操作步骤才敢进行下一步，这里找了个注册 Zoho Mail 的详细教程 —— <a href="https://www.dreambuildinglab.com/website-construction/email/how-to-register-free-zoho-business-email.html">注册zoho免费企业邮箱</a>。这个教程虽然详细，但稍微有点过时，有些操作的名称略有更改。如有需要，可再找其它教程参考。  </p>
<p>该步骤完成于 2022.02.21。约耗时 40 分钟，因为一些步骤没有明确的参考不太敢试，必须找到别人这一步怎么做才动手。但实际上没关系，大胆试，不行重来嘛！  </p>
<h3 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h3><p>选择 <a href="https://contabo.com/en/">Contabo</a> 购买 VPS，在购买前将价格修改为欧元，选择5欧套餐，德国服务器，一次性购买 12 个月，其它选项全部默认。<br>这里塔塔提醒<a href="https://mantyke.icu/2021/mastodon-bulid/#%E8%B4%AD%E4%B9%B0vps"> Contabo 审核严格</a>，最好真实 IP 购买，填写信息时不要太扯，不然会被要求提供身份证明。但我就是那个认真填写还被要求提供护照的倒霉蛋。由于目前和德国有 7 个小时时差，上午提供护照信息后，一直到下午四点多才收到确认邮件。  </p>
<p>该步骤完成于 2022.03.02。约耗时 15 分钟加 19 小时，15 分钟是实际需要操作的时间，包括提供护照信息；19 小时是由于买服务器时护照不在手边，第二天上午才回复，下午收到确认。  </p>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><p>这一部分参考<a href="https://pullopen.github.io/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/2020/10/19/Mastodon-on-Docker.html">蓝盒子站长教程</a>。  </p>
<ul>
<li><p>配置 ssh-key<br>首先查看电脑当前用户的目录下是否存在.ssh目录，以及目录中是否存在<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。如果存在，公钥即为<code>id_rsa.pub</code>中的内容。如果不存在，则输入命令：  </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “your_email”</span><br></pre></td></tr></table></figure>

<p>一路回车，直到生成一个矩形的图案为止，生成的这串字符就是后面需要的公钥。  </p>
<p>接下来的步骤全部按照蓝盒子站长的教程进行，但我遇到了一个愚蠢的问题，不会保存 nano 编辑的内容并退出。即使编辑器下方有两行提醒，也没能正确保存文件。万一有朋友和我一样，可参考以下保存并退出的方法：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ^ 为键盘上的 Ctrl 键，以下方法直接使用 Ctrl 代替</span><br><span class="line"># 退出，并根据提示保存</span><br><span class="line">Ctrl + X 退出，按 y 选择保存，提示 file name to write，利用上下左右键选择要保存到的文件，回车保存</span><br><span class="line"># 退出，并保存</span><br><span class="line">Ctrl + X 退出，按 y 选择保存，回车</span><br><span class="line"># 先保存，后退出</span><br><span class="line">Ctrl + O 并回车保存，Ctrl + X 退出</span><br></pre></td></tr></table></figure></li>
<li><p>安装常用命令和配置防火墙<br>直接照抄蓝盒子站长给的命令，都非常顺利。  </p>
</li>
</ul>
<p>该步骤完成于 2022.03.03。约耗时 55 分钟，主要由于不会保存 nano 编辑的内容，根据各种教程也总是保存失败。中途一度试图换回之前常用的 vim，但事实证明两年没用就会忘记一切。如果能顺利保存，这一步十分钟以内就可以完成。  </p>
<p><strong>tips</strong><br>虽然上次建站配置好了服务器端的公钥，但这次登录时，MobaXterm 一直返回错误信息：  </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disconnected: No supported authentication methods available (server sent: publickey)</span><br></pre></td></tr></table></figure>

<p>原因是服务器已经关闭账户密码登录，但使用 MobaXterm 登录时没有勾选 <code>Use private key</code> 并指定私钥文件。<br>具体步骤为 <code>Session -&gt; SSH -&gt; Use private key and specify a private key for passwordless login</code>。<br>设置完成后即可顺利登录。  </p>
<h3 id="安装-docker-和-docker-compose"><a href="#安装-docker-和-docker-compose" class="headerlink" title="安装 docker 和 docker-compose"></a>安装 docker 和 docker-compose</h3><p>根据蓝盒子站长的教程，使用官方提供的一键脚本安装 docker。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 代码来自蓝盒子站长教程</span><br><span class="line">bash &lt;(curl -L https://get.docker.com/)</span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>该步骤完成于 2022.03.13。约耗时 15 分钟，包括一开始登录不上服务器而查找原因的时间，实际操作时间约 3 分钟。这一步骤完成后可以通过命令 <code>docker-compose -h</code> 检查 docker 是否真的安装成功。  </p>
<h3 id="拉取-Mastodon-镜像-amp-初始化-PostgreSQL"><a href="#拉取-Mastodon-镜像-amp-初始化-PostgreSQL" class="headerlink" title="拉取 Mastodon 镜像 &amp; 初始化 PostgreSQL"></a>拉取 Mastodon 镜像 &amp; 初始化 PostgreSQL</h3><p>这几项全部根据蓝盒子站长 <a href="https://pullopen.github.io/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/2020/10/19/Mastodon-on-Docker.html">2022-04-25 修改的教程</a>进行。  </p>
<ul>
<li>拉取 Mastodon 镜像<br>直接复制粘贴代码，拉取版本为 <code>v3.5.1</code>，并修改 <code>docker-compose.yml</code> 配置文件。  </li>
<li>初始化 PostgreSQL<br>复制粘贴代码，并根据教程中的提醒检查代码运行情况。  </li>
</ul>
<p>该步骤完成于 2022.05.07。约耗时 20 分钟，大部分用于思考设个什么密码。以及如果太久没有建站，一定要先看看上一次都做了什么、用过什么命令，这次又因为忘记 <code>nano</code> 怎么退出而慌乱几秒。  </p>
<h3 id="配置-Mastodon"><a href="#配置-Mastodon" class="headerlink" title="配置 Mastodon"></a>配置 Mastodon</h3><p>这一步骤仍然按照蓝盒子站长的教程进行，根据教程一步步慢慢做，看仔细每一步都要填什么就可以。  </p>
<p>根据<a href="https://mantyke.icu/2021/mastodon-bulid/#%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91">小球飞象建站笔记</a>中踩坑提醒，如果使用的是 zoho 邮件服务，建议 SMTP server 使用国际版地址，否则可能配置失败，无法发送通知邮件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SMTP_SERVER=smtp.zoho.com</span><br></pre></td></tr></table></figure>

<p>该步骤完成于 2022.05.07。耗时约 40 分钟，大多数时间消耗在 <code>docker-compose run --rm web bundle exec rake mastodon:setup</code> 的每一小步上。尤其是 zoho 还突然登录不上，而我又因为时隔近两个月，完全忘记了管理员邮箱是什么，手忙脚乱几分钟。<br>还需注意的是，在这一步中，所有的密码都不可见。一开始没有意识到这一点，以为密码没有粘贴上，同一位置贴两三遍密码导致出错。以及 .env.production 配置信息一定要在电脑上保存一遍！  </p>
<h3 id="安装并配置-nginx"><a href="#安装并配置-nginx" class="headerlink" title="安装并配置 nginx"></a>安装并配置 nginx</h3><p>在进行这一步之前，根据蓝盒子站长的提示，先在购买域名的网站 DNS 设置中增加一个 <code>A Record</code>，将设定的域名指向服务器。  </p>
<ul>
<li>安装 nginx<br>直接运行命令 <code>sudo apt install nginx -y</code> 出现报错信息：  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Err:2 http://security.ubuntu.com/ubuntu focal-updates/main amd64 libnginx-mod-http-image-filter amd64 1.18.0-0ubuntu1.2</span><br><span class="line">404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:3 http://security.ubuntu.com/ubuntu focal-updates/main amd64 libnginx-mod-http-xslt-filter amd64 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:4 http://security.ubuntu.com/ubuntu focal-updates/main amd64 libnginx-mod-mail amd64 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:5 http://security.ubuntu.com/ubuntu focal-updates/main amd64 libnginx-mod-stream amd64 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:6 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx-core amd64 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Ign:1 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx-common all 1.18.0-0ubuntu1.2</span><br><span class="line">Ign:7 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx all 1.18.0-0ubuntu1.2</span><br><span class="line">Err:1 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx-common all 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">Err:7 http://security.ubuntu.com/ubuntu focal-updates/main amd64 nginx all 1.18.0-0ubuntu1.2</span><br><span class="line">  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/nginx-common_1.18.0-0ubuntu1.2_all.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/libnginx-mod-http-image-filter_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/libnginx-mod-http-xslt-filter_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/libnginx-mod-mail_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/libnginx-mod-stream_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/nginx-core_1.18.0-0ubuntu1.2_amd64.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/n/nginx/nginx_1.18.0-0ubuntu1.2_all.deb  404  Not Found [IP: 213.136.72.159 80]</span><br><span class="line">E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?</span><br></pre></td></tr></table></figure>

<p>谷歌之后发现这是 <code>Ubuntu 20.04</code> 会出现的常见报错，在运行安装命令前应先运行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update # 运行这一行之后可以尝试运行安装命令，如果仍报错再运行下一行</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<ul>
<li>配置 nginx &amp; 配置SSL证书 &amp; 重启nginx<br>根据蓝盒子站长的教程配置，步骤中没有出错。</li>
</ul>
<p>该步骤完成于 2022.05.07。约耗时 30 分钟，除了一开始找报错原因费点时间之外，都是运行命令、等待命令结束，操作非常简单。  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到这里站点已经上线，后续都是一些个性化修改，可以根据不同需求找相应的教程。<br>站点搭建实际用时 230 分钟，其中很多时间浪费在不敢做和注意力不集中上。如果不是像我一样每天找一点时间随手操作其中一个小步骤，而是空出一大段时间专心建站的话，应该两到三小时就能够完成上述所有步骤。<br>如果你和我一样也记不住整个过程中太多账号、用户名和密码，可以在电脑上建一个备忘录或在其它安全的地方记住密码。</p>
<h2 id="备份-未完成"><a href="#备份-未完成" class="headerlink" title="备份 (未完成)"></a>备份 (未完成)</h2><p>参考蓝盒子站长的教程：<a href="https://pullopen.github.io/%E7%AB%99%E7%82%B9%E7%BB%B4%E6%8A%A4/2020/07/22/Move-mastodon-media-to-Scaleway.html">如何将Mastodon媒体上传至Scaleway云储存</a></p>
<h2 id="装修"><a href="#装修" class="headerlink" title="装修"></a>装修</h2><h3 id="使用管理命令行"><a href="#使用管理命令行" class="headerlink" title="使用管理命令行"></a>使用管理命令行</h3><ul>
<li>使用脚本简化命令<br>参考：<a href="https://blog.tantalum.life/posts/how-to-run-your-mastodon-by-docker/#%E4%BD%BF%E7%94%A8alias%E8%84%9A%E6%9C%AC%E7%BC%A9%E5%86%99tootctl%E5%91%BD%E4%BB%A4">使用 alias 脚本缩写 tootctl 命令</a>。<br>由于前面的步骤一直主要参考蓝盒子站长的教程，所以这里第一步目标文件夹应为 <code>/home/mastodon/mastodon</code>，即 <code>cd /home/mastodon/mastodon</code>。  </li>
<li>使用命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tootctl help # 帮助信息，如果正常运行说明上一步的简化命令脚本生效。</span><br><span class="line">tootctl settings registrations close # 关闭注册</span><br></pre></td></tr></table></figure></li>
</ul>
<p>此处由于站点装修未完成，暂时关闭注册。也可以在网页端关闭注册。  </p>
<h3 id="开启全文搜索"><a href="#开启全文搜索" class="headerlink" title="开启全文搜索"></a>开启全文搜索</h3><p>参考蓝盒子站长给出的命令修改相应的配置文件，但在重启 docker 这一步骤报错：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: yaml.parser.ParserError: while parsing a block mapping</span><br><span class="line">  in &quot;./docker-compose.yml&quot;, line 3, column 3</span><br><span class="line">expected &lt;block end&gt;, but found &#x27;&lt;block mapping start&gt;&#x27;</span><br><span class="line">  in &quot;./docker-compose.yml&quot;, line 26, column 4</span><br></pre></td></tr></table></figure>

<p>再次检查 <code>docker-compose.yml</code> 文件发现，只删除 <code>#</code> 会导致缩进不统一，导致对 block 的判断有误。每行在删除 <code>#</code> 的同时，应在行首再删除一个空格。<br>其余步骤根据教程中的命令，一步一步完成即可。</p>
<h3 id="其它魔改"><a href="#其它魔改" class="headerlink" title="其它魔改"></a>其它魔改</h3><p>站点魔改有许多可用的教程，如：<br><a href="http://blog.tantalum.life/posts/how-to-run-your-mastodon-by-docker/">Mastodon | 采用docker建站后的使用与维护</a><br><a href="https://pullopen.github.io/%E7%AB%99%E7%82%B9%E7%BB%B4%E6%8A%A4/2020/11/26/mastodon-manage.html">如何装饰你的站点：自定义CSS、中继站和自定义表情</a><br><a href="https://pullopen.github.io/%E8%BF%9B%E9%98%B6%E9%AD%94%E6%94%B9/2020/11/14/mastodon-modify.html">进阶魔改：修改字数上限、媒体上限、投票上限、添加自定义主题、界面用语、非登陆用户有限显示、优化中文搜索，附阻止本站嘟文流入某站点方法</a>  </p>
]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Build</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + GitHub Pages搭建个人博客</title>
    <url>/2021/09/16/Hexo-GitHubPages/</url>
    <content><![CDATA[<center>本博客搭建过程中参考了许多教程。本文用于记录搭建过程，以及出现的一些小问题</center>  
<span id="more"></span>  

<br>  
<br>  

<p>有需要学习搭建博客的朋友可直接参考他人成熟的教程。本文参考教程：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/70240127">Hexo+Github Pages快速实现个人网站</a><br> 搭建流程较为清晰，整体框架都有，不想详细了解每一个步骤只是想成功搭建一个博客参考这个教程就够</li>
<li><a href="https://juejin.cn/post/6844904131266609165">彻底搞懂如何使用Hexo+GitHubPages搭建个人博客</a><br> 对于各种概念的解释都很详细，能够学习到很多知识，有助于未来对博客进行魔改升级等高级操作</li>
<li><a href="https://hexo.io/zh-cn/docs/">Hexo官方说明文档</a><br> Hexo官方说明文档，目前更新版本为1/9/2021。内容步骤简洁明了，跟着一步步做不会出大的差错，如有问题也可以直接提交</li>
<li><a href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site">GitHub Pages官方说明文档</a><br> GitHub Pages官方说明文档，参考性不如前面三个链接，但也能提供一部分支持。</li>
</ol>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Mac和Linux系统的电脑已经预装了git.<br>Windows系统的电脑可以从官网(<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> )下载相应的版本，安装过程中选择默认选项即可。<br>由于之前简单使用过gitee加git存代码，git的配置在当初已经完成。搜索“git使用”能够找到很多有用的教程。</p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>可从官网 (<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>)直接下载安装，可根据需求下载最新版本或推荐版本。需要注意的是，目前Hexo官网给出的建议是Node.js版本需不低于10.13，建议使用Node.js 12.0及以上版本。此处下载了Nodejs官网的推荐版本(recommended for most users)，14.17.6 LTS.<br>由于对Node.js并不了解，安装过程中直接选择了Automatically install the necessary tools.如果想更深入了解安装过程及自定义安装，可参考官方给出的详细安装教程(<a href="https://github.com/nodejs/node-gyp#on-windows">https://github.com/nodejs/node-gyp#on-windows</a>)</p>
<h3 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h3><h4 id="检查Git和node-js安装情况"><a href="#检查Git和node-js安装情况" class="headerlink" title="检查Git和node.js安装情况"></a>检查Git和node.js安装情况</h4><p>安装Hexo需要git和node.js安装完成。检查电脑中这两项安装完成后，即可安装Hexo。可使用查看版本来检查是否安装成功。  </p>
<pre><code>$ npm -v  
$ node -v  
$ git --version  
</code></pre>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>上述安装成功后，只需要使用npm即可完成Hexo的安装  </p>
<pre><code>$ npm install -g hexo-cli  
</code></pre>
<p>对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包  </p>
<pre><code>$ npm install hexo
</code></pre>
<h4 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h4><p>依然使用查看版本号的方式检查安装是否成功，运行命令：  </p>
<pre><code>$ hexo - v
</code></pre>
<h4 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h4><pre><code>$ hexo init &lt;blogname&gt; #此处blogname可以自己起名字，此步要在空目录下进行
$ cd blog  #进入blog目录
$ npm install  #它会根据package.json依赖配置文件自动下载安装所需要的依赖模块node_modules
$ hexo generate  #生成静态文件, 缩写 $ hexo g
$ hexo server  #开启本地服务, 此时通过 http://localhost:4000 就可以访问默认样式的博客, 缩写$ hexo s
</code></pre>
<h4 id="小小的Debug"><a href="#小小的Debug" class="headerlink" title="小小的Debug"></a>小小的Debug</h4><p>安装时，显示在resolveNewModule步骤耗时很久，不知道是卡住还是这个步骤本就耗费时间。<br>Google找到Hexo的官方说明文档(<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a>)，其中提到安装只需要几分钟，并且这个几分钟可能包含前述的Git和Node.js的准备。因此意识到安装出现问题，直接停下此次安装并重新运行命令。<br>出现问题的原因可能是安装的同时在下载一个较大的文件，无论是内存占用还是网络占用都达到一定程度，使得Hexo的安装受到影响。二次运行命令行时，下载已经结束，只用时51s就完成安装。<br>多翻了几个教程，很多教程都有提到新建文件夹Hexo，在这个目录下安装Hexo。因此卸载Hexo，在目标位置建立文件夹重装。卸载命令：  </p>
<pre><code>$ npm uninstall hexo-cli -g
</code></pre>
<p>这次安装同样比较顺利，很快就完成。<br>实际上，如果在安装前没有建立文件夹，只需在安装成功后建立一个新目录，后续步骤在这个空目录下进行即可。上述uninstall步骤是因为比较心急，直接推翻重来，但没有必要。</p>
<h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><h3 id="git初始配置"><a href="#git初始配置" class="headerlink" title="git初始配置"></a>git初始配置</h3><p>Git安装完成后确认是否完成基本部署，用户名和邮箱设置是否完成。  </p>
<pre><code>$ git config --global user.name &quot;YOUR NAME&quot;  #设置用户名称
$ git config --global user.email &quot;YOUR EMAIL&quot;  #设置邮箱地址
</code></pre>
<h3 id="生成SSH-key公钥"><a href="#生成SSH-key公钥" class="headerlink" title="生成SSH key公钥"></a>生成SSH key公钥</h3><p>查看当前用户的目录下是否存在.ssh目录，如果存在进入到此目录下检查是否存在id_rsa和id_rsa.pub两个文件，这两个文件分别对应的是公钥和私钥，如果存在直接跳过此步，否则输入下面的命令：  </p>
<pre><code>$ ssh-keygen -t rsa -C “your_github_email”
# -t type:指定你要生成的密钥类型
# -C commit:提供一个新的注释  
</code></pre>
<p>然后一路回车，直到生成一个矩形的图案为止。记下生成的这串字符，这就是后面需要给GitHub配置的公钥。</p>
<h3 id="创建GitHub账号"><a href="#创建GitHub账号" class="headerlink" title="创建GitHub账号"></a>创建GitHub账号</h3><p>打开官网用邮箱一步步注册即可，仅有的两个可能遇到的问题:</p>
<ul>
<li>没想好用户名</li>
<li>确认注册的邮件因为有链接可能会被当作垃圾邮件。</li>
</ul>
<h3 id="配置GitHub中的公钥"><a href="#配置GitHub中的公钥" class="headerlink" title="配置GitHub中的公钥"></a>配置GitHub中的公钥</h3><p>在GitHub账号设置中找到添加SSH key的地方，即 <code>Settings -&gt; SSH and GPG keys -&gt; New SSH key</code> 将前述步骤中生成的公钥贴在此处  </p>
<h3 id="创建仓库-repository"><a href="#创建仓库-repository" class="headerlink" title="创建仓库(repository)"></a>创建仓库(repository)</h3><p>单机右上角(用户头像旁边)的“+”号即可创建New repository。<br>Owner 处为用户名，后面的 Repository name 需要严格按照 username.github.io 填写。这样才能保证生成的是 GitHub Pages 页面，而不是其它代码库。  </p>
<h3 id="GitHub-Pages-1"><a href="#GitHub-Pages-1" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><p>创建成功后会自动进入该 repository，进入 setting 找到 Pages，进入后即可看到 GitHub Pages 界面。<br>这一步骤可能需要一些时间，耐心等待，一般几分钟就会显示站点发布成功。</p>
<h4 id="小小的debug"><a href="#小小的debug" class="headerlink" title="小小的debug"></a>小小的debug</h4><p>第一次走到这一步时，此处有一句提醒，由于该 GitHub 仓库是空的，所以无法创建 GitHub Pages 站点。解决方式： </p>
<ul>
<li>可自己创建一个README文件</li>
<li>粗暴删库重来，建库时选择生成默认README文件  </li>
</ul>
<h2 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h2><h3 id="安装hexo-deployer-git"><a href="#安装hexo-deployer-git" class="headerlink" title="安装hexo-deployer-git"></a>安装hexo-deployer-git</h3><p>在博客根目录下运行命令  </p>
<pre><code>$ npm install hexo-deployer-git –save
</code></pre>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p><code>_config.yml</code> 是整个博客的配置文件，每项配置参数在Hexo官方文档可找到详细介绍。<br>使用git能将本地博客文件夹关联到GitHub的远程仓库，并把本地文件push到对应的仓库中。Hexo 提供了一种更简便地方式，只需要在 <code>_config.yml</code> 中作相应的配置，通过命令行命令就可以很方便地把静态文件部署到对应的仓库中。<br>找到根目录中的 <code>_config.yml</code> 博客配置文件，在deployment配置项下设置如下参数：  </p>
<pre><code>deploy:  
    type: git  
    repo: git@github.com:yourname/yourname.github.io.git  
    branch: master  
</code></pre>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre><code>$ hexo generate #生成本地静态文件，可缩写为hexo g
$ hexo deploy   #部署，可缩写为hexo d
</code></pre>
<p>这时回到GitHub仓库, 可以看到网站的静态文件已经上传。</p>
<h4 id="小小的Debug-1"><a href="#小小的Debug-1" class="headerlink" title="小小的Debug"></a>小小的Debug</h4><p>部署没有报错，但网站没有更新<br>原因：GitHub Pages默认是从main生成页面，但本地设置部署参数是 branch 一项中填写的是 master<br>Debug：修改该 repository 设置中 pages 的 source 一项,或将前面提到的修改博客配置文件的 branch 参数为 main</p>
<h3 id="一些有用的命令"><a href="#一些有用的命令" class="headerlink" title="一些有用的命令"></a>一些有用的命令</h3><pre><code>hexo clean = hexo c #清除本地缓存，也就是清除public/文件夹和db.json文件
hexo generate = hexo g #将souce文件夹下的Markdown和HTML文件解析到了public文件夹下，并生成了db.json文件
hexo server = hexo s #开启本地调试模式
hexo deploy = hexo d #将本地资源部署到GithubPages
</code></pre>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><p>Hexo的官网上即可找到许多可用主题，或搜索Hexo theme也可以找到。官网中列出的主题直达：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>找主题除了符合自己的审美之外，也要注意该主题是否一直有人维护。较长时间无人维护的主题可能由于版本问题无法顺利安装使用。</p>
<h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>本博客选择的主题是Next，安装步骤如下：<br>将主题clone到theme文件夹下</p>
<pre><code>$ cd blog
$ git clone https://github.com/next-theme/hexo-theme-next themes/next
</code></pre>
<p>然后在hexo配置文件中修改themes为next</p>
<pre><code>themes: next
</code></pre>
<h3 id="一些小改动"><a href="#一些小改动" class="headerlink" title="一些小改动"></a>一些小改动</h3><p>根据next的说明文件，可以在该主题的配置文件中对细节进行修改。<br>对博客名、描述以及作者等的修改在根目录的配置文件中进行。</p>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Building</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么这些东西每次都要现查啊！</title>
    <url>/2023/06/27/command/</url>
    <content><![CDATA[<center> 记录一下明明很常用也很有用但查了一百次还是记不住的一些命令 </center>
<span id="more"></span>

<br>

<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>拉取镜像：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull image:tag</span><br></pre></td></tr></table></figure>

<p>根据镜像创建一个容器运行：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it image:tag</span><br><span class="line"><span class="comment"># -i: 以交互模式运行容器，通常与 -t 同时使用；</span></span><br><span class="line"><span class="comment"># -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span></span><br></pre></td></tr></table></figure>

<p>但这种方式创建的容器会在使用 <code>exit</code> 退出时停止，并保留容器内容。可以利用 <code>docker run</code> 创建容器之后利用其它命令来运行、进入容器操作。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start containernumber</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it containernumber bash</span><br><span class="line"><span class="comment"># Keep STDIN open even if not attached</span></span><br><span class="line"><span class="comment"># Allocate a pseudo-TTY</span></span><br></pre></td></tr></table></figure>

<p>此时如果使用 <code>exit</code> 退出容器，则容器不会停止运行。  </p>
<p>停止容器：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop containernumber</span><br></pre></td></tr></table></figure>

<p>删除容器：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm containernumber</span><br></pre></td></tr></table></figure>

<p>删除镜像：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi image-id</span><br></pre></td></tr></table></figure>

<p>修剪镜像：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image prune -af</span><br><span class="line"><span class="comment"># -a: WARNING! This will remove:</span></span><br><span class="line">        <span class="comment"># - all stopped containers</span></span><br><span class="line">        <span class="comment"># - all volumes not used by at least one container</span></span><br><span class="line">        <span class="comment"># - all networks not used by at least one container</span></span><br><span class="line">        <span class="comment"># - all images without at least one container associated to them</span></span><br><span class="line"><span class="comment"># -f: 不确认直接删除</span></span><br></pre></td></tr></table></figure>

<p>列出镜像 / 容器：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show all images (default hides intermediate images)</span></span><br><span class="line">docker image ls -a</span><br><span class="line"><span class="comment"># Show all containers (default shows just running)</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>将容器中的文件拷贝到宿主机：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp containernumber:path/to/the/file.name path/to/the/host/file.name</span><br></pre></td></tr></table></figure>

<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>查看磁盘使用：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -hl <span class="comment"># 查看磁盘剩余空间</span></span><br><span class="line">df -h  <span class="comment"># 查看每个根路径的分区大小</span></span><br></pre></td></tr></table></figure>

<p>查看文件大小：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -lh</span><br><span class="line"><span class="comment"># -l: 以长格式显示文件和目录的列表，以字节为单位显示大小</span></span><br><span class="line"><span class="comment"># -h: 文件或目录大小大于 1024 字节时，请以人类可读的 KB、MB、GB 或 TB 来表示文件大小和目录大小</span></span><br></pre></td></tr></table></figure>

<p>统计文件数目：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l | grep <span class="string">&quot;^-&quot;</span> | wc -l    <span class="comment"># 统计当前目录下文件的个数（不包括目录）</span></span><br><span class="line">ls -lR| grep <span class="string">&quot;^-&quot;</span> | wc -l    <span class="comment"># 统计当前目录下文件的个数（包括子目录）</span></span><br><span class="line">ls -lR | grep <span class="string">&quot;^d&quot;</span> | wc -l   <span class="comment"># 查看某目录下文件夹(目录)的个数（包括子目录）</span></span><br></pre></td></tr></table></figure>

<p>文件取列：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cut -f columnnumber file.name</span><br><span class="line">cut -d <span class="string">&#x27;sep&#x27;</span> -f columnnumber file.name</span><br><span class="line"><span class="comment"># -d: 更改分隔符，默认为 tab</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>到底多少次才能学会使用 git</title>
    <url>/2024/06/07/basicgit/</url>
    <content><![CDATA[<center> 明明已经无数次从本地或服务器把代码备份到 GitHub，但还是记不住到底怎么做 </center>
<span id="more"></span>

<br>  

<h2 id="新建-repository"><a href="#新建-repository" class="headerlink" title="新建 repository"></a>新建 repository</h2><p>在 GitHub 上为想要上传的内容新建一个空 repository，连 <code>README.md</code> 都不要。没有什么特别的原因，只是我解决不了冲突，怎么改都不对，不如直接建个空库。  </p>
<h2 id="检查-git"><a href="#检查-git" class="headerlink" title="检查 git"></a>检查 git</h2><p>检查是否安装 <code>git</code>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure>

<p>输出应为 git 版本。如果提醒命令不存在，需要安装 git。<br>Mac 和 Linux 系统的电脑已经预装了git。Windows 系统的电脑可以从官网(<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> )下载相应的版本，安装过程中选择默认选项即可。  </p>
<h2 id="配置-git"><a href="#配置-git" class="headerlink" title="配置 git"></a>配置 git</h2><p>配置 Git 用户名和邮箱：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your.email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>打开代码所在的目录，并初始化一个新的Git仓库：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/code</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>在使用 Git 管理代码时，<code>git init</code> 命令用于在一个目录中初始化一个新的 Git 仓库。这个命令通常在你开始一个新的项目时使用，它会在当前目录创建一个 <code>.git</code> 文件夹，用来存储 Git 仓库的配置信息、对象数据库等。但是，并不是在所有情况下都必须执行 <code>git init</code>。<br>不需要执行 <code>git init</code>:  </p>
<ul>
<li>克隆现有仓库 (<code>git clone &lt;remote-url&gt;</code>)  </li>
<li>加入已有的仓库  </li>
<li>继承现有的 Git 仓库  </li>
</ul>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>检查当前 git 是否有远程库：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>如果已存在 origin，可以执行 <code>git remote remove origin</code> 后，再添加远程库。  </p>
<p>将第一步新建的 GitHub 库添加为远程库。假设 GitHub 库 URL 是 <code>https://github.com/yourusername/your-repo.git</code>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/yourusername/your-repo.git</span><br></pre></td></tr></table></figure>

<p>GitHub 已经不再支持使用密码进行身份验证，而是建议使用个人访问令牌 (Personal Access Token, PAT) 或 SSH 密钥进行身份验证。如果利用 PAT 进行身份验证，则需要执行：  </p>
<ol>
<li>登录到 GitHub 账户。  </li>
<li>点击右上角的头像，选择 “Settings”。  </li>
<li>在左侧菜单中选择 “Developer settings”。  </li>
<li>选择 “Personal access tokens” -&gt; “Tokens (classic)” -&gt; “Generate new token”。  </li>
<li>为令牌命名并选择所需的权限，通常选择 “repo” 就足够了。  </li>
<li>生成令牌并保存它，因为这是你唯一能看到它的机会。  </li>
</ol>
<p>然后在终端输入以下命令：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https://&lt;your_token&gt;@github.com/yourusername/your-repo.git</span><br></pre></td></tr></table></figure>

<p>将 <code>&lt;your_token&gt;</code> 替换为生成的 PAT。  </p>
<p>或在一开始添加仓库时，就使用包含 token 的链接：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://&lt;your_token&gt;@github.com/your_username/repository_name.git</span><br></pre></td></tr></table></figure>

<h2 id="添加文件并提交"><a href="#添加文件并提交" class="headerlink" title="添加文件并提交"></a>添加文件并提交</h2><p>添加所有文件并提交：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加当前目录下所有文件，也可添加指定文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit</span></span><br><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="撤回-commit-或-add"><a href="#撤回-commit-或-add" class="headerlink" title="撤回 commit 或 add"></a>撤回 commit 或 add</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不删除工作空间改动代码，撤销 commit，并且撤销 git add . 操作</span></span><br><span class="line">git reset --mixed HEAD^</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">git reset HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销 commit</span></span><br><span class="line"><span class="comment"># HEAD^的意思是上一个版本，也可以写成 HEAD~1</span></span><br><span class="line"><span class="comment"># 如果想撤回 2 次 commit，可以使用 HEAD~2</span></span><br><span class="line">git reset --soft HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作空间改动代码，撤销commit，撤销git add . </span></span><br><span class="line"><span class="comment"># 恢复到上一次 commit 后的状态</span></span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<h2 id="推送到远程库"><a href="#推送到远程库" class="headerlink" title="推送到远程库"></a>推送到远程库</h2><p>将代码推送到 GitHub 仓库：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取远程仓库中的内容，否则 push 时也会因为未同步远程仓库内容而失败</span></span><br><span class="line"><span class="comment"># 如果远程仓库为空，则不需要这一步</span></span><br><span class="line">git pull origin main --allow-unrelated-histories</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 commit 推送到远程仓库</span></span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tools</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>你这个SSL证书怎么总是过期啊</title>
    <url>/2024/02/14/certbot/</url>
    <content><![CDATA[<center> 各个站点的 SSL 证书又自动更新失败且过期了，记录一下每次都做点什么吧。 </center>
<span id="more"></span>

<br>

<p>自动更新没成功，只能手动申请证书，在 <code>/etc/nginx/sites-available/</code> 目录下执行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo certbot certonly --nginx -d domain.name</span><br></pre></td></tr></table></figure>

<p>不确定是不是必须在这个目录下，但每次我都是在这个目录下执行的，就这样吧。  </p>
<p>成功得到证书之后注意看一下新证书的路径，可能会有变化。如果有变化，要更新在 nginx 配置文件的相应位置，主要是 <code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 两个路径。然后运行如下代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 检查 nginx 配置语法是否正确</span><br><span class="line">nginx -t</span><br><span class="line"># nginx 配置无报错，重启 nginx</span><br><span class="line">systemctl reload nginx</span><br></pre></td></tr></table></figure>

<p>检查证书是否可以自动更新：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certbot renew --dry-run</span><br></pre></td></tr></table></figure>

<p>就是这一步，每次检查是否可以自动更新都没问题，但每次真的需要自动更新又会出问题🚬  </p>
]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Build</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>certbot</tag>
      </tags>
  </entry>
  <entry>
    <title>为博客添加评论区</title>
    <url>/2023/02/08/comments/</url>
    <content><![CDATA[<center> 给三个博客都加了评论区，记录一下分别做了什么 </center>
<span id="more"></span>

<br>

<h2 id="Bugrocery-Giscus"><a href="#Bugrocery-Giscus" class="headerlink" title="Bugrocery - Giscus"></a>Bugrocery - Giscus</h2><p>本博客的评论配置。  </p>
<p>参考：<a href="https://tech.konata.co/2022-02-20-add-comment-to-hexo/">给 Hexo 配置 Giscus 评论系统</a>  </p>
<p>安装插件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-next-giscus --save</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://giscus.app/zh-CN">giscus</a> 生成相关参数：  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">giscus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># Github repository name</span></span><br><span class="line">  <span class="attr">repo_id:</span> <span class="comment"># Github repository id</span></span><br><span class="line">  <span class="attr">category:</span> <span class="string">Announcements</span> <span class="comment"># Github discussion category</span></span><br><span class="line">  <span class="attr">category_id:</span> <span class="comment"># Github discussion category id</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">mapping:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: 0 | 1 </span></span><br><span class="line">  <span class="attr">reactions_enabled:</span> <span class="number">1</span></span><br><span class="line">   <span class="comment"># Available values: 0 | 1 </span></span><br><span class="line">  <span class="attr">emit_metadata:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Available values: light | dark | dark_high_contrast | transparent_dark | preferred-color-scheme</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">preferred_color_scheme</span></span><br><span class="line">  <span class="comment"># Available values: en | zh-C</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">en</span></span><br><span class="line">  <span class="comment"># Available value: anonymous</span></span><br><span class="line">  <span class="attr">crossorigin:</span> <span class="string">anonymous</span></span><br></pre></td></tr></table></figure>

<p>将上述内容添加到 <code>next</code> 主题 <code>_config.yml</code> 的 <code>comments</code> 部分。<br>教程中说放在博客的 <code>_config.yml</code> 文件中即可，但一直不生效，改到主题的配置文件中才成功。  </p>
<h2 id="−-273-15-℃-Waline"><a href="#−-273-15-℃-Waline" class="headerlink" title="− 273.15 ℃ - Waline"></a>− 273.15 ℃ - Waline</h2><p>生活博客的评论配置，该博客用 hugo + vercel 搭建，主题是 stack，该主题事先支持 Waline。  </p>
<p>参考：<a href="https://waline.js.org/guide/get-started/">Waline 快速上手</a>  </p>
<p>根据教程中提到的步骤，先在 <a href="https://console.leancloud.app/apps">LeanCloud 国际版</a>注册应用，再到 <a href="https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example">Vercel 部署</a>，最后修改主题配置文件中的 <code>comments</code> 部分。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">provider:</span> <span class="string">waline</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">waline:</span></span><br><span class="line">            <span class="attr">serverURL:</span> <span class="comment">#vercel 提供的仓库链接</span></span><br><span class="line">            <span class="attr">lang:</span></span><br><span class="line">            <span class="attr">visitor:</span></span><br><span class="line">            <span class="attr">avatar:</span> <span class="string">&#x27;monsterid&#x27;</span></span><br><span class="line">            <span class="attr">emoji:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo</span></span><br><span class="line">            <span class="attr">requiredMeta:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">name</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">email</span></span><br><span class="line">            <span class="attr">placeholder:</span></span><br><span class="line">            <span class="attr">locale:</span></span><br><span class="line">                <span class="attr">admin:</span> <span class="string">Admin</span></span><br></pre></td></tr></table></figure>

<h2 id="Sparkles-Club-Valine-amp-Disqus"><a href="#Sparkles-Club-Valine-amp-Disqus" class="headerlink" title="Sparkles Club - Valine &amp; Disqus"></a>Sparkles Club - Valine &amp; Disqus</h2><p>存文博客的评论配置，该博客使用 hugo + vercel 搭建，主题是 LoveIt，该主题事先支持 Valine。 </p>
<p>参考：<a href="https://mantyke.icu/posts/2021/comment/">Hugo | 为 Blog 增加评论区</a>  </p>
<p>根据教程中提到的步骤，先在 <a href="https://console.leancloud.app/apps">LeanCloud 国际版</a>注册应用，再到配置文件 <code>config.toml</code> 中修改 Valine 的部分，填入 LeanCloud 应用的 <code>appID</code> 和 <code>appKey</code>。其它参数修改可参考：<a href="https://valine.js.org/configuration.html">valine 配置项</a>  </p>
<p>但目前没有生效，不知道原因。  </p>
<p>看到多处提到 Valine 的安全性不高，因此改为另一个主题已经支持的评论系统，<a href="https://disqus.com/">disqus</a>。注册账号，为网站创建评论。一步步进行之后，到配置文件中修改以下部分：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[params.page.comment]</span><br><span class="line">      enable = true</span><br><span class="line">      # Disqus comment config (https://disqus.com/)</span><br><span class="line">      # Disqus 评论系统设置 (https://disqus.com/)</span><br><span class="line">      [params.page.comment.disqus]</span><br><span class="line">        enable = true</span><br><span class="line">        # Disqus shortname to use Disqus in posts</span><br><span class="line">        # Disqus 的 shortname，用来在文章中启用 Disqus 评论系统</span><br><span class="line">        shortname = &quot;&quot; # 填入 Disqus 给出的 shortname</span><br></pre></td></tr></table></figure>

<p>很顺利配置完成，但成功后才发现这个方法需要登录才能评论，但反正也没人用，改不改的以后再说。  </p>
<h2 id="Sparkles-Club-Waline"><a href="#Sparkles-Club-Waline" class="headerlink" title="Sparkles Club - Waline"></a>Sparkles Club - Waline</h2><p>终于找到时间更新一下这个需要登录的评论区了！<br>参考：<a href="https://lewky.cn/posts/hugo-3.1.html/">Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章</a>  </p>
<p>根据教程先在 <a href="https://console.leancloud.app/apps">LeanCloud 国际版</a>注册应用，再到 <a href="https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example">Vercel 部署</a>，最后修改主题配置文件中的 <code>comment</code> 相关的部分。  </p>
<p>修改博客配置文件时，配置中与强制登陆相关的内容被我注释掉。本来就是为了不登录用，再搞个强制登录干嘛！  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Waline comment config (https://waline.js.org/)</span><br><span class="line"># Waline 评论系统设置 (https://waline.js.org/)</span><br><span class="line">[params.page.comment.waline]</span><br><span class="line">  enable = true</span><br><span class="line">  #js = &quot;https://cdn.jsdelivr.net/npm/@waline/client@latest&quot;</span><br><span class="line">  js = &quot;https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js&quot;</span><br><span class="line">  meta = [&#x27;nick&#x27;,&#x27;mail&#x27;,&#x27;link&#x27;]                           # 评论者相关属性</span><br><span class="line">  requiredMeta = [&#x27;nick&#x27;]                                 # 设置必填项，默认匿名，相比教程取消了邮箱为必填项</span><br><span class="line">  # login = &quot;force&quot;                                       # 不必登录</span><br><span class="line">  # placeholder = &quot;为防恶意灌水攻击，评论前需注册并登录，望见谅~&quot;     # 不登录所以这条没用了</span><br><span class="line">  serverURL = &quot;&quot;                                          # Waline的服务端地址（必填），vercel 给的地址</span><br><span class="line">  #imageHosting =                                         # 图床api，如果允许评论框上传图片</span><br><span class="line">  uploadImage = false                                     # 评论上传图片功能</span><br><span class="line">  avatar = &quot;retro&quot;                                        # Gravatar头像</span><br><span class="line">  avatarCDN = &quot;https://sdn.geekzu.org/avatar/&quot;            # Gravatar头像CDN地址，不建议使用loli源</span><br><span class="line">  pageSize = 20                                           # 评论列表分页，每页条数</span><br><span class="line">  lang = &quot;zh-CN&quot;                                          # 多语言支持</span><br><span class="line">  visitor = true                                          # 文章访问量统计</span><br><span class="line">  highlight = true                                        # 代码高亮</span><br></pre></td></tr></table></figure>

<p>“添加评论统计到文章元数据” 一步中要求把 <code>/themes/LoveIt/layouts/posts/single.html</code> 拷贝到 <code>/layouts/posts/single.html</code>，但我的博客系统中没有 <code>/layouts/posts/</code> 这一路径。新建了路径把文件拷贝进去，并修改相关内容。因为不放心，把原本在主题内的 <code>single.html</code> 里的相关内容也改成了教程中提到的东西。  </p>
<p>把更新内容推送到 github 之后，评论区火速生效！终于不用登录也可以评论了！！  </p>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Building</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Hugo</tag>
        <tag>Comments</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 1：the basic</title>
    <url>/2022/03/14/computernetworknotes1/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络第一章计算机网络概述自学笔记 </center>
<span id="more"></span>

<br>

<h2 id="课程来源"><a href="#课程来源" class="headerlink" title="课程来源"></a>课程来源</h2><p>bilibili 网课：<a href="https://www.bilibili.com/video/BV1JV411t7">中科大郑烇、杨坚全套《计算机网络》</a>  </p>
<br>  

<h2 id="什么是-Internet"><a href="#什么是-Internet" class="headerlink" title="什么是 Internet"></a>什么是 Internet</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>由节点和边构成的拓扑结构  </p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>联网的计算机所构成的系统，包括主机节点 (数据源或数据目标)、数据交换节点 (路由器、中继器、交换机等)、链路  </p>
<ul>
<li>节点  <ul>
<li>主机及其上运行的应用程序  </li>
<li>路由器、交换机等网络交换设备  </li>
</ul>
</li>
<li>边：通信链路  <ul>
<li>接入网链路：主机连接到互联网的链路  </li>
<li>主干链路：路由器间链路  </li>
</ul>
</li>
<li>协议  <ul>
<li>对等层实体在通信过程中，应该遵守的规则的集合，包括语义、语法和时序  </li>
</ul>
</li>
</ul>
<h3 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h3><p>数以亿计的、互联的计算设备  </p>
<ul>
<li>主机 = 端系统：end system / host  </li>
<li>运行网络应用程序</li>
</ul>
<p>通信链路  </p>
<ul>
<li>光纤、同轴电缆、无线电、卫星  </li>
<li>传输速率 = 带宽 (bps)  </li>
</ul>
<p>分组交换设备：转发分组 (packets)  </p>
<ul>
<li>路由器和交换机</li>
</ul>
<h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><p>TCP、IP 协议建立起的一个网络，也是一种计算机网络。  </p>
<ul>
<li>协议控制发送、接收消息：TCP、IP、HTTP、FTP、PPP 等  </li>
<li>网络的网络：松散的层次结构，互连的 ISP；公共 Internet vs 专用 intranet  </li>
<li>标准：RFC (Request For Comments)；IETF(Internet Engineering Task Force)  </li>
</ul>
<p><strong>协议</strong>定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和/或接收或其他事件方面所采取的动作。  </p>
<p>从服务角度理解 Internet</p>
<ul>
<li>使用通信设施进行通信的分布式应用：Web、VoIP、email、分布式游戏、电子商务、社交网络  </li>
<li>通信基础设施为 apps 提供编程接口 (通信服务)：将发送和接收数据的 apps 与互联网连接起来；为 apps 提供服务选择，类似于邮件服务，包括无连接不可靠服务和面向连接的可靠服务  </li>
</ul>
<br>  

<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>网络边缘 (edge)  </p>
<ul>
<li>主机  </li>
<li>应用程序：客户端和服务器  </li>
</ul>
<p>网络核心 (core)：数据交换  </p>
<ul>
<li>互连着的路由器  </li>
<li>网络的网络  </li>
</ul>
<p>接入网、物理媒体 (access)  </p>
<ul>
<li>有线或无线通信链路  </li>
</ul>
<h3 id="网络边缘-1"><a href="#网络边缘-1" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>端系统 (主机)：运行应用程序，如 Web、Email，在“网络的边缘”  </p>
<p>客户/服务模式  </p>
<ul>
<li>一种主从模式，可扩展性、可靠性有问题  </li>
<li>客户端向服务器请求、接收服务，如 Web 浏览器/服务器，Email 客户端/服务器  </li>
</ul>
<p>对等 (peer - peer) 模式  </p>
<ul>
<li>每个节点既是客户端有时服务器  </li>
<li>分布式的文件系统  </li>
<li>很少 (甚至没有) 专门的服务器，如 Gmutella、KaZaA、Emule、迅雷、电驴  </li>
</ul>
<h4 id="面向连接的通信服务"><a href="#面向连接的通信服务" class="headerlink" title="面向连接的通信服务"></a>面向连接的通信服务</h4><p>采用网络设施的面向连接服务  </p>
<p><strong>目标</strong>：在端系统之间传输数据  </p>
<ul>
<li>“握手”：在数据传输之前做好准备，为通信准备好相应的资源、设置  </li>
<li>两个通信主机之间为连接建立状态，端系统维护连接，只有端系统“知道”连接  </li>
</ul>
<p><strong>TCP (Transmission Control Protocol) 传输控制协议</strong> [RFC 793]  </p>
<ul>
<li>Internet 上面向连接的服务  </li>
<li>使用 TCP 的应用：HTTP (Web)、FTP (文件传输)、Telnet (远程登陆)、SMTP (Email)  </li>
<li><strong>可靠地、按顺序地传送数据</strong>：确认和重传  </li>
<li><strong>流量控制</strong>：平衡发送方和接收方，发送方不会淹没接收方  </li>
<li><strong>拥塞控制</strong>：了解网络路径情况，当网络拥塞时，发送方降低发送速率  </li>
</ul>
<h4 id="采用基础设施的无连接服务"><a href="#采用基础设施的无连接服务" class="headerlink" title="采用基础设施的无连接服务"></a>采用基础设施的无连接服务</h4><p>目标  </p>
<ul>
<li>在端系统之间传输数据  </li>
<li>无连接服务：直接发送，不打招呼  </li>
</ul>
<p><strong>UDP (User Datagram Protocol) 用户数据报协议</strong> [RFC 768]</p>
<ul>
<li>无连接  </li>
<li>不可靠数据传输  </li>
<li>无流量控制  </li>
<li>无拥塞控制  </li>
<li>使用 UDP 的应用：流媒体、远程会议、DNS、Internet 电话  </li>
</ul>
<br>  

<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>路由器的网状网络  </p>
<h3 id="通过网络传输数据的方式"><a href="#通过网络传输数据的方式" class="headerlink" title="通过网络传输数据的方式"></a>通过网络传输数据的方式</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>为每个预叫预留一条专有电路，如电话网  </p>
<p><img src="/2022/03/14/computernetworknotes1/dianlujiaohuan.png" alt="电路交换">  </p>
<p>为呼叫预留端-端资源  </p>
<ul>
<li>链路带宽，交换能力  </li>
<li>专用资源：不共享  </li>
<li>保证性能  </li>
<li>要求建立呼叫链接  </li>
</ul>
<p>网络资源 (如带宽) 被分成片  </p>
<ul>
<li>可频分 (Frequency-division multiplexing, FDM)，称频段；可时分 (Time-division multiplexing, TDM)，称时间周期片；可波分 (Wave-division multiplexing, WDM)，称波段  </li>
<li>为呼叫分配片  </li>
<li>如果某个呼叫没有数据，则其资源片处于空闲状态 (不共享)  </li>
</ul>
<p>特点  </p>
<ul>
<li>连接建立时间长  </li>
<li>计算机之间的通信具有突发性，若使用电路交换则浪费片较多  </li>
<li>可靠性不高 (维护 piece 间的 mapping 关系，若核心节点损毁则会造成大面积瘫痪)  </li>
</ul>
<h4 id="分组交换-packet-switch"><a href="#分组交换-packet-switch" class="headerlink" title="分组交换 (packet switch)"></a>分组交换 (packet switch)</h4><p>简介  </p>
<ul>
<li>将要传输的数据分成一个个单位：分组  </li>
<li>将分组从一个路由器传到一个相邻的路由器 (hop)，一段段最终从源端到目标端  </li>
<li>每段：采用链路的最大传输能力 (带宽)  </li>
</ul>
<p>以分组为单位存储 - 转发方式  </p>
<ul>
<li>网络带宽资源不再分为一个个片，传输时使用全部带宽  </li>
<li>主机之间传输的数据被分为一个个分组  </li>
</ul>
<p>资源共享，按需使用  </p>
<ul>
<li>存储 - 转发：分组每次移动一跳 (hop)  </li>
<li>在转发之前，节点必须收到整个分组  </li>
<li>延迟比线路交换大有排队时间<br><em>如果到达速率 &gt; 链路的输出速率，分组将会排队，等待传输；如果路由器缓存使用完，分组将被会抛弃。</em>  </li>
</ul>
<p>网络核心的关键功能  </p>
<ul>
<li><strong>路由</strong>：决定分组采用的源到目标的路径 (路由算法)  </li>
<li><strong>转发</strong>：将分组从路由器的输入链路转移到输出链路  </li>
</ul>
<p>分组交换的分组没有固定模式，即统计多路复用。  </p>
<h4 id="分组交换-vs-电路交换"><a href="#分组交换-vs-电路交换" class="headerlink" title="分组交换 vs 电路交换"></a>分组交换 vs 电路交换</h4><ul>
<li>分组交换允许更多用户使用网络<br><img src="/2022/03/14/computernetworknotes1/switchcompare.png" alt="分组交换与电路交换对比">  </li>
</ul>
<center> *网络强度为 1 时，网络会挂，所以分组交换时用户数不能为 10* </center>  

<ul>
<li>分组交换更适合于突发式数据传输：资源共享；简单，不必建立呼叫  </li>
<li>过度使用会造成网络拥堵：分组延时和丢失；对可靠的数据传输需要协议来约束 (拥塞控制)  </li>
</ul>
<h3 id="分组交换网络"><a href="#分组交换网络" class="headerlink" title="分组交换网络"></a>分组交换网络</h3><p>分组的存储 - 转发一段一段从源端传到目标端，按照有无网络层的连接分成：<br>(1) 数据报 (datagram) 网络  </p>
<ul>
<li>分组的目标地址决定下一跳  </li>
<li>在不同的阶段，路由可以改变  </li>
<li>即无连接，每一份都独立传送<ul>
<li>通信之前无需建立连接，有数据就传输</li>
<li>每一个分组都独立路由 (路径不一样，可能会失序)  </li>
<li>路由器根据分组的目标地址进行路由</li>
</ul>
</li>
<li>类似：问路  </li>
<li>eg. Internet  </li>
</ul>
<p>(2) 虚电路 (virtual circuit) 网络  </p>
<ul>
<li>每个分组都带标签，虚电路标识 VC ID，标签决定下一跳  </li>
<li>在呼叫建立时决定路径，在整个呼叫中路径保持不变  </li>
<li>路由器维护每个呼叫的状态信息  </li>
<li>即建立网络层的连接，每个交换节点中有相应标识  </li>
<li>eg. X.25 和 ATM  </li>
</ul>
<br>  

<h2 id="接入网和物理媒体"><a href="#接入网和物理媒体" class="headerlink" title="接入网和物理媒体"></a>接入网和物理媒体</h2><h3 id="接入网：怎样将端系统和边缘路由端链接"><a href="#接入网：怎样将端系统和边缘路由端链接" class="headerlink" title="接入网：怎样将端系统和边缘路由端链接"></a>接入网：怎样将端系统和边缘路由端链接</h3><ul>
<li>住宅接入网络  </li>
<li>单位接入网络：学校、公司  </li>
<li>无线接入网络  </li>
</ul>
<p><strong>重要指标</strong>：带宽、共享/专用</p>
<h4 id="住宅接入-modem"><a href="#住宅接入-modem" class="headerlink" title="住宅接入 (modem)"></a>住宅接入 (modem)</h4><p>将上网数据<strong>调制</strong>加载在音频信号上 (能保证的带宽只有 4 kHz)，在电话线上传输，在局端将其中的数据<strong>解调</strong>出来；反之亦然。  </p>
<ul>
<li>调频  </li>
<li>调幅  </li>
<li>调相位  </li>
<li>综合调制  </li>
</ul>
<p><strong>拨号调制解调器</strong>  </p>
<ul>
<li>56 Kbps 的速率直接接入路由器 (通常更低)  </li>
<li>不能同时上网和打电话，且不能总是在线  </li>
<li>利用已有的线路</li>
</ul>
<p><strong>Digital Subscribe Line (DSL)：</strong>采用现存的到交换局 DLSAM 的电话线  </p>
<ul>
<li>语音、数据在专享线路的不同波段传播</li>
<li>DSL 线路上的数据波传到互联网 (&gt; 4 kHz，上下传输带宽分布不均时称为 ADSL)  </li>
<li>DSL 线路上的数据波传到电话网 (&lt; 4 kHz)  </li>
<li>传输速率<ul>
<li>&lt; 2.5 Mbps 上行传输速率 (typically &lt; 1 Mbps)  </li>
<li>&lt; 24 Mbps 下行传输速率 (typically &lt; 10 Mbps)  </li>
</ul>
</li>
</ul>
<p><strong>线缆网络</strong>  </p>
<ul>
<li>有线电视信号线缆双向改造  </li>
<li><strong>FDM</strong>：在不同频段传输不同信道的数据，包括数字电视和上网数据 (上下行)  </li>
<li>类似的也可以使用电网  </li>
<li>HFC (Hybrid Fiber Coax)：非对称，最高 30 Mbps 的下行传输速率，2 Mbps 上行传输速率  </li>
<li>线缆和光纤网络将各个家庭用户接入到 ISP 路由器</li>
<li>个用户<strong>共享</strong>到线缆头端的接入网络 (与 DSL 不同，DSL 每个用户一个专用线路到 CO (Central Office))  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/modem.png" alt="住宅接入：电缆模式">  </p>
<br>  

<p><img src="/2022/03/14/computernetworknotes1/housenetwork.png" alt="接入网：家庭网络">  </p>
<h4 id="企业接入网络-Ethernet"><a href="#企业接入网络-Ethernet" class="headerlink" title="企业接入网络 (Ethernet)"></a>企业接入网络 (Ethernet)</h4><p>经常被弃业或大学等机构采用</p>
<ul>
<li>10 Mbps，100 Mbps，1 Gbps，10 Gbps 传输率  </li>
<li>现在端系统经常直接接到以太网络交换机上  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/Ethernet.png" alt="企业接入网络">  </p>
<h4 id="无线接入网络"><a href="#无线接入网络" class="headerlink" title="无线接入网络"></a>无线接入网络</h4><p>各无线端系统共享无线接入网络 (端系统到无线路由器)  </p>
<ul>
<li>通过基站或接入点  </li>
</ul>
<p>无线 LANs  </p>
<ul>
<li>建筑物内部 (100 ft)  </li>
<li>802.11 b/g (WiFi)：11，54 Mbps 传输速率  </li>
</ul>
<p>广域无线接入  </p>
<ul>
<li>由电信运营商提供 (Cellular)：10’s km  </li>
<li>1 到 10 Mbps  </li>
<li>3 G，4 G：LTE</li>
</ul>
<h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><ul>
<li>Bit：在传输-接收对间传播  </li>
<li>物理链路：在每个传输-接收对间跨越的一种物理媒体  </li>
<li>导引型媒体：信号沿着固体媒介被导引，如同轴电缆、光纤、双绞线  </li>
<li>非导引型媒体：信号自由传播，如无线电  </li>
</ul>
<h4 id="双绞线-TP"><a href="#双绞线-TP" class="headerlink" title="双绞线 (TP)"></a>双绞线 (TP)</h4><ul>
<li>两根绝缘铜线  </li>
<li>5 类：100 Mbps Ethernet、Gbps 以太网  </li>
<li>6 类：10 Gbps </li>
</ul>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><ul>
<li>两根同心的铜导线  </li>
<li>双向  </li>
<li>基带电缆<ul>
<li>电缆上一个单个信道</li>
<li>Ethernet</li>
</ul>
</li>
<li>宽带电缆<ul>
<li>电缆上有多个信道</li>
<li>HFC</li>
</ul>
</li>
</ul>
<h4 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h4><ul>
<li>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输  </li>
<li>高速：点到点的告诉传输，如 10 Gbps ~ 100 Gbps 传输速率  </li>
<li>低误码率：在两个中继器之间可以有很长的距离，不受电磁噪声的干扰  </li>
<li>安全：全反射或垂直 (射入角度为零)；单模光纤或多模光纤  </li>
</ul>
<h4 id="无线链路"><a href="#无线链路" class="headerlink" title="无线链路"></a>无线链路</h4><ul>
<li>开放空间传输电磁波，携带要传输的数据  </li>
<li>无需物理“线缆”  </li>
<li>双向  </li>
<li>传播环境效应：反射、吸收、干扰  </li>
<li>类型  <ul>
<li>地面微波：up to 45 Mbps channels  </li>
<li>LAN：WiFi；11 Mbps，54 Mbps，540 Mbps 等  </li>
<li>wide area：蜂窝；3 G cellular (~ few Mbps)；4 G 10 Mbps；5 G 数 Gbps  </li>
<li>卫星：每个信道 Kbps 到 45 Mbps，或者多个聚集信道；270 msec 端到端延迟 (延迟大)；同步静止卫星和低轨卫星  </li>
</ul>
</li>
</ul>
<br>  

<h2 id="Internet-结构和-ISP"><a href="#Internet-结构和-ISP" class="headerlink" title="Internet 结构和 ISP"></a>Internet 结构和 ISP</h2><h3 id="互联网络结构：网络的网络"><a href="#互联网络结构：网络的网络" class="headerlink" title="互联网络结构：网络的网络"></a>互联网络结构：网络的网络</h3><p>端系统通过接入 ISPs (Internet Service Providers) 连接到互联网  </p>
<ul>
<li>住宅、公司和大学的 ISPs  </li>
</ul>
<p>接入 ISPs 相应的必须是互联的，因此任何两个端系统可相互发送分组到对方。<br>导致“网络的网络”非常复杂，发展和演化通过经济和国家政策来驱动。  </p>
<h3 id="接入-ISPs-的连接方式"><a href="#接入-ISPs-的连接方式" class="headerlink" title="接入 ISPs 的连接方式"></a>接入 ISPs 的连接方式</h3><p>接入 ISPs 之间全连接：即将每两个 ISPs 直接相连，不可扩展，需要 O(n<sup>2</sup>) 连接  </p>
<p>将每个接入 ISP 都连接到<strong>全局 ISP</strong> (全局范围内覆盖)：客户 ISPs 和提供者 ISPs 有经济合约  </p>
<p><img src="/2022/03/14/computernetworknotes1/globalISP.png" alt="将每个接入 ISP 都连接到全局 ISP">  </p>
<p>如果全局 ISP 事可行的业务，则一定会有不同公司<strong>竞争</strong>；通过 ISP 之间的<strong>合作</strong>可以完成业务的扩展，肯定会有互联，对等互联的结算关系  </p>
<p><img src="/2022/03/14/computernetworknotes1/ISPpeerlink.png" alt="ISP 竞争与合作"></p>
<p>业务细分 (全球接入和区域接入)，<strong>区域网络</strong>将出现，用于将接入 ISPs 连接到全局 ISPs  </p>
<p><img src="/2022/03/14/computernetworknotes1/regionalnet.png" alt="局域网络">  </p>
<p><strong>内容提供商网络</strong> (Internet Content Provider, eg. Google, Microsoft, Akamai) 可能会构建它们自己的网络，将它们的服务、内容更加靠近端用户，向用户提供更好的服务，减少自己的运营支出</p>
<ul>
<li>在全球各地部署自己的网络 (或靠近核心 ISP)，连接自己的数据中心机房 (Data Center)，走自己的数据  </li>
<li>连接若干 local ISP 和各级 (包括一层) ISP，更加靠近用户  </li>
<li>少付费，且用户访问更快</li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/CPN.png" alt="内容提供商网络">  </p>
<p>在网络的最中心，有一些为数不多的充分连接大范围网络 (分布广、节点有限，但之间有多重连接)  </p>
<ul>
<li>“tier-1” commercial ISPs (eg. Level 3, Sprint, AT &amp; T, NTT)，国家或者国际的覆盖范围  </li>
<li>content provider network (eg. Google)：将数据中心接入 ISP，方便周边用户的访问；通常私有网络之间用专网绕过第一层 ISP 和区域 ISPs  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/Internetstructure.png" alt="互联网络结构：网络的网络">  </p>
<h3 id="Internet-的结构：松散的层次结构"><a href="#Internet-的结构：松散的层次结构" class="headerlink" title="Internet 的结构：松散的层次结构"></a>Internet 的结构：松散的层次结构</h3><p><strong>中心：第一层 ISP</strong> (如 UUNet，BBN/Genuity，Sprint，AT &amp; T) 国家/国际覆盖，速率极高  </p>
<ul>
<li>直接于其它第一层 ISP 相连  </li>
<li>与大量的第二层 ISP 和其它客户网络相连  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/POP.png" alt="Sprint: point-of-presence">  </p>
<p>second.png：更小些的 (通常是局域性的) ISP  </p>
<ul>
<li>与一个或多个第一层 ISPs 相连，也可能于其它第二层 ISP  </li>
<li>通过合作拓展网络  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/second.png" alt="第二层 ISP">  </p>
<p>第三层 ISP 与其它本地 ISP  </p>
<ul>
<li>接入网 (与端系统最近)  </li>
<li>一个分组要经过许多网络  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/third.png" alt="第三层 ISP">  </p>
<h3 id="ISP-之间的连接"><a href="#ISP-之间的连接" class="headerlink" title="ISP 之间的连接"></a>ISP 之间的连接</h3><p><strong>POP</strong>  </p>
<ul>
<li>高层 ISP 面向客户网络的接入点，涉及费用结算  </li>
<li>多宿 (multi home)：一个低层 ISP 接入多个高层 ISP  </li>
</ul>
<p><strong>对等接入</strong>  </p>
<ul>
<li>2 个 ISP 对等互接，不涉及费用结算  </li>
</ul>
<p><strong>IXP</strong>  </p>
<ul>
<li>多个对等 ISP 互联互通之外，通常不涉及费用结算  </li>
<li>对等接入  </li>
</ul>
<p><strong>ICP</strong>  </p>
<ul>
<li>自己部署的专用网络</li>
<li>同时和各级 ISP 连接  </li>
</ul>
<br>  

<h2 id="分组延时、丢失和吞吐量"><a href="#分组延时、丢失和吞吐量" class="headerlink" title="分组延时、丢失和吞吐量"></a>分组延时、丢失和吞吐量</h2><h3 id="分组丢失和延时如何产生"><a href="#分组丢失和延时如何产生" class="headerlink" title="分组丢失和延时如何产生"></a>分组丢失和延时如何产生</h3><p>在路由器缓冲区的分组队列  </p>
<ul>
<li>分组到达链路的速率超过了链路输出的能力  </li>
<li>分组等待排到队头、被传输  </li>
<li>缓冲区满，无法进入路由器  </li>
</ul>
<p><img src="/2022/03/14/computernetworknotes1/queueNdelay.png" alt="分组延时和丢失">  </p>
<h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a>分组延时</h3><p>(1) 节点处理延时</p>
<ul>
<li>检查 bit 级差错  </li>
<li>检查分组首部和决定将分组导向何处  </li>
</ul>
<p>(2) 排队延时</p>
<ul>
<li>在输出链路上等待传输的时间  </li>
<li>依赖于路由器的拥塞控制  </li>
</ul>
<p>(3) 传输延时</p>
<ul>
<li>R = 链路带宽 (bps)  </li>
<li>L = 分组长度 (bits)  </li>
<li>将分组发送到链路上的时间 = L / R  </li>
<li>存储转发延时  </li>
</ul>
<p>(4) 传播延时</p>
<ul>
<li>d = 物理链路的长度</li>
<li>s = 在媒体上的传播速度 (~ 2 x 10<sup>8</sup> m / sec)  </li>
<li>传播延时 = d / s  </li>
</ul>
<p><em>R and s are very differential quantities</em>  </p>
<p><img src="/2022/03/14/computernetworknotes1/delay.png" alt="四种分组延时"></p>
<p><img src="/2022/03/14/computernetworknotes1/carqueue.png" alt="分组延时与车队类比">  </p>
<p><img src="/2022/03/14/computernetworknotes1/carqueue2.png" alt="分组延时与车队类比">   </p>
<p><em>信道容量大，可容纳的分组数量多</em>  </p>
<h3 id="节点延时"><a href="#节点延时" class="headerlink" title="节点延时"></a>节点延时</h3><p><img src="/2022/03/14/computernetworknotes1/delaytime.png">  </p>
<h3 id="排队延时"><a href="#排队延时" class="headerlink" title="排队延时"></a>排队延时</h3><ul>
<li><p>R = 链路带宽 (bps)  </p>
</li>
<li><p>L = 分组长度 (bits)  </p>
</li>
<li><p>a = 分组到达队列的平均速率  </p>
</li>
<li><p>流量强度 I = La / R  </p>
<ul>
<li>La / R ~ 0：平均排队延时很小  </li>
<li>La / R -&gt; 1：延时变得很大  </li>
<li>La / R &gt; 1：比特到达队列的速率超过了从该队列输出的速率，平均排队延时将趋向无穷大  </li>
</ul>
<p><em>设计系统时流量强度不能大于1</em>  </p>
<p><img src="/2022/03/14/computernetworknotes1/queuedelay.png"></p>
</li>
</ul>
<h3 id="Internet-的延时和路由"><a href="#Internet-的延时和路由" class="headerlink" title="Internet 的延时和路由"></a>Internet 的延时和路由</h3><p><strong>Traceroute 诊断程序</strong>：提供从源端，经过路由器，到目的的延时测量  </p>
<ul>
<li>For all <em>i</em>：<ul>
<li>沿着目的的路径，像每个路由器发送 3 个探测分组  </li>
<li>路由器 <em>i</em> 将向发送方返回一个分组  </li>
<li>发送方队发送和回复之间间隔计时  </li>
</ul>
</li>
<li>ICMP 协议  </li>
</ul>
<h3 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h3><p>链路的队列缓冲区容量有限<br>当分组到达一个满的队列时，该分组将会丢失<br>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传  </p>
<p><img src="/2022/03/14/computernetworknotes1/packagelost.png" alt="分组丢失">  </p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>在源端和目标端之间传输的速度 (数据量 / 单位时间)<br>有效的数量，要从源端确实到达目标端<br>源到端的吞吐量取决于路径上的最小吞吐量，即<strong>瓶颈链路</strong>的吞吐量<br>瓶颈链路：端到端路径上，限制端到端吞吐的链路<br><strong>瞬间吞吐量</strong>：在一个时间点的速率<br><strong>平均吞吐量</strong>：在一个长时间内平均值  </p>
<p><img src="/2022/03/14/computernetworknotes1/tuntuliang.png" alt="吞吐量">  </p>
<p><img src="/2022/03/14/computernetworknotes1/tuntuliang2.png" alt="吞吐量：互联网场景">  </p>
<br>

<h2 id="协议层次和服务模型"><a href="#协议层次和服务模型" class="headerlink" title="协议层次和服务模型"></a>协议层次和服务模型</h2><h3 id="网络是一个复杂系统"><a href="#网络是一个复杂系统" class="headerlink" title="网络是一个复杂系统"></a>网络是一个复杂系统</h3><p><strong>网络功能繁杂</strong>：数字信号的物理信号承载、点到点、路由、rdt、进程区分、应用等<br><strong>网络有许多构成元素和设备</strong>：主机、路由器、各种媒体的链路、应用、协议、硬件、软件等<br>如何规划这样一个复杂系统：模块化、<strong>层次化</strong></p>
<h3 id="层次化方式实现复杂网络功能"><a href="#层次化方式实现复杂网络功能" class="headerlink" title="层次化方式实现复杂网络功能"></a>层次化方式实现复杂网络功能</h3><p>将网络复杂的功能分层功能明确的<strong>层次</strong>，每一层实现了其中一个或一组<strong>功能</strong>，功能中有其上层可以使用的功能：<strong>服务</strong><br>本层协议实体相互交互执行本层的<strong>协议动作</strong>，目的是实现本层功能，通过接口为上层提供更好的服务<br>在实现本层协议时，直接<strong>利用下层所提供的服务</strong><br>本层的服务：借助下层服务实现的本层协议实体之间交互带来的 (上层可以利用的) 新功能 + 更下层所提供的服务  </p>
<h3 id="服务和服务访问点"><a href="#服务和服务访问点" class="headerlink" title="服务和服务访问点"></a>服务和服务访问点</h3><p><strong>服务 (Service)：</strong>低层实体向上层实体提供它们之间通信的能力  </p>
<ul>
<li>服务用户 (service user)  </li>
<li>服务提供者 (service provider)  </li>
</ul>
<p><strong>原语 (primitive)：</strong>上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的 —— <strong>提供服务的形式</strong>  </p>
<p><strong>服务访问点 SAP (Services Access Point)：</strong>上层使用下层提供的服务通过层间的接口 —— <strong>提供服务的地点</strong>  </p>
<ul>
<li>eg. 邮箱  </li>
<li>地址 (address)：下层的一个实体支撑着上层的多个实体，SAP 有标志不同上层实体的作用  </li>
<li>可以有不同的实现，队列  </li>
<li>eg. 传输层的 SAP：端口 (port)<br><em>区分数据要从哪里传到哪里，服务提供者区分不同的服务用户，层间接口</em></li>
</ul>
<h3 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h3><p><strong>面向连接的服务 (Connection-oriented Service)</strong>  </p>
<ul>
<li>连接 (Connection)：两个通信实体为进行通信而建立的一种结合  </li>
<li>面向连接的服务通信过程：建立连接 (通信之前先“握手”，为通信分配资源，做好准备) -&gt; 通信 -&gt; 拆除连接  </li>
<li>例子：网络层的连接被称为虚电路  </li>
<li>适用范围：更适合传输大的数据块，不适合效地零星报文  </li>
<li>特点：保序  </li>
<li>服务类型<ul>
<li>可靠的信息流 传送页面 (可靠的获得，通过接收方的确认：先“握手”)  </li>
<li>可靠的字节流 远程登陆  </li>
<li>不可靠的连接 数字化声音  </li>
</ul>
</li>
</ul>
<p><strong>无连接的服务 (Connectionless Service)</strong>  </p>
<ul>
<li>两个对等层实体在通信钱不需要建立一个连接，不预留资源，不需要通信双方都活跃 (例：寄信；通信之前不“握手”)  </li>
<li>特点：不可靠、可能重复、可能失序  </li>
<li>IP分组，数据包  </li>
<li>适用范围：传送零星数据  </li>
<li>服务类型<ul>
<li>不可靠的数据报 电子方式的函件  </li>
<li>有确认的数据包 挂号信  </li>
<li>请求回答 信息查询  </li>
</ul>
</li>
</ul>
<h3 id="服务和协议"><a href="#服务和协议" class="headerlink" title="服务和协议"></a>服务和协议</h3><p><strong>区别</strong>  </p>
<ul>
<li>服务 (Service)：低层实体向上层实体提供它们之间的通信能力；通过原语 (primitive) 操作；垂直  </li>
<li>协议 (protocol)：对等层实体 (peer entity) 之间在相互通信的过程中；需要遵循的规则的集合；水平  </li>
</ul>
<p><strong>联系</strong>  </p>
<ul>
<li>本层协议的实现要靠下层提供的服务来实现  </li>
<li>本层实体通过协议为上层提供更高级的服务  </li>
</ul>
<h3 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h3><p><img src="/2022/03/14/computernetworknotes1/DU.png" alt="Data Unit">  </p>
<p>SDU：上层要求传输的数据<br>ICI：接口控制信息，为更加顺利地传过层间接口<br>IDU = SDU + ICI<br>PDU：最常见的数据单元；在不同层有不同的名称，如应用报文、分组、数据报、位、帧等  </p>
<p><strong>n-PDU的构成形式</strong><br><em>n-header：与本层交换数据所需的一些控制信息；其中，n 为层数，第 n 层</em>  </p>
<ul>
<li>一对一：SDU + n-header  </li>
<li>一对多：SDU 的一部分 + n-header (PDU 大小有限，需要将 SDU 分为几个部分)  </li>
<li>多对一：若干 SDU + n-header  </li>
</ul>
<h3 id="分层处理队实现复杂系统的好处"><a href="#分层处理队实现复杂系统的好处" class="headerlink" title="分层处理队实现复杂系统的好处"></a>分层处理队实现复杂系统的好处</h3><p>对复杂的系统<br><strong>概念化</strong>：结构清晰，便于标示网络组件，以及描述其相互关系</p>
<ul>
<li>分层参考模型  </li>
</ul>
<p><strong>结构化</strong>：模块化更易于维护和系统升级  </p>
<ul>
<li>改变某一层服务的实现不影响系统中的其它层次，对其它层次而言是透明的  </li>
<li>eg. 如果改变登记程序并不影响系统的其他部分  </li>
</ul>
<p>分层的问题：效率相对较低  </p>
<h3 id="Internet-协议栈"><a href="#Internet-协议栈" class="headerlink" title="Internet 协议栈"></a>Internet 协议栈</h3><p><strong>应用层</strong>：网络应用  </p>
<ul>
<li>为人类用户或其它应用进程提供网络应用服务  </li>
<li>完成应用报文之间的交互  </li>
<li>FTP, SMTP, HTTP, DNS  </li>
<li>协议数据单元：报文 (message)  </li>
</ul>
<p><strong>传输层</strong>：主机之间的数据传输  </p>
<ul>
<li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠的通信  </li>
<li>完成进程到进程的区分  </li>
<li>TCP, UDP  </li>
<li>协议数据单元：报文段 (segment)；eg. TCP 段，UDP 数据报  </li>
</ul>
<p><strong>网络层</strong>：为数据包从源到目的选择路由  </p>
<ul>
<li>主机主机之间的通信，端到端通信，不可靠  </li>
<li>传输以分组为单位的端到端的数据  </li>
<li>IP，路由协议  </li>
<li>协议数据单元：分组 (packet)；如果无连接方式：数据报 (datagram)  </li>
</ul>
<p><strong>链路层</strong>：相邻网络节点间的数据传输  </p>
<ul>
<li>2 个相邻 2 点的通信，点到点通信，可靠或不可靠</li>
<li>在相邻两点之间，传输以帧为单位的数据 (Point to Point, P2P)  </li>
<li>点对点协议 PPP，802.11 (WiFi)，Ethernet  </li>
<li>协议数据单元：帧 (frame)  </li>
</ul>
<p><strong>物理层</strong>：在线路上传送 bit  </p>
<ul>
<li>把数据转换成物理信号承载在媒体上传输出去，接收方将物理信号再转换为数据信息  </li>
<li>协议数据单元：位 (bit)  </li>
</ul>
<p><em>链路层和物理层协议一般封装在同一张网卡中</em>  </p>
<p><img src="/2022/03/14/computernetworknotes1/Internetxieyizhan.png">  </p>
<h3 id="ISO-OSI-参考模型"><a href="#ISO-OSI-参考模型" class="headerlink" title="ISO/OSI 参考模型"></a>ISO/OSI 参考模型</h3><p><strong>表示层</strong>：允许应用解释传输的数据  </p>
<ul>
<li>关心数据语义方面的信息和核心内容，而不是关心具体表达、如何编码</li>
<li>加密、压缩、机器相关的表示转换  </li>
</ul>
<p><strong>会话层</strong>：数据交换的同步，检查点，恢复  </p>
<ul>
<li>会话管理：建立会话、维持会话  </li>
</ul>
<p><em>Internet 协议栈中没有以上两层，但依靠应用层来实现以上两层实现的功能</em>  </p>
<p><img src="/2022/03/14/computernetworknotes1/ISO.png">  </p>
<h3 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a>封装和解封装</h3><p><img src="/2022/03/14/computernetworknotes1/seal.png" alt="封装和解封装">  </p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 2：Applications</title>
    <url>/2022/03/23/computernetworknotes2/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络第二章应用层自学笔记 </center>
<span id="more"></span>

<br>

<h2 id="本章基本内容"><a href="#本章基本内容" class="headerlink" title="本章基本内容"></a>本章基本内容</h2><p>网络应用的<strong>原理</strong>：网络应用协议的概念和实现方面  </p>
<ul>
<li>传输层的服务模型  </li>
<li>客户-服务器模式  </li>
<li>对等模式 (peer-to-peer)  </li>
<li>内容分发网络  </li>
</ul>
<p>网络应用的<strong>实例</strong>：互联网流行的应用层协议  </p>
<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP / POP3 / IMAP  </li>
<li>DNS  </li>
</ul>
<p><strong>编程</strong>：网络应用程序</p>
<ul>
<li>Socket API  </li>
</ul>
<p>网络应用的例子：E-mail，Web，文本消息，远程登陆，P2P 文件共享，即时通信，多用户网络游戏，流媒体 (YouTube，Hulu，Netflix)，Internet 电话，实时电视会议，社交网络，搜索等  </p>
<br>

<h2 id="创建一个新的网络应用"><a href="#创建一个新的网络应用" class="headerlink" title="创建一个新的网络应用"></a>创建一个新的网络应用</h2><p>编程  </p>
<ul>
<li>在不同端系统上运行  </li>
<li>通过网络基础设施提供的服务，应用进程彼此通信  </li>
<li>eg. Web：Web服务器软件与浏览器软件通信  </li>
</ul>
<p>网络核心中没有应用层软件  </p>
<ul>
<li>网络核心没有应用层  </li>
<li>网络应用只在端系统上存在：快速网络应用开发和部署  </li>
</ul>
<br>

<h2 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h2><h3 id="客户-服务器模式-C-S-client-server"><a href="#客户-服务器模式-C-S-client-server" class="headerlink" title="客户-服务器模式 (C/S: client/server)"></a>客户-服务器模式 (C/S: client/server)</h3><p><strong>服务器</strong>  </p>
<ul>
<li>一直运行  </li>
<li>固定的 IP 地址和周知的端口号 (约定)  </li>
<li>扩展性：服务器场  <ul>
<li>数据中心进行扩展</li>
<li>扩展性差  </li>
<li>可靠性差：服务非常依赖于服务器的状态  </li>
</ul>
</li>
</ul>
<p><strong>客户端</strong>  </p>
<ul>
<li>主动与服务器通信  </li>
<li>与互联网各有间歇性的连接  </li>
<li>可能是动态 IP 地址  </li>
<li>不直接与其它客户端通信  </li>
</ul>
<h3 id="对等模式-P2P-Peer-to-Peer"><a href="#对等模式-P2P-Peer-to-Peer" class="headerlink" title="对等模式 (P2P: Peer to Peer)"></a>对等模式 (P2P: Peer to Peer)</h3><p>(几乎) 没有一直运行的服务器<br>任意端系统之间可以进行通信<br>每一个节点既是客户端又是服务器  </p>
<ul>
<li>自扩展性：新 peer 节点带来新的服务能力，也带来新的服务请求  </li>
</ul>
<p>参与的主机间歇性连接且可以改变 IP 地址  </p>
<ul>
<li>难以管理</li>
</ul>
<p>eg. Gnutella，迅雷  </p>
<h3 id="混合体：客户-服务器和对等体系结构"><a href="#混合体：客户-服务器和对等体系结构" class="headerlink" title="混合体：客户-服务器和对等体系结构"></a>混合体：客户-服务器和对等体系结构</h3><p><strong>Napster</strong>  </p>
<ul>
<li>文件搜索：集中  <ul>
<li>主机在中心服务器上注册其资源  </li>
<li>主机向中心服务器查询资源位置  </li>
</ul>
</li>
<li>文件传输：P2P  <ul>
<li>任意 Peer 节点之间</li>
</ul>
</li>
</ul>
<p><strong>即时通信</strong>  </p>
<ul>
<li>在线检测：集中  <ul>
<li>当用户上线时，向中心服务器注册其 IP 地址  </li>
<li>用户与中心服务器联系，已找到其在线好友的位置  </li>
</ul>
</li>
<li>两个用户之间聊天：P2P  </li>
</ul>
<br>  

<h2 id="应用层原理-进程通信"><a href="#应用层原理-进程通信" class="headerlink" title="应用层原理-进程通信"></a>应用层原理-进程通信</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>进程</strong>：在主机上运行的应用程序  </p>
<ul>
<li>客户端进程：发起通信的进程 (主动)  </li>
<li>服务器进程：等待连接的进程 (被动)  </li>
</ul>
<p><em>P2P 架构的应用也有客户端进程和服务器进程之分</em>  </p>
<p>在同一个主机内，使用<strong>进程间通信机制</strong>通信 (操作系统定义)<br>不同主机，通过交换<strong>报文</strong> (Message) 来通信  </p>
<ul>
<li>使用 OS 提供的通信服务  </li>
<li>按照应用协议交换报文：借助传输层提供的服务  </li>
</ul>
<h3 id="分布式进程通信需要解决的问题"><a href="#分布式进程通信需要解决的问题" class="headerlink" title="分布式进程通信需要解决的问题"></a>分布式进程通信需要解决的问题</h3><ol>
<li>进程标示和寻址问题 (服务用户)  </li>
<li>传输层-应用层如何提供服务 (服务)  <ul>
<li>位置：层间界面的 SAP (TCP/IP: socket)  </li>
<li>形式：应用程序接口 API (TCP/IP: socket API)  </li>
</ul>
</li>
<li>如何使用传输层提供的服务，实现应用进程之间的报文交换，即实现应用 (用户使用服务)  <ul>
<li>定义应用层协议：报文格式、解释、时序等  </li>
<li>编制程序，使用 OS 提供的 API，调用网络基础设施提供通信服务传报文，实现应用时序等  </li>
</ul>
</li>
</ol>
<h4 id="对进程进行编址-addressing"><a href="#对进程进行编址-addressing" class="headerlink" title="对进程进行编址 (addressing)"></a>对进程进行编址 (addressing)</h4><p>进程为了接收报文，必须有一个<strong>标识</strong>，即 SAP (发送也需要标示)  </p>
<ul>
<li>主机：唯一的 32 位 IP 地址  <ul>
<li>仅仅有 IP 地址不能唯一标示一个进程，在一台端系统上有很多应用进程在运行  </li>
</ul>
</li>
<li>所采用的传输层协议：TCP or UDP  </li>
<li>端口号 (Port Numbers)  <ul>
<li>一些知名端口号例子：HTTP TCP 80；Mail TCP 25；ftp TCP 2  </li>
</ul>
</li>
<li>一个进程：用 IP + port 标示，端节点  </li>
<li>本质上，一对主机进程之间的通信由 2 个端节点 (end point) 构成  </li>
</ul>
<h4 id="传输层提供的服务-需要穿过层间的信息"><a href="#传输层提供的服务-需要穿过层间的信息" class="headerlink" title="传输层提供的服务-需要穿过层间的信息"></a>传输层提供的服务-需要穿过层间的信息</h4><p>层间接口必须要携带的信息  </p>
<ul>
<li>要传输的报文 (对于本层来说：SDU)</li>
<li>谁传的：对方应用进程的标示 IP + TCP (UDP) 端口号  </li>
<li>传给谁：对方的应用进程标示 对方的 IP + TCP (UDP) 端口号  </li>
</ul>
<p>传输层实体 (TCP 或 UDP 实体)根据这些信息进行 TCP 报文段 (UDP 数据报)的封装  </p>
<ul>
<li>源端口号，目标端口号，数据等  </li>
<li>将 IP 地址往下交 IP 实体，用于封装 IP 数据报：源 IP，目标 IP  </li>
</ul>
<h4 id="传输层提供的服务-层间信息的代表"><a href="#传输层提供的服务-层间信息的代表" class="headerlink" title="传输层提供的服务-层间信息的代表"></a>传输层提供的服务-层间信息的代表</h4><p>如果 Socket API 每次传输报文都携带如此多的信息，太繁琐易错，不便于管理<br>用代号标示通信双方或单方：socket (代表本地 IP、本地端口和对方 IP、对方端口的一个本地标识)<br>类似 OS 打开文件返回句柄一样，对句柄的操作就是对文件的操作  </p>
<p><strong>TCP</strong> <strong>socket</strong>  </p>
<ul>
<li>TCP 服务，两个进程之间的通信之前需要建立连接  <ul>
<li>两个进程通信会<strong>持续</strong>一段时间，通信关系稳定  </li>
</ul>
</li>
<li>可用一个征数标示两个应用实体之间的通信关系，<strong>本地</strong>标示 (便于本地管理引入的一个标识)  </li>
<li>穿过层间接口的信息量<strong>最小</strong>  </li>
<li>TCP socket：源 IP，源端口，目标IP，目标端口；用于指明应用进程会话的本地标示  </li>
<li>TCP之上的套接字 (socket)：对于使用面向连接的服务 (TCP) 的应用而言，套接字时 4 元组的一个具有<strong>本地意义的标示</strong>  <ul>
<li>4 元组：源 IP、源 port、目标 IP、目标 port  </li>
<li>唯一的制定了一个会话 (2 个进程之间的会话关系)  </li>
<li>应用使用这个标示，与远程的应用进程通信  </li>
<li>不必在每一个报文的发送都要指定这个 4 元组  </li>
<li>类似文件句柄，每次使用文件句柄，而不是使用文件的目录名、文件名等  </li>
<li>简单，便于管理，层间传输的信息较少  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/TCPsocket.png" alt="TCP socket">  </p>
<p><strong>UDP</strong> <strong>socket</strong>  </p>
<ul>
<li>UDP 服务：两个进程之间的通信之前不需要建立连接  <ul>
<li>每个报文都是独立传输的  </li>
<li>前后报文可能给不同的分布式进程  </li>
</ul>
</li>
<li>只能用一个征数标示本应用实体的标示，因为这个报文可能传给另外一个分布式进程  </li>
<li>穿过层间接口的信息量最小  </li>
<li>UDP socket：本IP，本端口；2 元组，本地标示  </li>
<li>传输报文时，必须提供对方 IP、port；接收报文时，传输层需要上传对方的 IP、port  </li>
<li>UDP 之上的套接字 (socket)：对于使用无连接服务 (UDP) 的应用而言，套接字是 2 元组的一个具有<strong>本地意义的标示</strong>  <ul>
<li>2 元组：IP，port (源端指定)  </li>
<li>UDP 套接字指定了应用所在的一个<strong>端节点</strong> (end point)  </li>
<li>在发送数据报时，采用创建好的本地套接字 (标示 ID)，就不必在发送每个报文中指明自己所采用的 IP 和 port  </li>
<li>在发送报文时，必须置顶对方的 IP 和 UDP port (另外一个段节点)  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/UDPsocket.png" alt="UDP socket"></p>
<p><strong>套接字</strong> (Socket)  </p>
<ul>
<li>进程向套接字发送报文，或从套接字接收报文  </li>
<li>套接字 &lt;-&gt; 门户  <ul>
<li>发送进程将报文<strong>推出</strong>门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接收进程  </li>
<li>接收进程从另外一段的门户<strong>收到</strong>报文 (依赖于传输层设施)  </li>
</ul>
</li>
</ul>
<h4 id="如何使用传输层提供的服务实现应用"><a href="#如何使用传输层提供的服务实现应用" class="headerlink" title="如何使用传输层提供的服务实现应用"></a>如何使用传输层提供的服务实现应用</h4><p><strong>应用层协议</strong>  </p>
<ul>
<li>定义了运行在不同端系统上的应用进程如何相互交换报文  <ul>
<li>交换的<strong>报文类型</strong>：请求和应答报文  </li>
<li>各种报文类型的<strong>语法</strong>：报文中的各个字段及其描述  </li>
<li>字段的<strong>语义</strong>：即字段取值的含义  </li>
<li>进程何时、如何发送报文及对报文进行响应的<strong>规则</strong>  </li>
</ul>
</li>
<li>应用协议仅仅是应用的一个组成部分，仅规范通信交互规则<ul>
<li>Web 应用：HTTP 协议、web 客户端、web 服务器、HTML  </li>
</ul>
</li>
<li>公开协议<ul>
<li>由 RFC 文档定义</li>
<li>允许互操作</li>
<li>eg. HTTP、SMTP  </li>
</ul>
</li>
<li>专用 (私有) 协议  <ul>
<li>协议不公开</li>
<li>eg. Skype  </li>
</ul>
</li>
</ul>
<p><strong>应用需要传输层提供什么服务</strong>  </p>
<ul>
<li>数据丢失率  <ul>
<li>有些应用要求 100 % 的可靠数据传输，如文件  </li>
<li>有些应用能容忍一定比例一下的数据丢失，如音频  </li>
</ul>
</li>
<li>延迟  <ul>
<li>一些应用出于有效性考虑，对数据传输有严格的时间限制，如 Internet 电话、交互式游戏</li>
</ul>
</li>
<li>吞吐  <ul>
<li>一些应用必须需要最小限度的吞吐，从而使得应用能够有效运转，如多媒体  </li>
<li>一些应用能充分利用可供使用的吞吐，如弹性应用  </li>
</ul>
</li>
<li>安全性  <ul>
<li>机密性  </li>
<li>完整性</li>
<li>可认证性 (鉴别)  </li>
</ul>
</li>
</ul>
<p><strong>Internet</strong> <strong>传输层提供的服务</strong>  </p>
<ul>
<li>TCP 服务<ul>
<li>可靠的传输服务  </li>
<li>流量控制：发送方不会淹没接收方  </li>
<li>拥塞控制：当网络出现拥塞时，能抑制发送方  </li>
<li>不能提供的服务：时间保证、最小吞吐量保证和安全  </li>
<li>面向连接：要求在客户端进程和服务器进程之间建立连接  </li>
</ul>
</li>
<li>UDP 服务  <ul>
<li>不考考的数据传输  </li>
<li>不提供的服务：可靠、流量控制、拥塞控制、时间、带宽保证、建立连接  </li>
</ul>
</li>
</ul>
<p><em>UDP 存在的必要性</em>  </p>
<ul>
<li>能够区分不同的进程，而 IP 服务不能  <ul>
<li>在 IP 提供的主机到主机端到端功能的基础上，区分了主机的应用进程  </li>
</ul>
</li>
<li>无需建立连接，省去建立连接的时间，适合事务性的应用  </li>
<li>不做可靠性的工作，如检错重发  <ul>
<li>适合对实时性要求较高而对正确性要求不高的应用  </li>
<li>为实现可靠性 (准确性、保序等)，必须付出时间代价 (检错重发)  </li>
</ul>
</li>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据  <ul>
<li>在 TCP 上的应用，应用发送数据的速度和主机向网络发送的实际速度不一致，因为有流量控制和拥塞控制  </li>
</ul>
</li>
</ul>
<p><strong>安全</strong> <strong>TCP</strong>  </p>
<ul>
<li>TCP &amp; UDP  <ul>
<li>都没有加密</li>
<li>明文通过互联网传输，甚至密码</li>
</ul>
</li>
<li>SSL (安全套接字层)  <ul>
<li>在 TCP 上实现，提供加密的 TCP 连接  </li>
<li>私密性  </li>
<li>数据完整性  </li>
<li>端到端的鉴别  </li>
<li>SSL 在应用层：应用采用 SSL 库，SSL 库使用 TCP 通信  </li>
<li>SSL socket API：应用通过 API 将明文交给 socket，SSL 将其加密在互联网上传输  </li>
</ul>
</li>
</ul>
<br>

<h2 id="Web-and-HTTP"><a href="#Web-and-HTTP" class="headerlink" title="Web and HTTP"></a>Web and HTTP</h2><h3 id="Web-页"><a href="#Web-页" class="headerlink" title="Web 页"></a>Web 页</h3><p>由一些<strong>对象</strong>组成，对象可以是 HTML 文件、JPEG 图像、Java 小程序、声音剪辑文件等<br>Web 页含有一个基本的 HTML 文件，该基本 HTML 文件又包含若干对象的引用 (链接)<br>通过 URL (通用资源调用符)对每个对象进行引用：访问协议、用户名、口令字、端口等，支持匿名访问，默认端口为 80<br>URL 格式：<br><img src="/2022/03/23/computernetworknotes2/URLform.png">  </p>
<h3 id="HTTP-概况"><a href="#HTTP-概况" class="headerlink" title="HTTP 概况"></a>HTTP 概况</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>超文本传输协议 (Hyper Text Transform Protocol)，Web 的应用层协议<br>客户/服务器模式  </p>
<ul>
<li>客户：请求、接收和显示 Web 对象的浏览器  </li>
<li>服务器：对请求进行响应，发送对象的 Web 服务器  </li>
</ul>
<p>HTTP 1.0：RFC 1945<br>HTTP 1.1：RFC 2068  </p>
<h4 id="使用-TCP"><a href="#使用-TCP" class="headerlink" title="使用 TCP"></a>使用 TCP</h4><ul>
<li>客户发起一个与服务器的 TCP 连接 (建立套接字)，端口号为 80  </li>
<li>服务器接受客户的 TCP 连接  </li>
<li>在浏览器 (HTTP 客户端) 与 Web 服务器 (HTTP 服务器 server) 交换 HTTP 报文 (应用层协议报文)  </li>
<li>TCP 连接关闭  </li>
</ul>
<p>HTTP 是无状态的：服务器并不维护关于客户的任何信息，不维护客户端的状态<br>维护状态的协议很复杂：  </p>
<ul>
<li>必须维护历史信息 (状态)  </li>
<li>如果服务器/客户端死机，它们的状态信息可能不一致，二者的信息必须是一致的  </li>
<li>无状态的服务器能够支持更多的客户端  </li>
</ul>
<h3 id="HTTP-连接"><a href="#HTTP-连接" class="headerlink" title="HTTP 连接"></a>HTTP 连接</h3><h4 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a>响应时间模型</h4><p>往返时间 RTT (round-trip time)：一个小的分组从客户端到服务器，在回到客户端的时间 (传输时间忽略)<br>响应时间：  </p>
<ul>
<li>一个 RTT 用来发起 TCP 连接  </li>
<li>一个 RTT 用来 HTTP 请求并等待 HTTP 响应  </li>
<li>文件传输时间  </li>
</ul>
<p>  <em>共 2 RTT + 传输时间</em>  </p>
<p><img src="/2022/03/23/computernetworknotes2/RTTmodel.png" alt="响应时间模型">  </p>
<h4 id="非持久-HTTP"><a href="#非持久-HTTP" class="headerlink" title="非持久 HTTP"></a>非持久 HTTP</h4><p>最多只有一个对象在 TCP 连接上发送<br>下载多个对象需要多个 TCP 连接<br>HTTP 1.0 使用非持久连接<br>过程：TCP 连接请求 -&gt; TCP 连接确认 -&gt; HTTP 请求 -&gt; 对象回传 -&gt; 连接关闭请求 -&gt; 连接关闭确认  </p>
<p><img src="/2022/03/23/computernetworknotes2/unperHTTP.png" alt="非持久 HTTP 连接"><br><img src="/2022/03/23/computernetworknotes2/unperHTTP2.png" alt="非持久 HTTP 连接">  </p>
<p>非持久 HTTP 的缺点  </p>
<ul>
<li>每个对象要 2 个 RTT  </li>
<li>操作系统必须为每个 TCP 连接分配资源  </li>
<li>浏览器通常打开并行 TCP 连接，以获取引用对象  </li>
</ul>
<h4 id="持久-HTTP"><a href="#持久-HTTP" class="headerlink" title="持久 HTTP"></a>持久 HTTP</h4><p>多个对象可以在一个 (在客户端和服务器之间的) TCP 连接上传输<br>HTTP 1.1 默认使用持久连接<br>过程：TCP 连接请求 -&gt; TCP 连接确认 -&gt; HTTP 请求对象 -&gt; 对象回传；连接不关闭，之后再有请求可直接使用此路径  </p>
<ul>
<li>服务器在发送响应后，仍保持 TCP 连接  </li>
<li>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送  </li>
<li>客户端在遇到一个引用对象时，可以尽快发送该对象的请求</li>
</ul>
<p><em>非流水方式的持久</em> <em>HTTP</em>  </p>
<ul>
<li>客户端只能在收到前一个响应后才能发出新的请求  </li>
<li>每个引用对象花费一个 RTT  </li>
</ul>
<p><em>流水方式的持久</em> <em>HTTP</em>  </p>
<ul>
<li>HTTP 1.1 的默认模式  </li>
<li>客户端遇到一个引用对象就立即产生一个请求  </li>
<li>所有引用 (小) 对象只花费一个 RTT 是可能的</li>
</ul>
<h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><p>两种类型的 HTTP 报文：请求，响应  </p>
<h4 id="HTTP-请求报文："><a href="#HTTP-请求报文：" class="headerlink" title="HTTP 请求报文："></a>HTTP 请求报文：</h4><p>ASCII (人能阅读，readable)<br>  <img src="/2022/03/23/computernetworknotes2/ASCIIrequest.png">  </p>
<p>通用格式<br>  <img src="/2022/03/23/computernetworknotes2/HTTPnormal.png">  </p>
<h4 id="提交表单输入"><a href="#提交表单输入" class="headerlink" title="提交表单输入"></a>提交表单输入</h4><p>Post 方式  </p>
<ul>
<li>网页通常包括表单输入  </li>
<li>包含在实体主体 (entity body) 中的输入被提交到服务器  </li>
</ul>
<p>URL 方式  </p>
<ul>
<li>方法：GET  </li>
<li>输入通过请求行的 URL 字段上载  </li>
</ul>
<h4 id="方法类型"><a href="#方法类型" class="headerlink" title="方法类型"></a>方法类型</h4><p>HTTP 1.0  </p>
<ul>
<li>GET  </li>
<li>POST</li>
<li>HEAD：要求服务器在响应报文中不包含请求对象 -&gt; 故障跟踪</li>
</ul>
<p>HTTP 1.1  </p>
<ul>
<li>GET, POST, HEAD</li>
<li>PUT：将实体主体中的文件上载到 URL 字段规定的路径，通常用于网页内容的维护  </li>
<li>DELETE：删除 URL 字段规定的文件，用于维护网页</li>
</ul>
<h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p><img src="/2022/03/23/computernetworknotes2/HTTPreaction.png" alt="HTTP 响应报文格式">  </p>
<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p><strong>状态行</strong>：协议版本、状态码 (如404、504等)和相应状态信息<br><strong>首部行</strong>：服务器、内容等的相关信息，如服务器系统信息、内容的字节长度等<br><strong>数据</strong>：如请求的 HTML 文件  </p>
<h4 id="HTTP-响应状态码"><a href="#HTTP-响应状态码" class="headerlink" title="HTTP 响应状态码"></a>HTTP 响应状态码</h4><p>位于服务器 -&gt; 客户端的响应报文中的首行<br>例子：  </p>
<ul>
<li>200 OK：请求成功，请求对象包含在响应报文的后续部分  </li>
<li>301 Moved Permanently：请求的对象已经被永久转移，新的 URL 在响应报文的 Location：首部行中指定；客户端软件自动用新的 URL 去获取对象  </li>
<li>400 Bad Request：一个通用的差错代码，表示该请求不能被服务器解读  </li>
<li>404 Not Found：请求的文档在服务器上没有找到  </li>
<li>505 HTTP Version Not Supported  </li>
</ul>
<h3 id="用户-服务器状态-cookies"><a href="#用户-服务器状态-cookies" class="headerlink" title="用户-服务器状态 cookies"></a>用户-服务器状态 cookies</h3><p>大多数主要的门户网站使用cookies，用于维护状态  </p>
<h4 id="4-个组成部分"><a href="#4-个组成部分" class="headerlink" title="4 个组成部分"></a>4 个组成部分</h4><p>在 HTTP 响应报文中有一个 cookie 的首部行<br>在 HTTP 请求报文含有一个 cookie 的首部行<br>在用户段系统中保留有一个 cookie 文件，由用户的浏览器管理<br>在 Web 站点有一个后端数据库<br><em>通过维护 cookie 使得 HTTP 这一无状态服务能够维护状态</em>  </p>
<p><img src="/2022/03/23/computernetworknotes2/cookies.png" alt="Cookies: 维护状态">  </p>
<h4 id="Cookies-的作用"><a href="#Cookies-的作用" class="headerlink" title="Cookies 的作用"></a>Cookies 的作用</h4><p>用户验证<br>购物车<br>推荐<br>用户状态 (Web Email)  </p>
<h4 id="如何维持状态"><a href="#如何维持状态" class="headerlink" title="如何维持状态"></a>如何维持状态</h4><p>协议端节点：在多个事务上，发送端和接收端维持状态<br>cookies：http 报文携带状态信息  </p>
<h4 id="Cookies-与隐私"><a href="#Cookies-与隐私" class="headerlink" title="Cookies 与隐私"></a>Cookies 与隐私</h4><p>Cookies 允许站点知道许多关于用户的信息<br>可能将这些信息卖给第三方<br>使用重定向和 cookie 的搜索引擎还能知道用户更多信息</p>
<ul>
<li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式 (互联网画像)  </li>
</ul>
<p>广告公司从站点获得信息  </p>
<h3 id="Web-缓存-代理服务器"><a href="#Web-缓存-代理服务器" class="headerlink" title="Web 缓存(代理服务器)"></a>Web 缓存(代理服务器)</h3><p>目标：不访问原始服务器，就满足客户的请求<br>用户设置浏览器：通过缓存访问 Web<br>缓存既是客户端又是服务器<br>通常缓存由 ISP 安装：大学、公司、居民区 ISP  </p>
<h4 id="缓存实现的方式"><a href="#缓存实现的方式" class="headerlink" title="缓存实现的方式"></a>缓存实现的方式</h4><p>浏览器将所有的 HTTP 请求发给缓存  </p>
<ul>
<li>在缓存中的对象：缓存直接返回对象 (本地访问)  </li>
<li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回客户端 (远程访问)  </li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/caches.png">  </p>
<h4 id="Web-缓存的优势"><a href="#Web-缓存的优势" class="headerlink" title="Web 缓存的优势"></a>Web 缓存的优势</h4><p>降低客户端的请求响应时间<br>可以大大减少一个机构内部网络与 Internet 接入链路上的流量<br>互联网大量采用缓存：可以使较弱的 ICP 也能有效提供内容  </p>
<h4 id="条件-GET-方法"><a href="#条件-GET-方法" class="headerlink" title="条件 GET 方法"></a>条件 GET 方法</h4><p>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象<br>缓存器：在 HTTP 请求中指定缓存拷贝的日期：<code>If-modified-since: &lt;date&gt;</code><br>服务器：如果缓存拷贝不陈旧，则响应报文没包含对象：HTTP/1.0 304 Not Modified  </p>
<br>

<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h3 id="FTP：文件传输协议"><a href="#FTP：文件传输协议" class="headerlink" title="FTP：文件传输协议"></a>FTP：文件传输协议</h3><p>向远程主机上传输文件或从远程主机接收文件<br>客户/服务器模式  </p>
<ul>
<li>客户端：发起传输的一方  </li>
<li>服务器：远程主机  </li>
</ul>
<p>FTP：RFC 959<br>FTP 服务器：端口号为 21  </p>
<h3 id="控制连接与数据连接分开"><a href="#控制连接与数据连接分开" class="headerlink" title="控制连接与数据连接分开"></a>控制连接与数据连接分开</h3><p>FTP 客户端与 FTP 服务器通过端口 21 联系，并使用 TCP 为传输协议<br>客户端通过控制连接获得身份确认<br>客户端通过控制连接非让送命令浏览远程目录<br>收到一个文件传输命令时，服务器打开一个到客户端的数据连接<br>一个文件传输完成后，服务器关闭连接  </p>
<p><img src="/2022/03/23/computernetworknotes2/FTPconnect.png">  </p>
<p>服务器打开第二个 TCP 数据连接用来传输另一个文件<br>控制连接：带外 (out of band) 传送<br>FTP 服务器维护用户的状态信息：当前路径、用户账户与控制连接对应 (<strong>有状态</strong>)  </p>
<h3 id="FTP-命令、响应"><a href="#FTP-命令、响应" class="headerlink" title="FTP 命令、响应"></a>FTP 命令、响应</h3><p>命令样例：  </p>
<ul>
<li>在控制连接上以 ASCII 文本方式传送  </li>
<li>USER username  </li>
<li>PASS password  </li>
<li>LIST：请服务器返回远程主机当前目录的文件列表  </li>
<li>RETR filename：从远程主机的当年目录检索文件 (gets)，下载  </li>
<li>STOR filename：向远程主机的当前目录存放文件 (puts)，上载  </li>
</ul>
<p><em>上和下的概念以客户端为准</em></p>
<p>返回码样例：  </p>
<ul>
<li>状态码和状态信息 (同 HTTP)  </li>
<li>331 username OK, password required  </li>
<li>125 data connection already open; transfer starting  </li>
<li>425 Can’t open data connection  </li>
<li>452 Error writing file  </li>
</ul>
<br>

<h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>三个主要组成部分：  </p>
<ul>
<li>用户代理  </li>
<li>邮件服务器  </li>
<li>简单邮件传输协议：SMTP  </li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/email.png">  </p>
<h4 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h4><p>又名邮件阅读器<br>撰写、编辑和阅读邮件<br>如 outlook、foxmail<br>输出和输入邮件保存在服务器上  </p>
<h4 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h4><p>邮箱中管理和维护发送给用户的邮件<br>输出报文队列保持待发送邮件报文<br>邮件服务器之间的 SMTP 协议：发送 email 报文  </p>
<ul>
<li>客户：发送方邮件服务器  </li>
<li>服务器：接收方邮件服务器  </li>
</ul>
<h4 id="SMTP-RFC-2821"><a href="#SMTP-RFC-2821" class="headerlink" title="SMTP [RFC 2821]"></a>SMTP [RFC 2821]</h4><p>使用 TCP 在客户端和服务器之间传送报文，端口号为 25<br>直接传输：从发送方服务器到接收方服务器<br>传输的三个阶段  </p>
<ul>
<li>握手  </li>
<li>传输报文  </li>
<li>关闭  </li>
</ul>
<p>命令/响应交互  </p>
<ul>
<li>命令：ASCII 文本  </li>
<li>响应：状态码和状态信息  </li>
</ul>
<p>报文必须为 7 位 ASCII 码：所有内容要在 ASCII 码范围之内  </p>
<p>SMTP 小结  </p>
<ul>
<li>使用持久连接  </li>
<li>要求报文 (首部和主题) 为 7 位 ASCII 编码  </li>
<li>SMTP 服务器使用 CRLF.CRLF 决定报文的尾部  </li>
</ul>
<p>与 HTTP 比较  </p>
<ul>
<li>HTTP：拉 (pull)  </li>
<li>SMTP：推 (push)  </li>
<li>二者都是 ASCII 形式的命令/响应交互、状态码  </li>
<li>HTTP：每个对象封装在各子的响应报文中  </li>
<li>SMTP：多个对象包含在一个报文中  </li>
</ul>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>SMTP：交换 email 报文的协议<br>RFC 822：文本报文的标准  </p>
<ul>
<li>首部行  <ul>
<li>To:  </li>
<li>From: </li>
<li>Subject:  </li>
</ul>
<em>与 SMTP 命令不同</em>  </li>
<li>主体  <ul>
<li>报文，只能是 ASCII 码字符  </li>
</ul>
</li>
</ul>
<p><strong>多媒体扩展</strong>  </p>
<ul>
<li>MIME：多媒体邮件扩展 (multimedia mail extension)，RFC 2045，2056  </li>
<li>在报文首部用额外的行申明 MIME 内容类型</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/MIME.png">  </p>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>SMTP：传送放到接收方的邮件服务器<br>邮件访问协议：从服务器访问邮件  </p>
<ul>
<li>POP<ul>
<li>邮局访问协议 (Post Office Protocol) [RFC 1939]  </li>
<li>用户身份确认 (代理&lt;–&gt;服务器) 并下载  </li>
</ul>
</li>
<li>IMAP  <ul>
<li>Internet 邮件访问协议 (Internet Mail Access Protocol) [RFC 1730]  </li>
<li>更多特性 (更复杂)  </li>
<li>在服务器上处理存储的报文  </li>
</ul>
</li>
<li>HTTP  <ul>
<li>Hotmail，Yahoo！Mail 等  </li>
<li>方便  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/EmailProtocol.png">  </p>
<p><em>前两跳是推，最后一跳是拉</em>  </p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>用户确认阶段  </p>
<ul>
<li>客户端命令：  <ul>
<li>user：申明用户名  </li>
<li>pass：口令  </li>
</ul>
<em>明文</em>  </li>
<li>服务器响应：  <ul>
<li>+OK</li>
<li>-ERR</li>
</ul>
</li>
</ul>
<p>事务处理阶段(客户端)：</p>
<ul>
<li>list：报文号列表  </li>
<li>retr：根据报文号检索报文  </li>
<li>dele：删除  </li>
<li>quit</li>
</ul>
<p>“<strong>下载并删除</strong>” 模式：如果改变客户机，不能阅读邮件<br>“<strong>下载并保留</strong>” 模式：不同客户机上为报文的拷贝<br>POP3 在会话中是无状态的，不支持远程维护，本地管理文件夹  </p>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP 服务器将每个报文与一个文件夹联系起来<br>允许用户用目录来组织报文<br>允许用户读取报文组件<br>IMAP 在会话过程中保留用户状态：用户名、报文 ID 与目录名之间映射<br>远程管理文件夹  </p>
<br>  

<h2 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS (Domain Name System)"></a>DNS (Domain Name System)</h2><h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><p>IP 地址主要用于标识主机、路由器，但不便于人类记忆和使用<br>人类用户提供要访问机器的“字符串”名称，由 DNS 负责转换成二进制的网络地址<br>DNS 主要提供域名和 IP 地址之间的转换<br>分层的命名，分布式的解析  </p>
<h3 id="DNS-总体思路"><a href="#DNS-总体思路" class="headerlink" title="DNS 总体思路"></a>DNS 总体思路</h3><p>分层的、基于域的命名机制<br>若干分布式的数据库完成名字到 IP 地址的转换<br>运行在 UDP 之上端口号为 53 的应用服务<br>核心的 Internet 功能，但以应用层协议实现：在网络边缘处理复杂性  </p>
<h3 id="DNS-主要目的"><a href="#DNS-主要目的" class="headerlink" title="DNS 主要目的"></a>DNS 主要目的</h3><p>实现主机名 - IP 地址的转换 (name/IP translate)<br>主机别名 (便于用户访问) 到规范名字 (便于管理) 的转换：Host aliasing<br>邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing<br>负载均衡：Load Distribution  </p>
<h3 id="DNS-域名结构"><a href="#DNS-域名结构" class="headerlink" title="DNS 域名结构"></a>DNS 域名结构</h3><p>一个层次命名设备会有很多重名<br>DNS 采用层次树状结构的命名方法<br>Internet 被划分为几百个顶级域 (top level domains)  </p>
<ul>
<li>通用的 (generic)<br>.com, .edu, .gov, .int, .mil, .net, .org, .firm, .hsop, .web, .arts, .rec  </li>
<li>国家的 (countries)<br>.cn, .us, .nl, .jp  </li>
</ul>
<p>每个(子)域下面可划分为若干子域 (subdomains)<br>树叶是主机  </p>
<h3 id="DNS-名字空间-The-DNS-Name-Space"><a href="#DNS-名字空间-The-DNS-Name-Space" class="headerlink" title="DNS 名字空间 (The DNS Name Space)"></a>DNS 名字空间 (The DNS Name Space)</h3><p><strong>域名</strong>  </p>
<ul>
<li>从本域往上，直到树根  </li>
<li>中间使用 “.” 间隔不同级别  </li>
<li>域的域名：可以用于表示一个域  </li>
<li>主机的域名：一个域上的一个主机  </li>
</ul>
<p><strong>域名的管理</strong>  </p>
<ul>
<li>一个域管理其下的子域  </li>
<li>创建一个新的域，必须征得它所属的域的同意  </li>
</ul>
<p><strong>域域物理网络无关</strong>  </p>
<ul>
<li>域遵从组织界限，而不是物理网络  <ul>
<li>一个域的主机可以不在一个网络  </li>
<li>一个网络的主机不一定在一个域  </li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理的  </li>
</ul>
<h3 id="名字服务器-Name-Server"><a href="#名字服务器-Name-Server" class="headerlink" title="名字服务器 (Name Server)"></a>名字服务器 (Name Server)</h3><p><strong>一个名字服务器的问题</strong>  </p>
<ul>
<li>可靠性：单点故障  </li>
<li>扩展性：通信容量  </li>
<li>维护：远距离的集中式数据库  </li>
</ul>
<p><strong>区域</strong> <strong>(zone)</strong>  </p>
<ul>
<li>区域的划分由区域管理者决定  </li>
<li>将 DNS 名字空间划为互不相交的区域，每个区域都是树的一部分  </li>
<li>名字服务器<ul>
<li>每个区域有一个名字服务器，维护者它所管辖区域的权威信息 (authoritative record)  </li>
<li>名字服务器允许被放置在区域之外，以保障可靠性</li>
</ul>
</li>
</ul>
<h4 id="权威-DNS-服务器"><a href="#权威-DNS-服务器" class="headerlink" title="权威 DNS 服务器"></a>权威 DNS 服务器</h4><p>组织机构的 DNS 服务器<br>提供组织机构服务器 (如 Web 和 Mail) 可访问的主机和 IP 之间的映射<br>组织机构可以选择自己维护或由某个服务提供商来维护  </p>
<h4 id="TLD-服务器"><a href="#TLD-服务器" class="headerlink" title="TLD 服务器"></a>TLD 服务器</h4><p>顶级域 (TLD) 服务器<br>负责顶级域名 (如com, org, net,edu 和 gov) 和所有国家级的顶级域名 (如 cn, uk, fr, ca, jp, de 等)  </p>
<ul>
<li>Network solutions 公司维护 com 服务器</li>
<li>Educause 公司维护 edu TLD 服务器  </li>
</ul>
<h3 id="区域名字服务器维护资源记录"><a href="#区域名字服务器维护资源记录" class="headerlink" title="区域名字服务器维护资源记录"></a>区域名字服务器维护资源记录</h3><p><strong>资源记录</strong> (resource records)  </p>
<ul>
<li>作用：维护域名 - IP 地址(其它)的映射关系  </li>
<li>位置：Name Server 的分布式数据库中  </li>
</ul>
<p><strong>RR 格式</strong>：domain_name, ttl, type, class, Value  </p>
<ul>
<li>Domain_name：域名  </li>
<li>ttl：time to live，生存时间 (权威：长期；缓冲记录：短期，一般为两天)  </li>
<li>class：类别，对于 Internet 值为 IN  </li>
<li>Value：值，可以是数字、域名或 ASCII 串  </li>
<li>Type 类别：资源记录的类型</li>
</ul>
<h3 id="DNS-记录"><a href="#DNS-记录" class="headerlink" title="DNS 记录"></a>DNS 记录</h3><p><strong>DNS</strong>：保存资源记录 (RR) 的分布式数据库<br><strong>RR 格式</strong>：(name, value, type, ttl)<br><strong>Type</strong>  </p>
<ul>
<li>Type = A  <ul>
<li>Name 为主机  </li>
<li>Value 为 IP 地址  </li>
</ul>
</li>
<li>Type = CNAME  <ul>
<li>Name 为规范名字的别名  </li>
<li>Value 为规范名字</li>
</ul>
</li>
<li>Type = NS  <ul>
<li>Name 为子域名 (如 foo.com)  </li>
<li>Value 为该子域名的权威服务器的域名  </li>
</ul>
</li>
<li>Type = MX  <ul>
<li>Value 为 name 对应的邮件服务器的名字</li>
</ul>
</li>
</ul>
<p><strong>TTL</strong>：生存时间，决定了资源记录应当从缓存中删除的时间  </p>
<h3 id="DNS-大致工作过程"><a href="#DNS-大致工作过程" class="headerlink" title="DNS 大致工作过程"></a>DNS 大致工作过程</h3><p>应用调用：解析器 (resolver)<br>解析器作为客户，向 Name Server 发出查询报文 (封装在 UDP 段中)<br>Name Server 返回响应报文 (name/ip)  </p>
<p><img src="/2022/03/23/computernetworknotes2/DNSworkflow.png">  </p>
<h3 id="本地名字服务器-Local-Name-Server"><a href="#本地名字服务器-Local-Name-Server" class="headerlink" title="本地名字服务器 (Local Name Server)"></a>本地名字服务器 (Local Name Server)</h3><p>并不严格属于层次结构<br>每个 ISP (居民区的 ISP、公司、大学) 都有一个本地 DNS 服务器，也称为默认名字服务器<br>当一个主机发起一个 DNS 查询时，查询被送到其本地 DNS 服务器：起着代理的作用，将查询转发到层次结构中  </p>
<h4 id="名字解析过程"><a href="#名字解析过程" class="headerlink" title="名字解析过程"></a>名字解析过程</h4><p>目标名字在 Local Name Server 中  </p>
<ul>
<li>查询名字在该区域内部  </li>
<li>缓存 (cashing)  </li>
</ul>
<p>缓存为了性能，删除为了一致性  </p>
<p>当本地名字服务器不能解析名字时，联系根名字服务器，顺着根 - TLD 一直找到权威名字服务器  </p>
<ul>
<li><strong>递归查询</strong>  <ul>
<li>名字解析负担都放在当前联络的名字服务器上  </li>
<li>问题：根服务器的负担太重  </li>
<li>解决：迭代查询 (iterated queries)  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/diguichaxun.png">  </p>
<ul>
<li><strong>迭代查询</strong>  <ul>
<li>根 (及各级域名) 服务器返回的不是查询结果，而是下一个 NS 的地址  </li>
<li>最后由权威名字服务器给出解析结果  </li>
<li>当前联络的服务器给出可以联系的服务器的名字  </li>
<li>“我不知道这个名字，但可以向这个服务器请求”  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/diedaichaxun.png">  </p>
<h3 id="DNS-协议、报文"><a href="#DNS-协议、报文" class="headerlink" title="DNS 协议、报文"></a>DNS 协议、报文</h3><p>DNS 协议：查询和响应报文的报文格式相同  </p>
<p><img src="/2022/03/23/computernetworknotes2/DNSbaowen.png" alt="DNS 报文格式">  </p>
<p><strong>报文首部</strong>  </p>
<ul>
<li>标识符 (ID)：16 位；实现流水线查询  </li>
<li>flags<ul>
<li>查询/应答</li>
<li>希望递归</li>
<li>递归可用</li>
<li>应答为权威</li>
</ul>
</li>
</ul>
<h3 id="提高性能：缓存"><a href="#提高性能：缓存" class="headerlink" title="提高性能：缓存"></a>提高性能：缓存</h3><p>一旦名字服务器学到一个映射，就将该映射<strong>缓存</strong>起来<br>跟服务器通常都在本地服务器中缓存着，使得根服务器不用经常被访问<br>目的：提高效率<br>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致<br>解决方案：TTL，默认 2 天  </p>
<h3 id="维护问题：新增一个域"><a href="#维护问题：新增一个域" class="headerlink" title="维护问题：新增一个域"></a>维护问题：新增一个域</h3><p>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址<br>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析：名字 -&gt; 地址  </p>
<h3 id="攻击-DNS"><a href="#攻击-DNS" class="headerlink" title="攻击 DNS"></a>攻击 DNS</h3><p>总体而言，DNS 比较健壮  </p>
<h4 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h4><p>对根服务器进行流量轰炸攻击：发送大量 ping  </p>
<ul>
<li>没有成功  </li>
<li>原因 1：根目录服务器配置了流量过滤器，防火墙  </li>
<li>原因 2：Local DNS 服务器缓存了 TLD 服务器的 IP 地址，因此无需查询根服务器  </li>
</ul>
<p>向 TLD 服务器流量轰炸攻击：发送大量查询  </p>
<ul>
<li>可能更危险  </li>
<li>效果一般，大部分 DNS 缓存了 TLD  </li>
</ul>
<h4 id="重定向攻击"><a href="#重定向攻击" class="headerlink" title="重定向攻击"></a>重定向攻击</h4><p>中间人攻击：结果查询，伪造回答，从而攻击某个 (DNS 回答指定的 IP) 站点<br>DNS 中毒：发送伪造的应答给 DNS 服务器，希望它能够缓存这个虚假的结果<br>技术上较困难：分布式截获和伪造利用 DNS 基础设施进行 DDoS<br>伪造某个 IP 进行查询，攻击这个目标 IP<br>查询放大，响应报文比查询报文大<br>效果有限  </p>
<br>  

<h2 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h2><h3 id="纯-P2P-架构"><a href="#纯-P2P-架构" class="headerlink" title="纯 P2P 架构"></a>纯 P2P 架构</h3><p>没有(或极少)一直运行的服务器<br>任意端系统都可以直接通信<br>利用 Peer 的服务能力<br>Peer 节点间歇上网，每次 IP 地址都有可能变化  </p>
<p>例子：</p>
<ul>
<li>文件分发 (BitTorrent)  </li>
<li>流媒体 (KanKan)  </li>
<li>VoIP (Skype)  </li>
</ul>
<h4 id="文件分发：C-S-vs-P2P"><a href="#文件分发：C-S-vs-P2P" class="headerlink" title="文件分发：C/S vs P2P"></a>文件分发：C/S vs P2P</h4><p>Peer 节点上下载能力是有限的<br><strong>C/S 模式</strong>  </p>
<ul>
<li><strong>服务器传输</strong>：都是由服务器发送给 Peer，服务器必须顺序传输 (上载) N 个文件拷贝<ul>
<li>发送一个 copy：F/u<sub>s</sub>  </li>
<li>发送 N 个 copy：NF/u<sub>s</sub>  </li>
</ul>
</li>
<li><strong>客户端</strong>：每个客户端必须下载一个文件拷贝  <ul>
<li>d<sub>min</sub>：客户端最小的下载速率  </li>
<li>下载带宽最小的客户端下载的时间：F/d<sub>min</sub>  </li>
</ul>
</li>
</ul>
<p>采用 C-S 方法将一个 F 大小的文件分发给 N 个客户端耗时 D<sub>c-s</sub> ≥ max<br>{NF/u<sub>s</sub>, F/d<sub>min</sub>}  </p>
<ul>
<li>随着客户端的数目 N 越多，时间越长 (线性增加)  </li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/SCfile.png">  </p>
<p><strong>P2P 模式</strong>  </p>
<ul>
<li><strong>服务器传输</strong>：最少需要上载一份拷贝<ul>
<li>发送一个拷贝的时间：F/u<sub>s</sub>  </li>
</ul>
</li>
<li><strong>客户端</strong>：每个客户端必须下载一个拷贝  <ul>
<li>最小下载带宽客户单耗时：F/d<sub>min</sub>  </li>
</ul>
</li>
<li><strong>客户端</strong>：所有客户端总体下载量 NF  <ul>
<li>最大上载带宽是 u<sub>s</sub> + Σu<sub>i</sub>  </li>
<li>除了服务器可以上载，其它所有的 Peer 节点都可以上载  </li>
</ul>
</li>
</ul>
<p>采用 P2P 方法将一个 F 大小的文件分发给 N 个客户端耗时：D<sub>P2P</sub> ≥ max<br>{F/u<sub>s</sub>, F/d<sub>min</sub>, NF/(u<sub>s</sub> + Σu<sub>i</sub>)}  </p>
<ul>
<li>分子随着 N 线性变化，每个节点需要下载，整体下载量随着 N 增大  </li>
<li>分母也是如此，随着 peer 节点的增多，每个 peer 也带了服务能力  </li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/p2pfile.png">  </p>
<p>P2P 性能更好，可扩展性更强  </p>
<p><img src="/2022/03/23/computernetworknotes2/filevs.png" alt="Client-Server vs P2P 文件分发速度对比">  </p>
<h3 id="P2P-的管理模式"><a href="#P2P-的管理模式" class="headerlink" title="P2P 的管理模式"></a>P2P 的管理模式</h3><h4 id="P2P-文件共享的问题"><a href="#P2P-文件共享的问题" class="headerlink" title="P2P 文件共享的问题"></a>P2P 文件共享的问题</h4><p><strong>问题</strong>：</p>
<ul>
<li>如何定位所需资源  </li>
<li>如何处理对等方的加入与离开  </li>
</ul>
<p><strong>可能的方案</strong>：</p>
<ul>
<li>集中  </li>
<li>分散  </li>
<li>半分散  </li>
</ul>
<h4 id="非结构化-P2P"><a href="#非结构化-P2P" class="headerlink" title="非结构化 P2P"></a>非结构化 P2P</h4><p>节点与节点之间是任意构建起来的 overlay  </p>
<p><strong>集中式目录</strong>  </p>
<ul>
<li>当对等方连接时，告诉中心服务器：IP 地址、内容；peer A 可查询资源；peer A 从 peer B 处请求文件；下线时告诉中心服务器  </li>
<li>存在的问题：文件传输是分散的，而定位内容则是高度集中的；单点故障，如中心服务器出现问题；性能瓶颈；侵犯版权  </li>
</ul>
<p><strong>完全分布式</strong>  </p>
<ul>
<li>没有中心服务器  </li>
<li>全开放文件共享协议  </li>
<li>查询泛洪：Gnutella；许多 Gnutella 客户端实现了 Gnutella 协议，类似 HTTP 有许多的浏览器  </li>
<li>覆盖网络：图  <ul>
<li>如果 X 和 Y 之间有一个 TCP 连接，则二者之间存在一条边  </li>
<li>所有活动的对等方和边就是覆盖网络  </li>
<li>边并不是物理链路  </li>
<li>给定一个对等方，通常所连接的节点少于 10 个  </li>
</ul>
</li>
<li>Gnutella 协议  <ul>
<li>在已有的 TCP 连接上发送查询报文  </li>
<li>对等方转发查询报文  </li>
<li>以反方向返回查询命中报文  </li>
</ul>
</li>
<li>可扩展性  <ul>
<li>限制范围的泛洪查询  </li>
<li>设置 ttl  </li>
<li>让中转节点记忆查询，下次返回不再发送查询  </li>
</ul>
</li>
<li>对等方加入(Gnutella)  <ul>
<li>对等方 X 必须首先发现某些已经在覆盖网络中的其它对等方：使用可用对等方列表；自己维持一张对等方列表(经常开机的对等放的 IP)；联系维持列表的 Gnutella 站点  </li>
<li>X 接着试图与该列表上的对等方建立 TCP 连接，直到与某个对等方 Y 建立连接  </li>
<li>X 向 Y 发送一个 Ping 报文，Y 转发该 Ping 报文  </li>
<li>所有收到 Ping 报文的对等方以 Pong 报文响应：IP 地址、共享文件的数量及总字节数  </li>
<li>X 收到许多 Pong 报文，然后它能建立其它 TCP 连接  </li>
</ul>
</li>
</ul>
<p><strong>混合体</strong>：利用不匀称性 (KaZaA)  </p>
<ul>
<li>每个对等方要么是一个组长，要么隶属于一个组长  <ul>
<li>对等方与其组长之间有 TCP 连接  </li>
<li>组长对之间有 TCP 连接  </li>
</ul>
</li>
<li>组长跟踪器所有的孩子的内容  </li>
<li>组长与其他组长联系  <ul>
<li>转发查询到其他组长  </li>
<li>获得其他组长的数据拷贝  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/Kazaa.png" alt="混合体连接示例"></p>
<ul>
<li>KaZaA：查询<ul>
<li>每个文件有一个散列标识码和一个描述符  </li>
<li>客户端向其组长发送关键字查询  </li>
<li>组长用匹配进行响应：对每个匹配元数据、散列标识码和 IP 地址  </li>
<li>如果组长将查询转发给其他组长，其他组长也以匹配进行响应  </li>
<li>客户端选择要下载的文件：向拥有文件的对等方发送一个带散列标识码的 HTTP 请求  </li>
</ul>
</li>
</ul>
<p><strong>BitTorrent</strong>  </p>
<ul>
<li>文件被分为一个个块 256 KB；每个节点都有一张 Bit map；节点之间定期交互  </li>
<li>网络中的这些 peers 发送接收文件块，相互服务  </li>
<li>tracker：跟踪 torrent 中参与节点  </li>
<li>Torrent (洪流)：节点的组，之间交换文件块  </li>
<li>Peer 加入 torrent  <ul>
<li>一开始没有块，但是将会通过其他节点处累积文件块  </li>
<li>向跟踪服务器注册，获得 peer 节点列表，和部分 peer 节点构成邻居关系 (“<br>连接”)  </li>
</ul>
</li>
<li>当 peer 下载时，该 peer 可以同时向其他节点提供上线服务  </li>
<li>peer 可能会变换用于交换的块的 peer 节点  </li>
<li>扰动 churn：peer 节点可能会上线或者下线，整个洪流具有动态性  </li>
<li>一旦一个 peer 拥有整个文件，他会 (自私的) 离开或者保留 (利他主义) 在 torrent 中  </li>
<li>请求块  <ul>
<li>在任何给定时间，不同 peer 节点拥有一个文件块的子集  </li>
<li>周期性的，某节点向邻居询问他们用有哪些块的信息  </li>
<li>某节点向 peer 节点请求它希望的块、稀缺的块  </li>
</ul>
</li>
<li>发送块：一报还一报 tit-for-tat  <ul>
<li>某节点向 4 个 peer 发送块，这些块向它自己提供最大带宽的服务：其他 peer 被该节点阻塞，将不会从这一节点获得服务；每 10 秒重新评估一次 (前 4 位)  </li>
<li>每 30 秒随机选择其它 peer 节点，向这个节点发送块：“优化疏通”这个节点；新选择的节点可以加入这个 top 4  </li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/computernetworknotes2/titfortat.png">  </p>
<h4 id="DHT-结构化-P2P"><a href="#DHT-结构化-P2P" class="headerlink" title="DHT (结构化) P2P"></a>DHT (结构化) P2P</h4><p>peer 节点之间构成环、树等关系的有序拓扑 overlay<br><strong>DHT</strong>: Distributed Hash Table<br>节点 IP 和文件都有一个唯一 Hash 值用以标识<br>内容存在哪个节点是约定好的，副本数量不需要很多就可以很快地找到目标内容  </p>
<br>  

<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h3 id="视频流化服务和-CDN：上下文"><a href="#视频流化服务和-CDN：上下文" class="headerlink" title="视频流化服务和 CDN：上下文"></a>视频流化服务和 CDN：上下文</h3><p>视频流量占据互联网大部分带宽<br>挑战  </p>
<ul>
<li>规模性：如何服务着 ~ 1 B 用户；单个超级服务器无法提供服务  </li>
<li>异构性：不同用户拥有不同的能力；如有线接入和移动用户、带宽丰富和受限用户  </li>
</ul>
<p><strong>解决方案</strong>：分布式的、应用层面的基础设施  </p>
<h3 id="多媒体：视频"><a href="#多媒体：视频" class="headerlink" title="多媒体：视频"></a>多媒体：视频</h3><p><strong>视频</strong>：固定速率显示的图像序列<br>网络视频特点：  </p>
<ul>
<li>高码率：&gt; 10 x 于音频，搞得网络带宽需求  </li>
<li>可以被压缩  </li>
<li>90 % 以上的网络流量是视频  </li>
</ul>
<p><strong>数字化图像</strong>：像素的阵列，每个像素被若干 bits 标识<br><strong>编码</strong>：使用图像内和图像间的荣誉来降低编码的比特数  </p>
<ul>
<li>空间冗余 (图像内)  <ul>
<li>如一张图中某颜色大面积重复，不是发送 N 个相同的颜色值，仅仅发送 2 个值：颜色和重复的个数 N  </li>
</ul>
</li>
<li>时间冗余 (相邻的图像间)  <ul>
<li>如不是发送第 i+1 帧的全部编码，而仅发送和第 i 帧差别的地方  </li>
</ul>
</li>
<li>CBR (Constant Bit Rate)：以固定速率编码  </li>
<li>VBR (Variable Bit Rate)：视频编码速率随时间的变化而变化  </li>
</ul>
<h3 id="多媒体流化服务：DASH"><a href="#多媒体流化服务：DASH" class="headerlink" title="多媒体流化服务：DASH"></a>多媒体流化服务：DASH</h3><p><strong>DASH</strong>: Dynamic, Adaptive Streaming over HTTP<br><strong>服务器</strong>  </p>
<ul>
<li>将视频分割成多个块  </li>
<li>每个块独立存储，编码于不同码率 (8 ~ 10 种)  </li>
<li>*告示文件 (manifest file)*：提供不同块的 URL  </li>
</ul>
<p><strong>客户端</strong>  </p>
<ul>
<li>先获取告示文件  </li>
<li>周期性地测量服务器到客户端的带宽  </li>
<li>查询告示文件，在一个时刻请求一个块，HTTP 头部指定字节范围  <ul>
<li>如果带宽足够，选择最大码率的视频块  </li>
<li>会话中的不同时刻，可以切换请求不同的编码块，取决于当时的可用带宽  </li>
</ul>
</li>
</ul>
<p><strong>智能</strong>客户端：客户端自适应决定  </p>
<ul>
<li>什么时候去请求块：不至于缓存挨饿或溢出  </li>
<li>请求什么编码速率的视频块：档带宽够用时，请求高质量的视频块  </li>
<li>那里去请求块：可以向离自己近的服务器发送 URL，或者向高可用带宽的服务器请求  </li>
</ul>
<h3 id="Content-Distribution-Networks"><a href="#Content-Distribution-Networks" class="headerlink" title="Content Distribution Networks"></a>Content Distribution Networks</h3><p><strong>挑战</strong>：服务器如何通过网络向上百万用户同时流化视频内容(上百万视频内容)？  </p>
<h4 id="单个的、大的超级服务中心：mega-server"><a href="#单个的、大的超级服务中心：mega-server" class="headerlink" title="单个的、大的超级服务中心：mega-server"></a>单个的、大的超级服务中心：mega-server</h4><p>服务器到客户端路径上跳数过多，瓶颈链路的带宽小导致停顿<br>“二八定律”决定了网络同时充斥着同一个视频的多个拷贝，效率低、付费高、带宽浪费、效果差<br>单点故障，性能瓶颈<br>周边网络的拥塞会造成影响<br><strong>评述</strong>：实现相当简单，但这个方法不可扩展  </p>
<h4 id="CDN-1"><a href="#CDN-1" class="headerlink" title="CDN"></a>CDN</h4><p>通过 <strong>CDN</strong>，全网部署缓存节点，存储服务内容，就近位用户提供服务，提高用户体验  </p>
<p><em>enter deep</em>：将 CDN 服务器深入到许多接入网  </p>
<ul>
<li>更接近用户，服务器数量多，离用户近，但管理困难  </li>
<li>Akamai，1700 个位置  </li>
</ul>
<p><em>bring home</em>：部署在少数 (10 个左右) <strong>关键位置</strong>，如将服务器簇安装于 POP 附近 (离若干 1st ISP POP 较近)  </p>
<ul>
<li>采用租用线路将服务器簇连接起来</li>
<li>跳数稍微多一些，服务器少  </li>
<li>Limelight  </li>
</ul>
<p>Content Distribution Networks (CDNs) 的<strong>应用过程</strong>：  </p>
<ul>
<li>部署：在 CDN 节点中存储内容的多个拷贝  </li>
<li>用户从 CDN 中请求内容：重定向到最近的拷贝，请求内容；如果网络路径拥塞，可能选择不同的拷贝  </li>
</ul>
<p><em>减少跳数、增加拷贝，让内容靠近用户，总体相当于加速服务</em>  </p>
<p><strong>over the top</strong><br>CDN 运行在应用层、网络边缘<br>互联网络主机-主机之间的通信作为一种服务向用户提供  </p>
<h4 id="OTT-挑战：在拥塞的互联网上复制内容"><a href="#OTT-挑战：在拥塞的互联网上复制内容" class="headerlink" title="OTT 挑战：在拥塞的互联网上复制内容"></a>OTT 挑战：在拥塞的互联网上复制内容</h4><p>？从哪个 CDN 节点中获取内容<br>？用户在网络拥塞时的行为<br>？在哪些 CDN 节点中存储什么内容 (内容、节点部署策略的问题)  </p>
<p><img src="/2022/03/23/computernetworknotes2/Netflix.png" alt="CDN 案例：Netflix"></p>
<br>

<h2 id="TCP-套接字编程"><a href="#TCP-套接字编程" class="headerlink" title="TCP 套接字编程"></a>TCP 套接字编程</h2><h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><p>应用进程使用传输层提供的服务才能交换报文，实现应用协议，实现应用<br>TCP/IP：应用进程使用 Socket API 访问传输服务<br>地点：界面上的 SAP(socket)<br>方式：Socket API<br>socket：分布式应用进程之间的门，传输层协议提供的端到端服务接口  </p>
<p><img src="/2022/03/23/computernetworknotes2/socket.png">  </p>
<p>2 种传输层服务的 socket 类型：  </p>
<ul>
<li>TCP：可靠的、字节流服务 (原原本本，不错不重复不丢失，保证按照流但不保证界限)  </li>
<li>UDP：不可靠 (数据 UDP 数据报) 服务  </li>
</ul>
<h3 id="TCP-套接字编程-1"><a href="#TCP-套接字编程-1" class="headerlink" title="TCP 套接字编程"></a>TCP 套接字编程</h3><p><strong>套接字</strong>：应用进程与端到端传输协议 (TCP 或 UDP) 之间的门户<br><strong>TCP 服务</strong>：从一个进程向另一个进程可靠地传输字节流<br><em>类似文件句柄</em>  </p>
<h4 id="TCP-连接建立流程"><a href="#TCP-连接建立流程" class="headerlink" title="TCP 连接建立流程"></a>TCP 连接建立流程</h4><p><strong>服务器首先运行，等待连接建立</strong>：  </p>
<ol>
<li>服务器进程必须先于运行状态  </li>
</ol>
<ul>
<li><strong>创建</strong>欢迎 socket  </li>
<li>和本地端口<strong>捆绑</strong>   </li>
<li>在欢迎 socket 上阻塞式<strong>等待接收</strong>用户的连接</li>
</ul>
<p>  <em>创建、捆绑、等待等都是 socket 函数</em>  </p>
<p><strong>客户端主动和服务器建立连接</strong>：  </p>
<ol>
<li><strong>创建</strong>客户端本地套接字 (<strong>隐式捆绑</strong>到本地 port)  </li>
</ol>
<ul>
<li>指定服务器进程的 IP 地址和端口号，与服务器进程<strong>连接</strong>  </li>
</ul>
<ol start="3">
<li>当与客户端连接请求到来时，服务器<strong>接受</strong>来自客户端的请求，解除阻塞式等待，返回一个新的 socket (与欢迎 socket 不一样)，与客户端通信  </li>
</ol>
<ul>
<li>允许服务器与多个客户端通信  </li>
<li>使用源 IP 和源端口来区分不同的客户端  </li>
</ul>
<ol start="4">
<li>连接 API 调用有效时，客户端 P 与服务器建立了 TCP 连接</li>
</ol>
<p><strong>从应用进程的角度</strong>：TCP 在客户端和服务器进程之间提供了可靠的、字节流 (管道) 服务  </p>
<h3 id="TCP-socket-编程-C-S-模式应用样例：大小写转换"><a href="#TCP-socket-编程-C-S-模式应用样例：大小写转换" class="headerlink" title="TCP socket 编程 C/S 模式应用样例：大小写转换"></a>TCP socket 编程 C/S 模式应用样例：大小写转换</h3><ol>
<li>客户端从标准输入装置读取一行字符，发送给服务器  </li>
<li>服务器从 socket 读取字符  </li>
<li>服务器将字符转换成大写，然后返回给客户端  </li>
<li>客户端从 socket 中读取一行字符，然后打印出来  </li>
</ol>
<p><img src="/2022/03/23/computernetworknotes2/CSTCPsocket.png">  </p>
<p>实际上，这描述了 C-S 之间交互的动作次序  </p>
<h4 id="数据结构-sockaddr-in"><a href="#数据结构-sockaddr-in" class="headerlink" title="数据结构 sockaddr_in"></a>数据结构 sockaddr_in</h4><p>IP 地址和 port 捆绑关系的数据结构 (标识进程的端节点)  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> sin_family; <span class="comment">//AF_INET</span></span><br><span class="line">  u_short sin_port; <span class="comment">//port  </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//IP address, unsigned long  </span></span><br><span class="line">  <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">//align</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/23/computernetworknotes2/sockaddr_in.png">  </p>
<h4 id="数据结构-hostent"><a href="#数据结构-hostent" class="headerlink" title="数据结构 hostent"></a>数据结构 hostent</h4><p>域名和 IP 地址的数据结构  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *h_name;</span><br><span class="line">  <span class="keyword">char</span> **h_aliases;</span><br><span class="line">  <span class="keyword">int</span> h_addrtype;</span><br><span class="line">  <span class="keyword">int</span> h_length; <span class="comment">//地址长度  </span></span><br><span class="line">  <span class="keyword">char</span> **h_addr_list;  </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> h_addr h_addr_list[0];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/23/computernetworknotes2/host_ent.png">  </p>
<p>作为调用域名解析函数时的参数<br>返回后，将 IP 地址拷贝到 sockaddr_in 的 IP 地址部分  </p>
<h4 id="C-S-socket-交互：TCP"><a href="#C-S-socket-交互：TCP" class="headerlink" title="C/S socket 交互：TCP"></a>C/S socket 交互：TCP</h4><p><img src="/2022/03/23/computernetworknotes2/TCPjiaohu1.png">  </p>
<h4 id="例：客户端-TCP"><a href="#例：客户端-TCP" class="headerlink" title="例：客户端 TCP"></a>例：客户端 TCP</h4><p><img src="/2022/03/23/computernetworknotes2/clientTCP.png"><br><img src="/2022/03/23/computernetworknotes2/clientTCP2.png"></p>
<h4 id="例：服务器-TCP"><a href="#例：服务器-TCP" class="headerlink" title="例：服务器 TCP"></a>例：服务器 TCP</h4><p><img src="/2022/03/23/computernetworknotes2/serverTCP.png"><br><img src="/2022/03/23/computernetworknotes2/serverTCP2.png">  </p>
<br>  

<h2 id="UDP-套接字编程"><a href="#UDP-套接字编程" class="headerlink" title="UDP 套接字编程"></a>UDP 套接字编程</h2><h3 id="UDP-Socket-编程"><a href="#UDP-Socket-编程" class="headerlink" title="UDP Socket 编程"></a>UDP Socket 编程</h3><p>UDP：在客户端和服务器之间没有连接  </p>
<ul>
<li>没有握手  </li>
<li>发送端在每一个报文中明确指定目标的 IP 地址和端口号  </li>
<li>服务器必须从收到的分组中提取出发送端的 IP 地址和端口号  </li>
</ul>
<p>UDP 传送的数据可能乱序也可能丢失<br>进程视角看 UDP 服务：UDP 位客户端和服务器提供<strong>不可靠的</strong>字节组传送服务  </p>
<h3 id="Client-server-socket-交互：UDP"><a href="#Client-server-socket-交互：UDP" class="headerlink" title="Client/server socket 交互：UDP"></a>Client/server socket 交互：UDP</h3><p><img src="/2022/03/23/computernetworknotes2/UDPcs.png"></p>
<p><strong>C 客户端 UDP 代码</strong><br><img src="/2022/03/23/computernetworknotes2/UDPccode1.png" alt="C 客户端 UDP 代码样例">  </p>
<p><img src="/2022/03/23/computernetworknotes2/UDPccode2.png" alt="C 客户端 UDP 代码样例"></p>
<p><strong>C 服务器 UDP 代码</strong><br><img src="/2022/03/23/computernetworknotes2/UDPscode1.png" alt="C 服务器 UDP 代码">  </p>
<p><img src="/2022/03/23/computernetworknotes2/UDPscode2.png" alt="C 服务器 UDP 代码"></p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>CATsama：如何做一个定时发嘟的 Mastodon bot</title>
    <url>/2022/07/12/catsama/</url>
    <content><![CDATA[<center> 性感猫猫，每日上午八点半，在您的时间线上推送一个喵喵神签 </center>
<span id="more"></span>

<br>

<p>在缪尚后厅和大家聊天时，猫猫从键盘经过，留下一串神秘文字。大家一致认为这是猫猫给我们留下的忠告，因此决定在缪尚给猫猫神开个位置，就有了这个喵喵喵账号。让我们有请 CATsama！  </p>
<h2 id="在-VPS-上安装-python"><a href="#在-VPS-上安装-python" class="headerlink" title="在 VPS 上安装 python"></a>在 VPS 上安装 python</h2><p>综合此方和塔塔的教程，决定安装 miniconda。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 /root 文件夹执行如下命令</span></span><br><span class="line">mkdir miniconda</span><br><span class="line"><span class="built_in">cd</span> miniconda</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 python 最新版本并用 bash 安装</span></span><br><span class="line">wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">sh Miniconda3-latest-Linux-x86_64.sh //用bash安装</span><br></pre></td></tr></table></figure>

<p>之后会有很长一段的文字，都是许可说明，一直按 <code>Enter</code> 即可，直到出现 <code>Do you accept the license terms? [yes|no]</code> 输入 <code>yes</code>，开启正式安装。安装路径直接使用默认 <code>/root/miniconda3</code>。<br>安装完成后会询问是否运行 <code>conda init</code> 来初始化，选择 <code>yes</code>。<br>检查是否安装成功，重启终端后输入 <code>conda --version</code>。  </p>
<h2 id="安装-bot"><a href="#安装-bot" class="headerlink" title="安装 bot"></a>安装 bot</h2><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><p>注册 Mastodon 账号，在管理面板找到开发-创建新应用，创建新应用并给予读写权限，复制访问令牌。<br>由于 Fedi 有许多 bot 账号，为避免 bot 账号之间陷入无限回复循环，建议勾选账号设置中的 “这是一个机器人账户”。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>创建存放 bot 相关文件的文件夹，这里模仿塔塔，存在 <code>/root/miniconda</code> 下。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码来源于塔塔</span></span><br><span class="line"><span class="built_in">cd</span> miniconda</span><br><span class="line">conda create -n mastbot python=3.8 <span class="comment"># 创建一个叫mastbot的版本为3.8的python虚拟环境，如果已经创建了就不用了</span></span><br><span class="line">conda activate mastbot <span class="comment"># 激活mastbot环境，root账号前会出现（mastbot）</span></span><br><span class="line">pip3 install requests beautifulsoup4 Mastodon.py <span class="comment"># 安装mastodon.py</span></span><br><span class="line">pip3 install numpy <span class="comment"># 安装 numpy，catsama 需要</span></span><br><span class="line">mkdir catsama</span><br><span class="line"><span class="built_in">cd</span> catsama</span><br><span class="line">nano mybot_usercred.secret <span class="comment"># 写入刚才复制的访问令牌，保存退出</span></span><br><span class="line">nano catsama.py <span class="comment"># 发嘟脚本</span></span><br></pre></td></tr></table></figure>

<p>发嘟 python 脚本框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> mastodon <span class="keyword">import</span> Mastodon</span><br><span class="line"></span><br><span class="line">mastodon = Mastodon(</span><br><span class="line">    access_token = <span class="string">&#x27;mybot_usercred.secret&#x27;</span>,</span><br><span class="line">    api_base_url = <span class="string">&#x27;实例地址&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要发送的内容放在当前文件夹下面的 `content.txt` 里，每行一句</span></span><br><span class="line">content = random.choice(<span class="built_in">open</span>(<span class="string">&quot;content.txt&quot;</span>).read().splitlines())  </span><br><span class="line"><span class="comment"># content 即为发送嘟文的内容，可根据 bot 的需要替换为不同内容</span></span><br><span class="line"></span><br><span class="line">mastodon.status_post(content)</span><br></pre></td></tr></table></figure>

<p>上述工作完成后，<code>python bot.py</code> 运行脚本。如果顺利，bot 就会发出嘟嘟；如有报错，根据报错信息修改。  </p>
<h2 id="定时发嘟"><a href="#定时发嘟" class="headerlink" title="定时发嘟"></a>定时发嘟</h2><p>想要实现定时发嘟肯定不能人工蹲点，而要实现自动化。使用 <code>crontab</code> 设置定时任务，定时自动运行 <code>python bot.py</code> 即可实现定时发嘟。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30 2 * * *  cd /root/miniconda/catsama &amp;&amp; /root/miniconda3/envs/mastbot/bin/python catsama.py &gt;&gt; /root/miniconda/catsama/log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>设置为每天服务器时间 2：30 发送一条喵签。如有报错信息，将输出到 log.txt，可根据报错修改。  </p>
<h2 id="catsama-脚本存档"><a href="#catsama-脚本存档" class="headerlink" title="catsama 脚本存档"></a>catsama 脚本存档</h2><p>生成一个含有字母、数字、特殊符号和汉字的字符串，这串字符即为喵签内容。如果遇到低概率随机生成的串为空或最终输出的部分为空，则从 ABC 的朋友们名字中选择一个作为喵签内容。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np, numpy.random</span><br><span class="line"><span class="keyword">from</span> mastodon <span class="keyword">import</span> Mastodon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成num个中文字符并输出为list</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GBK2312</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">        head = random.randint(<span class="number">0xb0</span>, <span class="number">0xf7</span>)</span><br><span class="line">        body = random.randint(<span class="number">0xa1</span>, <span class="number">0xfe</span>)</span><br><span class="line">        val = <span class="string">f&#x27;<span class="subst">&#123;head:x&#125;</span><span class="subst">&#123;body:x&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">str</span> = <span class="built_in">str</span> + <span class="built_in">bytes</span>.fromhex(val).decode(<span class="string">&#x27;gb2312&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成num个数字并输出为list</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listNum</span>(<span class="params">num</span>):</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nums) &lt; num:</span><br><span class="line">        i = random.randint(<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">        nums.append(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">str</span>(nums))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成猫签</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predictfuture</span>():</span></span><br><span class="line">    <span class="comment"># 随机生成n个数字</span></span><br><span class="line">    numN = random.randint(<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">    num = listNum(numN)</span><br><span class="line">    <span class="comment"># 随机生成n个字母</span></span><br><span class="line">    src_letters = string.ascii_letters</span><br><span class="line">    letN = random.randint(<span class="number">0</span>,<span class="number">26</span>)</span><br><span class="line">    letters = random.sample(src_letters,letN)</span><br><span class="line">    <span class="comment"># 随机生成n个特殊字符</span></span><br><span class="line">    spN = random.randint(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">    src_special = string.punctuation</span><br><span class="line">    special = random.sample(src_special,spN)</span><br><span class="line">    <span class="comment"># 随机生成n个汉字</span></span><br><span class="line">    chN = random.randint(<span class="number">0</span>,<span class="number">26</span>)</span><br><span class="line">    chinese = GBK2312(chN)</span><br><span class="line">    <span class="comment"># 合并所有随机生成的内容</span></span><br><span class="line">    ran_list = num + letters + special + chinese</span><br><span class="line">    <span class="comment"># 随机打乱生成的内容</span></span><br><span class="line">    random.shuffle(ran_list)</span><br><span class="line">    <span class="comment"># print(ran_list)</span></span><br><span class="line">    <span class="comment"># list转str</span></span><br><span class="line">    temp = <span class="string">&#x27;&#x27;</span>.join(ran_list)</span><br><span class="line">    numS = numN + letN + spN + chN</span><br><span class="line">    <span class="comment"># 填补可能出现的所有类型字符都为0或随机长度为0的情况</span></span><br><span class="line">    ABC_list = [<span class="string">&#x27;Enjolras&#x27;</span>, <span class="string">&#x27;Combeferre&#x27;</span>, <span class="string">&#x27;Jean prouvaire&#x27;</span>, <span class="string">&#x27;Feuilly&#x27;</span>, <span class="string">&#x27;Courfeyrac&#x27;</span>,<span class="string">&#x27; Bahorel&#x27;</span>, <span class="string">&#x27;Lesgle or Laigle&#x27;</span>, <span class="string">&#x27;Joly&#x27;</span>, <span class="string">&#x27;Grantaire&#x27;</span>]</span><br><span class="line">    friendABC = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(ABC_list)-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 输出猫猫语</span></span><br><span class="line">    <span class="keyword">if</span> numS == <span class="number">0</span>:</span><br><span class="line">        catsama = ABC_list[friendABC]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        catl = random.randint(<span class="number">0</span>,numS)</span><br><span class="line">        <span class="keyword">if</span> catl == <span class="number">0</span>:</span><br><span class="line">            catsama = ABC_list[friendABC]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            catsama = temp[<span class="number">0</span>:catl]</span><br><span class="line">    <span class="keyword">return</span> catsama</span><br><span class="line"></span><br><span class="line">mastodon = Mastodon(</span><br><span class="line">    access_token = <span class="string">&#x27;mybot_usercred.secret&#x27;</span>,</span><br><span class="line">    api_base_url = <span class="string">&#x27;https://musain.cafe&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">content = predictfuture() + <span class="string">&#x27;, miao!&#x27;</span></span><br><span class="line"><span class="comment"># print(content)</span></span><br><span class="line"></span><br><span class="line">mastodon.status_post(content)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Bot</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 4：Network Layer (1)</title>
    <url>/2022/06/07/computernetworknotes4/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络第四章网络层：数据平面 </center>
<span id="more"></span>

<br>

<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><p>在发送主机和接收主机对之间传送段 (segment)<br>在发送端将段封装到数据报中<br>在接收端，将段上交给传输层实体<br>网络层协议存在于每一个主机和路由器<br>路由器检查每一个经过它的 IP 数据报的头部  </p>
<h3 id="网络层的关键功能"><a href="#网络层的关键功能" class="headerlink" title="网络层的关键功能"></a>网络层的关键功能</h3><p><strong>转发</strong>：将分组从路由器的输入接口转发到合适的输出接口<br><strong>路由</strong>：使用路由算法来决定分组从发送主机到目标接收主机的路径  </p>
<ul>
<li>路由选择算法  </li>
<li>路由选择协议  </li>
</ul>
<h3 id="数据平面与控制平面"><a href="#数据平面与控制平面" class="headerlink" title="数据平面与控制平面"></a>数据平面与控制平面</h3><p><strong>数据平面</strong>  </p>
<ul>
<li>本地，每个路由器功能  </li>
<li>决定从路由器输入端口到达的分组如何转发到输出端口  </li>
<li>转发功能  <ul>
<li>传统方式：基于目标地址 + 转发表  </li>
<li>SDN 方式：集于多个字段 + 流表  </li>
</ul>
</li>
</ul>
<p><strong>控制平面</strong>  </p>
<ul>
<li>网络范围内的逻辑  </li>
<li>决定数据报如何在路由器之间路由，决定数据报从源道目标主机之间的端到端路径  </li>
<li>2 个控制平面方法  <ul>
<li>传统的路由算法：在路由器中被实现  </li>
<li>software-defined networking (SND)：在远程的服务器中实现  </li>
</ul>
</li>
</ul>
<h4 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h4><p>每-路由器(Per-router)控制平面<br>在每一个路由器中的单独路由器算法元件，在控制平面进行交互  </p>
<p><img src="/2022/06/07/computernetworknotes4/traditionalway.png">  </p>
<p>控制平面、数据平面紧紧耦合<br>路由和转发的相互作用  </p>
<p><img src="/2022/06/07/computernetworknotes4/traditional.png">  </p>
<h4 id="SDN-方式"><a href="#SDN-方式" class="headerlink" title="SDN 方式"></a>SDN 方式</h4><p>逻辑集中的控制平面<br>一个不同的(通常是远程的)控制器与本地控制代理(CAs)交互  </p>
<p><img src="/2022/06/07/computernetworknotes4/SDNway.png">  </p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p>对于单个数据报的服务  </p>
<ul>
<li>可靠传送  </li>
<li>延迟保证，如：少于 40 ms 的延迟  </li>
</ul>
<p>对于数据报流的服务  </p>
<ul>
<li>保存数据报传送  </li>
<li>保证流的最小带宽  </li>
<li>分组之间的延迟差  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/servicemodel.png"></p>
<h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><p>在某些网络架构中是第三个重要的功能  </p>
<ul>
<li>ATM, frame relay, X.25  </li>
</ul>
<p>在分组传输之前，在两个主机之间，再通过一些路由器所构成的路径上建立一个网络层连接  </p>
<ul>
<li>涉及到路由器  </li>
</ul>
<p>网络层和传输层连接服务区别  </p>
<ul>
<li><strong>网络层</strong>：在 2 个主机之间，涉及到路径上的一些路由器  </li>
<li><strong>传输层</strong>：在 2 个进程之间，很可能只体现在端系统上 (TCP 连接)  </li>
</ul>
<br>

<h2 id="路由器组成"><a href="#路由器组成" class="headerlink" title="路由器组成"></a>路由器组成</h2><h3 id="路由器结构概况"><a href="#路由器结构概况" class="headerlink" title="路由器结构概况"></a>路由器结构概况</h3><p>高层面(非常简化的)通用路由器体系架构：  </p>
<ul>
<li>路由：运行<strong>路由</strong>选择算法/协议(RIP, OSPF, BGP)-生成路由表  </li>
<li>转发：从输入到输出链路交换数据报-根据路由表进行分组的<strong>转发</strong>  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/luyouqi.png">  </p>
<h3 id="输入端口功能"><a href="#输入端口功能" class="headerlink" title="输入端口功能"></a>输入端口功能</h3><p><strong>物理层</strong>：Bit 级的接收<br><strong>数据链路层</strong>：链路层协议动作、解封装<br><strong>分布式交换</strong>：  </p>
<ul>
<li>根据数据报头部信息，如目的地址，在输入端口内存中的转发表中查找合适的输出端口 (匹配 + 行动)  </li>
<li>基于目的的转发：仅仅依赖于 IP 数据包的目标 IP 地址 (传统方法)  </li>
<li>通用转发：基于头部字段的任意集合进行转发  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/inputfunction.png">  </p>
<h3 id="输入端口缓存"><a href="#输入端口缓存" class="headerlink" title="输入端口缓存"></a>输入端口缓存</h3><p>当交换机构的速率小于输入端口的汇聚速率时，在输入端口可能要排队：排队延迟以及由于输入缓存溢出造成丢失<br>Head-of-the-line (HOL) blocking：排在队头的数据报阻止了队列中其它数据报向前移动  </p>
<p><img src="/2022/06/07/computernetworknotes4/inputhuancun.png"></p>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><p>将分组从输入缓冲区传输到合适的输出端口<br>交换速率：分组可以按照该速率从输入传输到输出  </p>
<ul>
<li>运行速度经常是输入/输出链路速率的若干倍  </li>
<li>N个输入端口：交换机构的交换速率是输入线路速度的 N 倍比较理想，才不会成为瓶颈  </li>
</ul>
<p>3 种典型的交换机构：<br><img src="/2022/06/07/computernetworknotes4/switch3.png">  </p>
<h4 id="通过内存交换"><a href="#通过内存交换" class="headerlink" title="通过内存交换"></a>通过内存交换</h4><p>第一代路由器：  </p>
<ul>
<li>在 CPU 直接控制下的交换，采用传统的计算机  </li>
<li>分组倍拷贝到系统内存，CPU 从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口  </li>
<li>转发速率被内存的带宽限制 (数据报通过 BUS 两遍)  </li>
<li>一次只能转发一个分组  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/memory.png">  </p>
<h3 id="通过总线交换"><a href="#通过总线交换" class="headerlink" title="通过总线交换"></a>通过总线交换</h3><p>数据报通过共享总线，从输入端口转发到输出端口<br>总线竞争：交换速度受限于总线带宽<br>1 次处理一个分组<br>1 Gbps bus, Cisco 1900；32 Gbps bus, Cisco 5600；对于接入或企业级路由器，速度足够，但不适合区域或骨干网络  </p>
<p><img src="/2022/06/07/computernetworknotes4/bus.png">  </p>
<h3 id="通过互联网络-crossbar-等-的交换"><a href="#通过互联网络-crossbar-等-的交换" class="headerlink" title="通过互联网络 (crossbar 等) 的交换"></a>通过互联网络 (crossbar 等) 的交换</h3><p>同时并发转发多个分组，克服总线带宽限制<br>Banyan (榕树) 网络，crossbar (纵横) 和其它的互联网络被开发，将多个处理器连接成多处理器<br>当分组从端口 A 到达，转给端口 Y：控制器短接相应的两个总线<br>高级设计：将数据报分片为固定长度的信元，通过交换网络交换<br>Cisco 12000：以 60 Gbps 的交换速率通过互联网络  </p>
<p><img src="/2022/06/07/computernetworknotes4/crossbar.png"></p>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p>当数据报从交换机构的到达速度比传输速度快，就需要输出端口缓存  </p>
<ul>
<li>数据报 (分组) 可能会被丢弃，由于拥塞，缓冲区没有空间  </li>
</ul>
<p>由<strong>调度规则</strong>选择排队的数据报进行传输  </p>
<ul>
<li>优先权调度-谁会获得最优性能，网络中立？  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/output.png">  </p>
<h3 id="输出端口排队"><a href="#输出端口排队" class="headerlink" title="输出端口排队"></a>输出端口排队</h3><p>假设交换速率 Rswitch 是 Rline 的 N 倍 (N：输入端口的数量)<br>当多个输入端口同时向输出端口发送时，缓冲该分组 (当通过交换网络到达的速率超过输出速率则缓存)<br>排队带来延迟，由于输出端口缓存溢出则丢弃数据报  </p>
<p><img src="/2022/06/07/computernetworknotes4/outputqueue.png">  </p>
<h3 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h3><p><strong>调度</strong>：选择下一个要通过链路传输的分组<br>FIFO (first in first out) scheduling：按照分组到来次序发送  </p>
<ul>
<li>丢弃策略：如果分组到达一个满的队列，哪个分组将会被抛弃  <ul>
<li>tail drop：丢弃刚到达的分组  </li>
<li>priority：根据优先权丢失/移除分组  </li>
<li>random：随机丢弃/移除  </li>
</ul>
</li>
</ul>
<h4 id="优先权"><a href="#优先权" class="headerlink" title="优先权"></a>优先权</h4><p>优先权调度：发送最高优先权的分组<br>多类，不同类别有不同的优先权  </p>
<ul>
<li>类别可能依赖于标记或其它的头部字段，eg. IP source/dest, port numbers, ds, etc.  </li>
<li>先传最高优先级的队列中的分组，除非没有  </li>
<li>高(低)优先权种的分组传输次序：FIFO  </li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>Round Robin(RR) scheduling：  </p>
<ul>
<li>多类  </li>
<li>循环扫描不同类型的队列，发送完一类的一个分组，再发送下一个类的一个分组，循环所有类</li>
</ul>
<p>Weighted Fair Queuing (WFQ)：  </p>
<ul>
<li>一般化的 Round Robin  </li>
<li>在一段时间内，每个队列得到的任务时间是：W<sub>i</sub>/(XIGMA(W<sub>i</sub>)) * t，和权重成正比  </li>
<li>每个类在一个循环中获得不同权重的服务量</li>
</ul>
<br>

<h2 id="IP-Internet-Protocol"><a href="#IP-Internet-Protocol" class="headerlink" title="IP Internet Protocol"></a>IP Internet Protocol</h2><h3 id="互联网的网络层"><a href="#互联网的网络层" class="headerlink" title="互联网的网络层"></a>互联网的网络层</h3><p>主机，路由器种的网络层功能：</p>
<p><img src="/2022/06/07/computernetworknotes4/InternetNet.png">  </p>
<h3 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h3><p>IPv4 数据报格式：  </p>
<p><img src="/2022/06/07/computernetworknotes4/IPform.png">  </p>
<h3 id="IP-分片和重组-Fragmentation-amp-Reassembly"><a href="#IP-分片和重组-Fragmentation-amp-Reassembly" class="headerlink" title="IP 分片和重组 (Fragmentation &amp; Reassembly)"></a>IP 分片和重组 (Fragmentation &amp; Reassembly)</h3><p>网络链路有 MTU (最大传输单元) - 链路层帧所携带的最大数据长度  </p>
<ul>
<li>不同的链路类型  </li>
<li>不同的 MTU  </li>
</ul>
<p>大的 IP 数据报在网络上被分片 (fragmented)  </p>
<ul>
<li>一个数据报被分割成若干个小数据报  <ul>
<li>相同的 ID  </li>
<li>不同的偏移量  </li>
<li>最后一个分片标记为 0  </li>
</ul>
</li>
<li>“重组” 只在最终的目标主机进行  </li>
<li>IP 头部的信息被用于标识、排序相关分片  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/FRexample.png">  </p>
<h3 id="IP-编址"><a href="#IP-编址" class="headerlink" title="IP 编址"></a>IP 编址</h3><p>IP 地址：32 位标示，对主机或路由器的接口编址<br>接口：主机/路由器和物理链路的连接处  </p>
<ul>
<li>路由器通常拥有多个接口  </li>
<li>主机也有可能有多个接口  </li>
<li>IP 地址和每一个接口关联  </li>
</ul>
<p>一个 IP 地址和一个接口相关联<br>这些接口如何连接：  </p>
<ul>
<li>有线以太网网口链接到以太网络交换机连接  </li>
<li>无线 WiFi 接口被 WiFi 基站连接  </li>
</ul>
<h3 id="子网-Subsets"><a href="#子网-Subsets" class="headerlink" title="子网 (Subsets)"></a>子网 (Subsets)</h3><p>IP 地址：</p>
<ul>
<li>子网部分 (高位 bits)  </li>
<li>主机部分 (低位 bits)  </li>
</ul>
<p><strong>子网</strong>：  </p>
<ul>
<li>一个子网内的节点 (主机或者路由器)，它们的 <strong>IP 地址的高位部分相同</strong>，这些节点构成的网络的一部分叫做子网  </li>
<li><strong>无需路由器介入</strong>，子网内个主机可以在物理上相互直接到达  </li>
</ul>
<p><strong>方法</strong>：  </p>
<ul>
<li>要判断一个子网，将每一个接口从主机或者路由器上分开，构成了一个个网络的孤岛  </li>
<li>每一个孤岛 (网络) 都可以被称之为 subset  </li>
</ul>
<p>子网掩码：11111111 11111111 11111111 00000000<br>subset mask：/24  </p>
<h3 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h3><p>单播地址：<br>Class A: 126 networks, 16 million hosts<br>Class B: 16382 networks, 64 K hosts<br>Class C: 2 million networks, 254 host<br>组播地址：<br>Class D: multicast<br>预留：<br>Class E: reserved for future  </p>
<p><img src="/2022/06/07/computernetworknotes4/IPclass.png">  </p>
<h3 id="特殊-IP-地址"><a href="#特殊-IP-地址" class="headerlink" title="特殊 IP 地址"></a>特殊 IP 地址</h3><p><strong>一些约定：</strong>  </p>
<ul>
<li>子网部分：全为 0 — 本网络  </li>
<li>主机部分：全为 0 — 本主机  </li>
<li>主机部分：全为 1 — 广播地址，这个网络的所有主机  </li>
<li>127.x.x.x: 回路地址/测试地址  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/spIP.png">  </p>
<p><strong>内网 (专用) IP 地址</strong>  </p>
<ul>
<li>专用地址：地址空间的一部分供专用地址使用  </li>
<li>永远不会被当作共用地址来分配，不会与公用地址重复<ul>
<li>只在局部网络中有意义，区分不同的设备  </li>
</ul>
</li>
<li>路由器不对目标地址是专用地址的分组进行转发  </li>
<li>专用地址范围：<ul>
<li>Class A 10.0.0.0 - 10.255.255.255 MASK 255.0.0.0  </li>
<li>Class B 172.16.0.0 - 172.31.255.255 MASK 255.255.0.0  </li>
<li>Class C 192.168.0.0 - 192.168.255.255 MASK 255.255.255.0  </li>
</ul>
</li>
</ul>
<h3 id="IP-编址：CIDR"><a href="#IP-编址：CIDR" class="headerlink" title="IP 编址：CIDR"></a>IP 编址：CIDR</h3><p><strong>CIDR</strong>：Classless InterDomain Routing (无类域间路由)  </p>
<ul>
<li>子网部分可以在任意的位置  </li>
<li>地址格式：a.b.c.d/x，其中 x 是地址中子网号的长度  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/CIDR.png">  </p>
<h3 id="转发表和转发算法"><a href="#转发表和转发算法" class="headerlink" title="转发表和转发算法"></a>转发表和转发算法</h3><p>目标子网号 | 掩码 | 下一跳 | 端口  </p>
<p><img src="/2022/06/07/computernetworknotes4/IPtransfer.png">  </p>
<ul>
<li>获得 IP 数据报的目标地址  </li>
<li>对于转发表中的每一个表项  <ul>
<li>如 (IP Des addr) &amp; (mask) == destination，则按照表项对应的接口转发该数据报  </li>
<li>如果没有找到，则使用默认表项转发数据报  </li>
</ul>
</li>
</ul>
<h3 id="如何获得一个-IP-地址"><a href="#如何获得一个-IP-地址" class="headerlink" title="如何获得一个 IP 地址"></a>如何获得一个 IP 地址</h3><h4 id="主机如何获得"><a href="#主机如何获得" class="headerlink" title="主机如何获得"></a>主机如何获得</h4><p>系统管理员将地址配置在一个文件中  </p>
<ul>
<li>Wintel: control-panel -&gt; network -&gt; configuration -&gt; tcp/ip -&gt; properties  </li>
<li>UNIX: /etc/rc.config<br>DHCP (Dynamic Host Configuration Protocol)：从服务器中动态获得一个 IP 地址  </li>
<li>plug-and-play  </li>
</ul>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>目标：允许主机在加入网络的时候，动态地从服务器哪里获得 IP 地址：  </p>
<ul>
<li>可以更新对主机在用 IP 地址的租用期 - 租期快到了  </li>
<li>重新启动时，允许重新使用以前用过的 IP 地址  </li>
<li>支持移动用户加入到该网络 (短期在网)  </li>
</ul>
<p>工作概况：  </p>
<ul>
<li>主机广播 “DHCP discover” 报文 [可选]  </li>
<li>DHCP 服务器用 “DHCP offer” 提供报文相应 [可选]  </li>
<li>主机请求 IP 地址：发送 “DHCP request” 报文  </li>
<li>DHCP 服务器发送地址：“DHCP ack” 报文  </li>
</ul>
<p>DHCP client-server scenario:  </p>
<p><img src="/2022/06/07/computernetworknotes4/DHCPclientserver.png"></p>
<h4 id="获得一个网络的子网部分"><a href="#获得一个网络的子网部分" class="headerlink" title="获得一个网络的子网部分"></a>获得一个网络的子网部分</h4><p>从 ISP 获得地址块中分配一个小地址块  </p>
<p>一个 ISP 如何获得一个地址块？<br>ICANN: Internet Corporation for Assigned Names and Numbers  </p>
<ul>
<li>分配地址  </li>
<li>管理 DNS  </li>
<li>分配域名，解决冲突  </li>
</ul>
<h3 id="层次编址"><a href="#层次编址" class="headerlink" title="层次编址"></a>层次编址</h3><p><strong>路由聚集</strong> (route aggregation):<br>层次编址允许路由信息的有效广播<br>支持有空洞的、大概的聚集  </p>
<p><img src="/2022/06/07/computernetworknotes4/RA.png">  </p>
<p><strong>特殊路由信息</strong> (more specific routes)：<br>ISPs-R-Us 拥有一个对组织 1 更加精确的路由<br>匹配时，多个匹配采用最长匹配 (最精确)  </p>
<p><img src="/2022/06/07/computernetworknotes4/msr.png"></p>
<h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT: Network Address Translation"></a>NAT: Network Address Translation</h3><p>网络间地址转换：出去时将所有内网地址转换为同一个机构 IP 地址，转回来时再由机构 IP 地址转回主机</p>
<p><img src="/2022/06/07/computernetworknotes4/NAT.png">  </p>
<p>动机：本地网络只有一个有效 IP 地址  </p>
<ul>
<li>不需要从 ISP 分配一块地址，可用一个 IP 地址用于所有的 (局域网) 设备 —— 省钱  </li>
<li>在局域网改变设备地址的情况下无须通知外界  </li>
<li>可以改变 ISP (地址变化) 而不需要改变内部的设备地址  </li>
<li>局域网内部的设备没有明确的地址，对外是不可见的 —— 安全  </li>
</ul>
<p>实现：NAT 路由器必须  </p>
<ul>
<li>外出数据包：替换源地址和端口号为 NAT IP 地址和新的端口号，目标 IP 和端口号不变  <ul>
<li>远端的 C/S 将会用 NAP IP 地址，新端口号作为目标地址  </li>
</ul>
</li>
<li>记住每个转换替换对 (在 NAT 转换表中)  <ul>
<li>源 IP，端口 vs NAP IP，新端口</li>
</ul>
</li>
<li>进入数据包：替换目标 IP 地址和端口号，采用存储在 NAT 表中的mapping 表项，用 (源 IP，端口)  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/NATprocess.png">  </p>
<p>16-bit 端口字段：6 万多个同时连接，要给局域网  </p>
<p>NAT 争议：  </p>
<ul>
<li>路由器之应该对第 3 层做信息处理，而这里对端口号 (4 层) 做了处理  </li>
<li>违反了 end-to-end 原则  <ul>
<li>端到端原则：复杂性放到网络边缘，无需借助中转和变换，就可以直接传送到目标主机  </li>
<li>NAT 可能要被一些应用设计者考虑，eg. P2P applications  </li>
<li>外网的机器无法主动连接到内网的机器上  </li>
</ul>
</li>
<li>地址短缺问题可以被 IPv6 解决  </li>
<li>NAT 穿越：如果客户端要连接 NAT 后面的服务器，如何操作  </li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/NATchuanyue1.png">  </p>
<p><img src="/2022/06/07/computernetworknotes4/NATchuanyue2.png">  </p>
<p><img src="/2022/06/07/computernetworknotes4/NATchuanyue3.png">  </p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>动机：  </p>
<ul>
<li>初始动机：32-bit 地址空间将会很快用完  </li>
<li>头部格式改变帮助加速处理和转发  <ul>
<li>TTL-1  </li>
<li>头部 checksum  </li>
<li>分片  </li>
</ul>
</li>
<li>头部格式改变帮助 QoS</li>
</ul>
<p>IPv6 数据报格式：  </p>
<ul>
<li>固定的 40 字节头部  </li>
<li>数据报传输过程中不允许分片 (源主机分片)  </li>
</ul>
<p>IPv6 头部 (Cont)  </p>
<ul>
<li>Priority：标示流中数据报的优先级  </li>
<li>Flow Label：表示数据包在一个 “flow” (“flow” 的概念没有被严格定义)  </li>
<li>Next header：标示上层协议  </li>
<li>Checksum：被移除，降低在每一段中的处理速度  </li>
<li>Options：允许，但是在头部之外，被 “Next Header” 字段标示  </li>
<li>ICMPv6：ICMP 的最新版本  <ul>
<li>附加了报文类型，eg. Packet too big  </li>
<li>多播组管理功能  </li>
</ul>
</li>
</ul>
<p><img src="/2022/06/07/computernetworknotes4/IPv6Cont.png">  </p>
<h3 id="IPv4-到-IPv6-的平移"><a href="#IPv4-到-IPv6-的平移" class="headerlink" title="IPv4 到 IPv6 的平移"></a>IPv4 到 IPv6 的平移</h3><p>不是所有的路由器都能够同时升级  </p>
<ul>
<li>没有一个标记日 “flag days”  </li>
<li>在 IPv4 和 IPv6 路由器混合时，网络如何运转？  </li>
</ul>
<p><strong>隧道</strong>：在 IPv4 路由器之间传输的 IPv4 数据报中写代 IPv6 数据报</p>
<br>

<h2 id="通用转发和-SDN"><a href="#通用转发和-SDN" class="headerlink" title="通用转发和 SDN"></a>通用转发和 SDN</h2><h3 id="网络层功能为例的数据平面和控制平面"><a href="#网络层功能为例的数据平面和控制平面" class="headerlink" title="网络层功能为例的数据平面和控制平面"></a>网络层功能为例的数据平面和控制平面</h3><p><strong>网络层功能</strong>：  </p>
<ul>
<li>转发：对于从某个端口到来的分组转发到合适的输出端口  </li>
<li>路由：决定分组从源端到目标端的路径 (路由算法)  </li>
</ul>
<p><strong>每个路由器 (Per Route) 的控制平面</strong>：每个路由器上都有实现路由算法原件 (它们之间需要相互交互) - 形成传统 IP 实现方式的控制平面  </p>
<ul>
<li>每台设备上既实现控制功能，又实现数据平面  </li>
<li>控制功能分布式实现  </li>
<li>路由表 - 粘连  </li>
</ul>
<p>缺陷：数量众多、功能各异的中间盒  </p>
<ul>
<li>路由器的网络层功能：  <ul>
<li>IP 转发：对于到来的分组按照路由表决定如何转发；数据平面  </li>
<li>路由：决定路径，计算路由表；处在控制平面  </li>
</ul>
</li>
<li>还有其他种类繁多网络设备 (中间盒)：  <ul>
<li>交换机；防火墙；NAT；IDS；负载均衡设备  </li>
<li>未来：不断增加的需求和相应的网络设备  </li>
<li>需要不同设备实现不同的网络功能  <ul>
<li>每台设备继承了控制平面和数据平面的功能  </li>
<li>控制平面分布式地实现了各种控制平面功能  </li>
<li>升级和部署网络设备非常困难  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络设备控制平面的实现方式特点"><a href="#网络设备控制平面的实现方式特点" class="headerlink" title="网络设备控制平面的实现方式特点"></a>网络设备控制平面的实现方式特点</h3><p>互联网网络设备：传统方式都是通过分布式，每台设备的方法来实现数据平面和控制平面功能  </p>
<ul>
<li>垂直集成：每台路由器或其它网络设备，包括：  <ul>
<li>硬件、在私有的操作系统  </li>
<li>互联网标准协议 (IP, RIP, IS-IS, OSPF, BGP) 的私有实现  </li>
<li>从上到下都有一个厂商提供 (代价大、被设备上 “绑架”)  </li>
</ul>
</li>
<li>每个设备都实现了数据平面和控制平面的事情  <ul>
<li>控制平面的功能是分布式实现的  </li>
</ul>
</li>
<li>设备基本上只能 (分布式升级困难) 按照固定方式工作，控制逻辑固化。不同的网络功能需要不哦那个的 “middle boxes”：防火墙、负载均衡设备、NAT boxes  </li>
</ul>
<p>(数据 + 控制平面) 集成 -&gt; (控制逻辑) 粉不 -&gt; 固化  </p>
<ul>
<li>代价大；升级困难；管理困难  </li>
</ul>
<p>问题：  </p>
<ul>
<li>垂直集成 &gt; 昂贵、不便于创新的生态  </li>
<li>分布式、货设备功能 == 网络设备种类繁多  <ul>
<li>无法改变路由等工作逻辑，无法实现流量工程等高级特性  </li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设备；管理困难  </li>
<li>要增加新的网络功能，需要设计、实现以及不舒心的特定设备，设备种类繁多  </li>
</ul>
</li>
</ul>
<p>解决：重新思考网络控制平面的处理方式  </p>
<ul>
<li>集中：远程的控制器集中实现控制逻辑  </li>
<li>远程：数据平面和控制平面的分离  </li>
</ul>
<h3 id="SDN：逻辑上集中的控制平面"><a href="#SDN：逻辑上集中的控制平面" class="headerlink" title="SDN：逻辑上集中的控制平面"></a>SDN：逻辑上集中的控制平面</h3><p>一个不同的 (通常是远程) 控制器和 CA 交互，控制器决定分组转发的逻辑 (可编程)，CA 所在设备执行逻辑  </p>
<p><img src="/2022/06/07/computernetworknotes4/SDN.png">  </p>
<p>特点：  </p>
<ul>
<li>通用 “flow-based” 基于流的匹配 + 行动，eg. OpenFlow  </li>
<li>控制平面和数据平面分离  </li>
<li>控制平面功能在数据交换设备之外实现  </li>
<li>可编程控制应用：在控制器之上以网络应用形式实现各种网络功能  </li>
</ul>
<h3 id="SDN-的主要思路"><a href="#SDN-的主要思路" class="headerlink" title="SDN 的主要思路"></a>SDN 的主要思路</h3><p>网络设备数据平面和控制平面分离<br>数据平面 - 分组交换机  </p>
<ul>
<li>将路由器、交换机和目前大多数网络设备的功能进一步抽象成：按照流表 (由控制平面设置的控制逻辑) 进行 PDU (帧、分组) 的动作 (包括转发、丢弃、拷贝、翻红、阻塞)  </li>
<li>统一化设备功能：SDN 交换机 (分组交换机)，执行控制逻辑  </li>
</ul>
<p>控制平面 - 控制器 + 网络应用  </p>
<ul>
<li>分离、集中  </li>
<li>计算和下发控制逻辑：流表  </li>
</ul>
<h3 id="SDN-控制平面和数据平面分离的优势"><a href="#SDN-控制平面和数据平面分离的优势" class="headerlink" title="SDN 控制平面和数据平面分离的优势"></a>SDN 控制平面和数据平面分离的优势</h3><p>水平集成控制平面的开放实现 (而非私有实现)，创造出更好的产业生态，促进发展  </p>
<ul>
<li>分组交换机、控制器和各种控制逻辑网络应用 app 可由不同厂商生产，专业化，引入竞争形成良好生态  </li>
</ul>
<p>集中式实现控制逻辑，网络管理容易  </p>
<ul>
<li>集中式控制器了解网络状况，编程简单  </li>
<li>避免路由器的误配置  </li>
</ul>
<p>基于流表的<strong>匹配 + 行动</strong>的工作方式允许可编程的分组交换机  </p>
<ul>
<li>实现流量工程等高级特性  </li>
<li>在此框架下实现各种新型 (未来) 的网络设备  </li>
</ul>
<h3 id="SDN-架构"><a href="#SDN-架构" class="headerlink" title="SDN 架构"></a>SDN 架构</h3><p>SDN 控制器 (网络OS)  </p>
<ul>
<li>维护网络状态信息  </li>
<li>通过上面的北向 API 和网络控制应用交互  </li>
<li>通过下面的南向 API 和网络交换机交互  </li>
<li>逻辑上集中，但是在是线上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法  </li>
</ul>
<p>网络控制应用  </p>
<ul>
<li>控制的大脑：采用下层提供的服务 (SDN 控制器提供的 API)，实现网络功能  <ul>
<li>路由器 交换机</li>
<li>接入控制 防火墙  </li>
<li>负载均衡  </li>
<li>其它功能</li>
</ul>
</li>
<li>非绑定：可以被第三方提供，与控制器厂商可以通常上不同，与分组交换机厂商也可以不同  </li>
</ul>
<h3 id="通用转发和-SDN-1"><a href="#通用转发和-SDN-1" class="headerlink" title="通用转发和 SDN"></a>通用转发和 SDN</h3><p>每个路由器包含一个流表 (被逻辑上集中的控制器计算和分发)  </p>
<h3 id="OpenFlow-数据平面抽象"><a href="#OpenFlow-数据平面抽象" class="headerlink" title="OpenFlow 数据平面抽象"></a>OpenFlow 数据平面抽象</h3><p>流：由分组 (帧) 头部字段所定义<br>通用转发：简单的分组处理规则  </p>
<ul>
<li>模式：将分组头部字段和流表进行匹配  </li>
<li>行动：对于匹配上的分组，可以是丢弃、转发、修改、将匹配的分组发送给控制器  </li>
<li>优先权 Priority：计歌模式匹配了，优先采用哪个，消除歧义  </li>
<li>计数器 Counters： #bytes 以及 #packets  </li>
</ul>
<p>路由器中的流表定义了路由器的匹配 + 行动规则 (流表由控制器计算并下发)  </p>
<h3 id="OpenFlow-抽象"><a href="#OpenFlow-抽象" class="headerlink" title="OpenFlow 抽象"></a>OpenFlow 抽象</h3><p>match + action：统一化各种网络设备提供的功能<br>目前几乎所有网络设备都可以在这个匹配 + 行动模式框架进行描述，具体化为各种网络设备包括未来的网络设备  </p>
<p>路由器  </p>
<ul>
<li>match：最长前缀匹配  </li>
<li>action：通过一条链路转发  </li>
</ul>
<p>交换机：  </p>
<ul>
<li>match：目标 MAC 地址  </li>
<li>action：转发或泛洪  </li>
</ul>
<p>防火墙  </p>
<ul>
<li>match：IP 地址和 TCP/UDP 端口号  </li>
<li>action：允许或者禁止</li>
</ul>
<p>NAT  </p>
<ul>
<li>match：IP 地址和端口号  </li>
<li>action：重写地址和端口号  </li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 6：A Top Down Approach</title>
    <url>/2022/09/06/computernetworknotes6/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络链路层和局域网 </center>
<span id="more"></span>

<br>

<h2 id="引论和服务"><a href="#引论和服务" class="headerlink" title="引论和服务"></a>引论和服务</h2><h3 id="网络节点的连接方式"><a href="#网络节点的连接方式" class="headerlink" title="网络节点的连接方式"></a>网络节点的连接方式</h3><p>点到点连接<br>多点连接：共享型介质；通过网络交换机  </p>
<h3 id="数据链路层和局域网"><a href="#数据链路层和局域网" class="headerlink" title="数据链路层和局域网"></a>数据链路层和局域网</h3><p>WAN：网络形式采用点到点链路  </p>
<ul>
<li>贷款大、距离远 (延迟打)：贷款延迟积大  </li>
<li>如果采用多点连接方式：竞争方式 (一旦冲突代价大)，令牌等协调方式 (在其中协调节点的发送代价大)  </li>
</ul>
<p>点到点的链路层服务实现非常简单，封装和解封装  </p>
<p>LAN：一般采用多点连接方式  </p>
<ul>
<li>连接到节点非常方便  </li>
<li>街道共享型介质上 (或网络交换机)，就可以连接所有其他节点  </li>
</ul>
<p>多点连接方式网络的链路层功能实现相当复杂  </p>
<ul>
<li>多点接入：协调各节点对共享型介质的访问和使用  </li>
<li>竞争方式：冲突之后的协调  </li>
<li>令牌方式：令牌产生、占有和释放等  </li>
</ul>
<h3 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>主机和路由器是节点 (网桥和交换机也是)：nodes<br>沿着通信路径，连接相邻节点通信信道的是链路：links  </p>
<ul>
<li>有线链路</li>
<li>无线链路  </li>
<li>局域网，共享型链路  </li>
</ul>
<p>第二层协议数据单元帧 (frame)，封装数据报  </p>
<p><strong>数据链路层</strong>负责从一个节点通过链路将 (帧重点) 数据报发送到<strong>物理相邻节点</strong>  </p>
<h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>数据报 (分组) 在不同的链路上以不同的链路协议传送：  </p>
<ul>
<li>第一跳链路：以太网  </li>
<li>中间链路：帧中继链路  </li>
<li>最后一跳：802.11  </li>
</ul>
<p>不同的链路协议提供不同的服务，如在链路层上提供 (或没有) 可靠数据传送  </p>
<h3 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h3><p>成帧，链路接入：  </p>
<ul>
<li>将数据报封装在帧中，加上帧头、帧尾部  </li>
<li>如果采用的是共享型介质，信道接入获得信道访问权  </li>
<li>在帧头部使用 “MAC” (物理) 地址来标示源和目的 (不同于 IP 地址)  </li>
</ul>
<p>在相邻两个节点完成可靠数据传输  </p>
<ul>
<li>在低出错率的链路上 (光纤和双绞线电缆) 很少使用  <ul>
<li>出错率低，没有必要再每一个帧中做差错控制的工作，协议复杂  <ul>
<li>发送端对每一帧进行差错控制编码，根据反馈做相应的动作  </li>
<li>接收端进行差错控制解码，反馈给发送端 (ACK，NAK)  </li>
</ul>
</li>
<li>在本层放弃可靠控制的工作，在网络层或传输层做可靠控制的工作，或根本不做可靠控制的工作  </li>
</ul>
</li>
<li>在高差错链路上需要进行可靠的数据传送<ul>
<li>高差错链路：无线链路  </li>
<li>出错率高，如果在链路层不做差错控制工作，漏出去的错误比较高，到了上层如果需要可靠控制的数据传输代价会很大 (不做 local recovery 总体代价大)  </li>
</ul>
</li>
</ul>
<p>流量控制：使得相邻的发送和接收方节点的速度匹配  </p>
<p>错误检测：  </p>
<ul>
<li>差错由信号衰减和噪声引起  </li>
<li>接收方检测出的错误：通知发送端进行重传或丢弃帧  </li>
</ul>
<p>差错纠正：接收端检查和纠正 bit 错误，不通过重传来纠正错误  </p>
<p>半双工和全双工  </p>
<ul>
<li>半双工：链路可以双向传输，但一次只有一个方向  </li>
<li>全双工：两个方向可以同时  </li>
</ul>
<h3 id="链路层实现位置"><a href="#链路层实现位置" class="headerlink" title="链路层实现位置"></a>链路层实现位置</h3><p>在每一个主机上，也在每个路由器上，交换机的每个端口上  </p>
<p>链路层功能在 “适配器” 上实现 (network interface card, NIC) 或在一个芯片组上  </p>
<ul>
<li>以太网卡，802.11 网卡；以太网芯片组  </li>
<li>实现链路层和相应的物理层功能  </li>
</ul>
<p>接到主机的系统总线上  </p>
<p>硬件、软件和固件的综合体</p>
<h3 id="适配器通信"><a href="#适配器通信" class="headerlink" title="适配器通信"></a>适配器通信</h3><p>发送方  </p>
<ul>
<li>在帧中封装数据报  </li>
<li>加上差错控制编码，实现 RDT 和流量控制功能等  </li>
</ul>
<p>接收方  </p>
<ul>
<li>检查有无出错，执行 RDT 和流量控制功等  </li>
<li>解封装数据报，将其交给上层  </li>
</ul>
<p>适配器是半自治的，实现了链路和物理层功能  </p>
<p><img src="/2022/09/06/computernetworknotes6/shipeiqi.png">  </p>
<br>

<h2 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h2><h3 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h3><p>EDC = 差错检测和纠正位 (冗余位)<br>D = 数据由差错检测保护，可以包含头部字段<br>错误检测不是 100% 可靠的：  </p>
<ul>
<li>协议会漏间一些错误 (很少)  </li>
<li>更长的 EDC 字段可以得到更好的检测和纠正效果  </li>
</ul>
<p><img src="/2022/09/06/computernetworknotes6/EDC.png">  </p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>单 bit 奇偶校验：检测单个 bit 级错误  </p>
<p><img src="/2022/09/06/computernetworknotes6/singlebit.png">  </p>
<p>2 维奇偶校验：检测和纠正单个 bit 错误  </p>
<p><img src="/2022/09/06/computernetworknotes6/2dsinglebit.png">  </p>
<h3 id="检验和：CRC-循环冗余校验"><a href="#检验和：CRC-循环冗余校验" class="headerlink" title="检验和：CRC (循环冗余校验)"></a>检验和：CRC (循环冗余校验)</h3><p>将数据比特 D 看作二进制的数据<br>生成多项式 G：双方协商 r+1 位模式 (r 次方)：生成和检验所使用的位模式<br>目标：选择 r 位 CRC 附加位 R，使得：  </p>
<ul>
<li>&lt;D, R&gt; 正好被 G 整除 (modulo 2)</li>
<li>接收方直到 G，将 &lt;D, R&gt; 除以 G，如果非 0 余数，检查出错误  </li>
<li>能检出所有少于 r+1 位的突发错误  </li>
</ul>
<p>实际应用：以太网、802.11 WiFi、ATM  </p>
<p><img src="/2022/09/06/computernetworknotes6/CRC.png">  </p>
<p>CRC 例子：  </p>
<p><img src="/2022/09/06/computernetworknotes6/CRCexample.png"></p>
<br>

<h2 id="多点访协议"><a href="#多点访协议" class="headerlink" title="多点访协议"></a>多点访协议</h2><h3 id="多路访问链接和协议"><a href="#多路访问链接和协议" class="headerlink" title="多路访问链接和协议"></a>多路访问链接和协议</h3><p>两种类型的链路 (一个子网内部链路链接形式)</p>
<ul>
<li><p><strong>点对点</strong>  </p>
<ul>
<li>拨号访问的 PPP  </li>
<li>以太网交换机和主机之间的点对点链路  </li>
</ul>
</li>
<li><p><strong>广播</strong> (共享线路或媒体)  </p>
<ul>
<li>传统以太网  </li>
<li>HFC 上行链路  </li>
<li>802.11 无线局域网  </li>
</ul>
</li>
</ul>
<h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><p>单个共享的广播型链路<br>2 个或更多站点同时传送：冲突 (collision)，多个节点在同一个时刻发送，则会收到 2 个或多个信号叠加  </p>
<h4 id="多路访问协议-介质访问控制协议：MAC"><a href="#多路访问协议-介质访问控制协议：MAC" class="headerlink" title="多路访问协议 (介质访问控制协议：MAC)"></a>多路访问协议 (介质访问控制协议：MAC)</h4><p>分布式算法：决定节点如何使用共享信道，即决定节点什么时候可以发送<br>关于共享控制的通信必须借助信道本身传输  </p>
<ul>
<li>没有带外的信道，各节点使用其协调信道使用  </li>
<li>用于传输控制信息  </li>
</ul>
<h4 id="理想的多路访问协议"><a href="#理想的多路访问协议" class="headerlink" title="理想的多路访问协议"></a>理想的多路访问协议</h4><p>给定：R bps 的广播信道<br>必要条件： </p>
<ol>
<li>当一个节点要发送时，可以 R 速率发送 </li>
<li>挡 M 个节点要发送，每个可以以 R/M 的平均速率发送  </li>
<li>完全分布的：没有特殊节点协调发送，没有时钟和时隙的同步  </li>
<li>简单  </li>
</ol>
<h4 id="MAC-媒体访问控制-协议分类"><a href="#MAC-媒体访问控制-协议分类" class="headerlink" title="MAC (媒体访问控制) 协议分类"></a>MAC (媒体访问控制) 协议分类</h4><p>信道划分：  </p>
<ul>
<li>把信道划分成小片 (时间、频率、编码)  </li>
<li>分配片给每个节点专用  </li>
</ul>
<p>随机访问：  </p>
<ul>
<li>信道不划分，允许冲突  </li>
<li>冲突后恢复  </li>
</ul>
<p>依次轮流：  </p>
<ul>
<li>节点依次轮流  </li>
<li>有很多数据传输的节点可以获得较长的信道使用权  </li>
</ul>
<h3 id="信道划分-MAC-协议"><a href="#信道划分-MAC-协议" class="headerlink" title="信道划分 MAC 协议"></a>信道划分 MAC 协议</h3><h4 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h4><p>TDMA： timd division multiple access  </p>
<ul>
<li>轮流使用信道，信道的时间分为周期  </li>
<li>每个站点使用每周期中固定的时隙 (长度 = 帧传输时间) 传输帧  </li>
<li>如果站点无帧传输，时隙空闲 -&gt; 浪费  </li>
<li>eg. 6 站 LAN，1、3、4 有数据报，时隙 2、5、6 空闲  </li>
</ul>
<p><img src="/2022/09/06/computernetworknotes6/TDMA.png">  </p>
<h4 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h4><p>FDMA： frequency division multiple access  </p>
<ul>
<li>信道的有效频率范围被分成一个个小的频段  </li>
<li>每个站点被分配一个固定的频段  </li>
<li>分配给站点的频段如果没有被使用，则空闲  </li>
</ul>
<p><img src="/2022/09/06/computernetworknotes6/FDMA.png">  </p>
<h4 id="码分多路访问-CDMA"><a href="#码分多路访问-CDMA" class="headerlink" title="码分多路访问 (CDMA)"></a>码分多路访问 (CDMA)</h4><p>CDMA：code division multiple access  </p>
<ul>
<li>所有站点在整个频段上同时进行传输，采用编码原理加以区分  </li>
<li>完全无冲突  </li>
<li>假定：信号同步很好，线性叠加  </li>
</ul>
<h3 id="随机存取协议"><a href="#随机存取协议" class="headerlink" title="随机存取协议"></a>随机存取协议</h3><p>当节点有帧要发送时  </p>
<ul>
<li>以信道带宽的全部 R bps 发送  </li>
<li>没有节点间的预先协调  </li>
</ul>
<p>两个或更多节点同时传输，会发生冲突 (collision)<br>随机存取协议规定：  </p>
<ul>
<li>如何检测冲突  </li>
<li>如何从冲突中恢复 (如，通过稍后的重传)  </li>
</ul>
<p>随机 MAC 协议  </p>
<ul>
<li>时隙 ALOHA  </li>
<li>ALOHA  </li>
<li>CSMA，CSMA/CD，CSMA/CA  </li>
</ul>
<h4 id="时隙-ALOHA"><a href="#时隙-ALOHA" class="headerlink" title="时隙 ALOHA"></a>时隙 ALOHA</h4><p>假设  </p>
<ul>
<li>所有帧是等长的  </li>
<li>时间被划分成相等的时隙，每个时隙可发送一帧  </li>
<li>节点支在时隙开始时发送帧  </li>
<li>节点在时钟上是同步的  </li>
<li>如果两个或多个节点在一个时隙传输，所有的站点都能检测到冲突  </li>
</ul>
<p>运行  </p>
<ul>
<li>当节点或去新的帧，在下一个时隙传输  </li>
<li>传输时没有检测到冲突，成功：节点能够在下一时隙发送新帧  </li>
<li>传输时检测到冲突，失败：节点在每一个随后的时隙以概率 p 重传帧直到成功  </li>
</ul>
<p>优点  </p>
<ul>
<li>节点可以以信道带宽全速连续传输  </li>
<li>高度分布：仅需要节点之间在时隙上的同步  </li>
<li>简单  </li>
</ul>
<p>缺点  </p>
<ul>
<li>存在冲突，浪费时隙  </li>
<li>即使有帧要发送，仍然有可能存在空闲的时隙  </li>
<li>节点检测冲突的时间 &lt; 帧传输的时间，必须传完  </li>
<li>需要时钟上同步  </li>
</ul>
<p><img src="/2022/09/06/computernetworknotes6/shixiALOHA.png">  </p>
<p>效率：当有很多节点，每个节点有很多帧要发送时，x % 的时隙是成功传输帧的时隙  </p>
<p><img src="/2022/09/06/computernetworknotes6/ALOHAefficiency.png">  </p>
<h4 id="纯-ALOHA-非时隙"><a href="#纯-ALOHA-非时隙" class="headerlink" title="纯 ALOHA (非时隙)"></a>纯 ALOHA (非时隙)</h4><p>无时隙 ALOHA：简单、无须节点间在时间上同步<br>当有帧需要传输：马上传输<br>冲突的概率增加：  </p>
<p><img src="/2022/09/06/computernetworknotes6/ALOHA.png">  </p>
<p><img src="/2022/09/06/computernetworknotes6/ALOHAef.png">  </p>
<h3 id="CSMA-冲突"><a href="#CSMA-冲突" class="headerlink" title="CSMA 冲突"></a>CSMA 冲突</h3><p>冲突仍然可能发生：由传播延迟造成，节点可能侦听不到正在进行的传输<br>冲突：整个冲突帧的传输时间都被浪费了，是无效传输<br>传播延迟 (距离) 决定了冲突的概率<br>节点依据本地的信道使用情况来判断全部信道的使用情况  </p>
<p><img src="/2022/09/06/computernetworknotes6/CSMAcollision.png"></p>
<h4 id="CSMA-CD-冲突检测"><a href="#CSMA-CD-冲突检测" class="headerlink" title="CSMA/CD (冲突检测)"></a>CSMA/CD (冲突检测)</h4><p>CSMA/CD：  </p>
<ul>
<li>载波侦听 CSMA：和在 CSMA 中一样发送钱侦听信道  </li>
<li>没有传完一个帧就可以在短时间内检测到冲突  </li>
<li>冲突发送时则传输终止，减少对信道的浪费  </li>
</ul>
<p>冲突检测 CD 技术，有线局域网中容易实现：  </p>
<ul>
<li>检测信号强度，比较传输与接收到的信号是否相同  </li>
<li>通过周期的过零点检测  </li>
</ul>
<p><img src="/2022/09/06/computernetworknotes6/CSMACD.png">  </p>
<p><strong>以太网 CSMA/CD 算法</strong>  </p>
<ol>
<li>适配器获取数据报，创建帧  </li>
<li>发送前：侦听信道 CS  </li>
</ol>
<ul>
<li>闲：开始传送帧  </li>
<li>忙：一直等到闲再发送  </li>
</ul>
<ol start="3">
<li>发送过程中，冲突检测 CD  </li>
</ol>
<ul>
<li>没有冲突：成功  </li>
<li>检测到冲突：放弃，之后尝试重发  </li>
</ul>
<ol start="4">
<li>发送方适配器检测到冲突，除放弃外，还发送一个 Jam 信号，所有听到冲突的适配器也是如此。  </li>
</ol>
<ul>
<li>强化冲突：让所有站点都知道冲突  </li>
</ul>
<ol start="5">
<li>如果放弃，适配器进入指数退避状态  </li>
</ol>
<ul>
<li>在第 m 次失败后，适配器随机选择一个 {0, 1, 2,…, 2^(m-1)} 中 K，等待 K*512 位时，然后转到步骤 2</li>
<li>exponential backoff：二进制指数退避算法  </li>
</ul>
<p><strong>指数退避</strong>  </p>
<ul>
<li>目标：适配器试图适应当前负载，在一个变化的碰撞窗口中随机选择时间点尝试重发  <ul>
<li>高负载：重传窗口时间打，减少冲突，但等待时间长  </li>
<li>低负载：使得个站点等待时间少，但冲突概率大  </li>
</ul>
</li>
<li>例：  </li>
</ul>
<p><img src="/2022/09/06/computernetworknotes6/ExpBackoff.png">  </p>
<p>CSMA/CD 效率  </p>
<p><img src="/2022/09/06/computernetworknotes6/CSMACDeff.png"></p>
<h4 id="无线局域网-CSMA-CA"><a href="#无线局域网-CSMA-CA" class="headerlink" title="无线局域网 CSMA/CA"></a>无线局域网 CSMA/CA</h4><p>WLAN 构成  </p>
<ul>
<li>基站：AP  </li>
<li>无线链路  </li>
<li>移动主机节点  </li>
</ul>
<p>冲突：2+ 站点 (AP 或者站点) 在同一个时刻发送<br>802.11：CSMA-发送前侦听信道；不会和其他节点正在进行的传输发生冲突<br>802.11：没有冲突检测  </p>
<ul>
<li>无法检测冲突：自身信号远远大于其它节点信号  </li>
<li>即使能 CD：冲突 ！= 不成功  </li>
<li>目标：avoid collisions (CSMA/CollisionAvoudance)  <ul>
<li>无法 CD，一旦发送一股脑全部发送完毕，不 CD  </li>
<li>为避免无 CD 带来的信道利用率低的问题，事前进行冲突避免  </li>
</ul>
</li>
</ul>
<p><strong>发送方</strong>：  </p>
<ol>
<li>如果站点侦测到信道空闲持续 DIFS 长，则传输整个帧 (no CD)  </li>
<li>如果侦测到信道忙碌，则选择一个随机回退值，并在信道空闲时递减该值；如果信道忙碌，回退值不会变化。倒数到 0 时 (只生在信道闲时) 发送整个帧。如果没有收到 ACK，增加回退值，重复 2</li>
</ol>
<p><strong>802.11 接收方</strong>：  </p>
<ul>
<li>如果帧正确，则在 SIFS 后发送 ACK  </li>
<li>无线链路特定，需要每帧确认；由于隐藏终端问题，在接收端可能形成干扰，接收方没有正确地接收到 (链路层可靠机制)  </li>
</ul>
<p>在 count down 时，真听到了信道空闲为什么不发送，而要等到 0 再发送：  </p>
<ul>
<li>2 个站点有数据帧需要发送，第三个节点正在发送  </li>
<li>LAN CD：让 2 者听到第三个节点发完，立即发送  <ul>
<li>冲突：放弃当前的发送，避免了信道浪费于无用冲突帧的发送  </li>
<li>代价不昂贵  </li>
</ul>
</li>
<li>WLAN CA<ul>
<li>无法 CD，一旦发送就必须发完，如冲突信道浪费严重，代价高昂  </li>
<li>思想：尽量实现避免冲突，而不是在发生冲突时放弃然后重发  </li>
<li>听到发送的站点，分别选择随机值，回退到 0 发送：不同随机值，一个站点会胜利；失败站点会冻结计数器，当胜利节点发完再发  </li>
</ul>
</li>
</ul>
<p>无法完全避免冲突  </p>
<p><img src="/2022/09/06/computernetworknotes6/CSMACA.png">  </p>
<p><strong>冲突避免</strong><br>思想：允许发送方 “预约” 信道，而不是随机访问该信道；避免长数据帧的冲突 (可选)  </p>
<ul>
<li>发送方首先使用 CSMA 向 BS 发送一个雄安的 RTS 分组：RTS 可能会冲突，但由于比较短，浪费信道较少  </li>
<li>BS 广播 clear-to-send CTS，作为 RTS 的响应  </li>
<li>CTS 能够被所有涉及到的节点听到：发送方发送数据帧；其它节点抑制发送  </li>
</ul>
<p>采用雄安的预约分组可以完全避免数据帧的冲突  </p>
<h4 id="线缆接入网络"><a href="#线缆接入网络" class="headerlink" title="线缆接入网络"></a>线缆接入网络</h4><p>多个 40 Mbps 下行 (广播) 信道，FDM  </p>
<ul>
<li>下行：通过 FDM 分成若干信道，互联网、数字电视等  </li>
<li>互联网信道：只有 1 个 CMTS 在其上传输  </li>
</ul>
<p>多个 30 Mbps 上行的信道，FDM  </p>
<ul>
<li>多路访问：所有用户使用；结者 TDM 分成微时隙  </li>
<li>部分时隙：分配；部分时隙；竞争  </li>
</ul>
<p><img src="/2022/09/06/computernetworknotes6/xianlanjieruwangluo.png">  </p>
<p>DOCSIS: TMD 上行信道  </p>
<ul>
<li>采用 TDM 的方式将上行信道分成若干微时隙：MAP 指定  </li>
<li>站点采用分配给它的微时隙上行微时隙：分配  </li>
<li>在特殊的上行微时隙中，个站点请求上行微时隙：竞争  <ul>
<li>个站点对于该时隙的使用时随机访问的  </li>
<li>一旦碰撞 (请求不臣工，结果是再下行的 MAP 中没有为它分配，则二进制退避) 选择时隙上传输  </li>
</ul>
</li>
</ul>
<p><img src="/2022/09/06/computernetworknotes6/xianlanjieruwangluo2.png">  </p>
<h3 id="轮流-Taking-Turns-MAC-协议"><a href="#轮流-Taking-Turns-MAC-协议" class="headerlink" title="轮流 (Taking Turns) MAC 协议"></a>轮流 (Taking Turns) MAC 协议</h3><h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>主节点邀请从节点依次传送<br>从节点一般比较 “dumb”<br>缺点：  </p>
<ul>
<li>轮询开销：轮询本身消耗信道带宽  </li>
<li>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也许要等到轮询一周后才能够发送  </li>
<li>单点故障：主节点失效时造成整个系统无法工作  </li>
</ul>
<h4 id="令牌传递"><a href="#令牌传递" class="headerlink" title="令牌传递"></a>令牌传递</h4><p>控制令牌 (token) 循环从一个节点到下一个节点传递<br>令牌报文：特殊的帧<br>缺点：  </p>
<ul>
<li>令牌开销：本身消耗带宽  </li>
<li>延迟：只有等到抓住令牌，才可传输  </li>
<li>单点故障 (token)：  <ul>
<li>令牌丢失系统级故障，整个系统无法传输  </li>
<li>复杂机制重新生成令牌 </li>
</ul>
</li>
</ul>
<h3 id="MAC-协议总结"><a href="#MAC-协议总结" class="headerlink" title="MAC 协议总结"></a>MAC 协议总结</h3><p>多点介入问题：对于一个共享型介质，各个节点如何协调对它的访问和使用？  </p>
<ul>
<li>信道划分：按时间、频率或编码  <ul>
<li>TDMA, FDMA, CDMA</li>
</ul>
</li>
<li>随机访问 (动态)  <ul>
<li>ALOHA, S-ALOHA, CSMA, CSMA/CD  </li>
<li>载波侦听：有线介质很容易，无线介质比较困难  </li>
<li>CSMA/CD：802.3 Ethernet 网中使用  </li>
<li>CSMA/CA：802.11 WLAN 中使用  </li>
</ul>
</li>
<li>依次轮流协议  <ul>
<li>集中 (有一个中心节点轮询)；分布 (通过令牌控制)  </li>
<li>蓝牙、FDDI、令牌环  </li>
</ul>
</li>
</ul>
<br>

<h2 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h2>]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 5：Network Layer (2)</title>
    <url>/2022/08/23/computernetworknotes5/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络第四章网络层：控制平面 </center>
<span id="more"></span>

<br>

<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><p>路由协议的目标：确定从发送主机到接收主机之间，通过路由器的网络 “较好” 的路径 (等价于路由器的序列)  </p>
<ul>
<li>路径：路由器的序列，分组会沿着该序列从源主机到达最后的目标主机  </li>
<li>“较好”：最小代价、最快的、最不拥塞  </li>
<li>一个路由器到另一个路由器的最佳路径  </li>
</ul>
<h3 id="路由-route"><a href="#路由-route" class="headerlink" title="路由 (route)"></a>路由 (route)</h3><p>路由：按照某种指标 (传输延迟、所经过的站点数目等) 找到一条从源节点到目标节点的较好路径  </p>
<ul>
<li>较好路径：按照某种指标较小的路径  </li>
<li>指标：站数、延迟、费用、队列长度等，或者是一些单纯指标的加权平均  </li>
<li>采用什么样的指标，标示网络使用者希望网络在什么地方表现突出，什么指标完了过使用者比较重视  </li>
</ul>
<p>路由器 - 路由器之间的最优路径 = 主机对之间的最优路径  </p>
<ul>
<li>路由器连接子网，子网到路由器之间的跳数只有一跳，必须要走  </li>
<li>路由器到下一跳路由器 (节点到节点) 之间的最优路径也就是从源子网向目标子网所有主机对之间的最优路径  </li>
<li>大大降低路由计算的规模  </li>
<li>在路由计算中按照子网到子网的路径计算为目标，而不是主机到主机  </li>
</ul>
<p>路由选择算法 (routing algorithm)：网络层软件的一部分，完成路由功能  </p>
<h3 id="最优化原则-optimality-principle"><a href="#最优化原则-optimality-principle" class="headerlink" title="最优化原则 (optimality principle)"></a>最优化原则 (optimality principle)</h3><p>汇集树 (sink tree)  </p>
<ul>
<li>此节点到所有其它节点的最优路径形成的树  </li>
<li>路由选择算法就是为所有路由器找到并使用汇集树  </li>
</ul>
<p>路由选择算法的原则  </p>
<ul>
<li>正确性 (correctness)：算法必须是正确的、完整的，使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应的表项，没有处理不了的目标站地址  </li>
<li>简单性 (simplicity)：算法在计算机上应简单；最优但复杂的算法延迟大，不实用，不应为了获取路由信息增加很多通信量  </li>
<li>健壮性 (robustness)：算法应能适应通信量和网络拓扑的变化；通信量变化，网络拓扑的变化算法能很快适应；不向很拥挤的链路发数据，不向断了的链路发数据  </li>
<li>稳定性 (stability)：产生的路由不应该摇摆  </li>
<li>公平性 (fairness)：对每一个站点都公平  </li>
<li>最优性 (optimality)：某一个指标的最优，时间、费用等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的  </li>
</ul>
<h3 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h3><h4 id="全局或局部路由信息"><a href="#全局或局部路由信息" class="headerlink" title="全局或局部路由信息"></a>全局或局部路由信息</h4><p>全局：  </p>
<ul>
<li>所有的路由器拥有完整的拓扑和便的代价的信息  </li>
<li>link state 算法  </li>
</ul>
<p>分布式：  </p>
<ul>
<li>路由器只知道与它又物理连接关系的邻居路由器，和到相应邻居路由器的代价值  </li>
<li>迭代地与邻居交换路由信息、计算路由信息  </li>
<li>distance vector 算法  </li>
</ul>
<h4 id="静态或动态"><a href="#静态或动态" class="headerlink" title="静态或动态"></a>静态或动态</h4><p>静态：路由随时间变化缓慢  </p>
<ul>
<li>非自适应路由选择算法 (non-adaptive algorithm)：不能适应网络拓扑和通信量的变化，路由表是事先计算好的  </li>
</ul>
<p>动态：路由变化很快；周期性更新，根据链路代价的变化而变化  </p>
<ul>
<li>自适应路由选择算法 (adaptive algorithm)：能适应网络拓扑和信息量的变化  </li>
</ul>
<h3 id="Link-State-路由的工作过程"><a href="#Link-State-路由的工作过程" class="headerlink" title="Link State 路由的工作过程"></a>Link State 路由的工作过程</h3><p>配置 LS 路由选择算法的路由工作过程  </p>
<ul>
<li>个点通过各种渠道获得整个网络拓扑，网络中所有链路代价等信息 (与算法本身没有关系，属于协议和实现)  </li>
<li>使用 LS 路由算法，计算本站点到其它站点的最优路径 (汇集树)，得到路由表  </li>
<li>按照此路由表转发分组 (datagram 方式)  <ul>
<li>严格意义上说不是一个路由的步骤  </li>
<li>分发到输入端口的网络层  </li>
</ul>
</li>
</ul>
<p>获得网络拓扑和链路代价信息 -&gt; 是用最短路由算法得到路由表  -&gt; 使用此路由表  </p>
<p>LS 路由的基本工作过程  </p>
<ol>
<li>发现相邻节点，获知对方网络地址  <ul>
<li>一个路由器上电之后，向所有线路发送 HELLO 分组  </li>
<li>其它路由器收到 HELLO 分组，回送应答，在应答分组中告知自己的名字 (全局唯一)  </li>
<li>在 LAN 中，通过广播 HELLO 分组获得其它路由器信息，可以认为引入一个人工节点  </li>
</ul>
</li>
<li>测量到相邻节点的代价 (延迟、开销)  <ul>
<li>实测法，发送一个分组要求对方立即响应  </li>
<li>会送一个 ECHO 分组  </li>
<li>通过测量时间可以估算出延迟情况  </li>
</ul>
</li>
<li>组装一个 LS 分组，描述它到相邻节点的代价情况<ul>
<li>发送者名称  </li>
<li>序号、年龄  </li>
<li>列表：给出它相邻节点，而它到相邻节点的延迟  </li>
</ul>
</li>
<li>将分组通过扩散的方法发到所有其它路由器  <ul>
<li>顺序号：用于控制无穷的扩散，每个路由器都记录 (源路由器，顺序号)，发现重复或老的就不扩散<br>具体问题：  <ul>
<li>循环使用问题</li>
<li>路由器崩溃之后序号从 0 开始  </li>
<li>序号出现错误</li>
</ul>
</li>
<li>解决问题的办法：年龄字段 (age)  <ul>
<li>生成一个分组时，年龄字段不为 0  </li>
<li>每隔一段时间， AGE 字段减 1  </li>
<li>AGE 字段为 0 的分组将被抛弃  </li>
</ul>
</li>
<li>扩散分组的数据结构  <ul>
<li>Source：从哪个节点收到 LS 分组  </li>
<li>Seq，Age：序号，年龄  </li>
<li>Send flags：发送标记，必须向指定的哪些相邻站点转发 LS 分组  </li>
<li>ACK flags：本站点必须向那斜相邻站点发送应答  </li>
<li>DATA：来自 source 站点的 LS 分组  </li>
<li>eg. 节点 B 的数据结构  </li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/2022/08/23/computernetworknotes5/LSstructure.png"></p>
<p><em>以上 4 步让每个路由器获得拓扑和边代价</em><br>5. 通过 Dijkstra 算法找出最短路径 (这一步才是路由算法)  </p>
<ul>
<li>每个节点独立算出来到其它节点 (路由器 = 网络) 的最短路径  </li>
<li>迭代算法：第 k 步能够直到本节点到 k 个其它节点的最短路径  </li>
</ul>
<p>LS 的应用情况  </p>
<ul>
<li>OSPF 协议是一种 LS 协议，被用于 Internet 上  </li>
<li>IS-IS (intermediate system - intermediate system)：被用于 Internet 主干中，Netware  </li>
</ul>
<p>算法复杂度：n 节点  </p>
<ul>
<li>每一次迭代：需要检查所有不在永久集合 N 中节点  </li>
<li>n(n+1)/2 次比较：O(n<sup>2</sup>)  </li>
<li>有效实现时：O(nlogn)  </li>
</ul>
<p>可能带来路径震荡：链路代价 = 链路承载的流量  </p>
<p><img src="/2022/08/23/computernetworknotes5/Dijkstra.png"></p>
<h3 id="距离矢量路由选择-distance-vector-routin"><a href="#距离矢量路由选择-distance-vector-routin" class="headerlink" title="距离矢量路由选择 (distance vector routin)"></a>距离矢量路由选择 (distance vector routin)</h3><p>基本思想：  </p>
<ul>
<li>各路由器维护一张路由表</li>
<li>各路由器与相邻路由器交换路由表  </li>
<li>根据获得的路由信息，更新路由表</li>
</ul>
<p><img src="/2022/08/23/computernetworknotes5/DV.png"></p>
<p>代价及相邻节点减代价的获得  </p>
<ul>
<li>跳数 (hops)，延迟 (delay)，队列长度  </li>
<li>相邻节点间代价的获得：实测  </li>
</ul>
<p>路由信息的更新  </p>
<ul>
<li>根据实测，得到本节点 A 到相邻站点的代价 (如延迟)  </li>
<li>根据各相邻站点声称它们到目标站点 B 的代价  </li>
<li>计算出本站点 A 经过各相邻站点到目标站点 B 的代价  </li>
<li>找到一个最小的代价和相应的下一个节点 Z，到达节点 B 经过此节点 Z，并且代价为 A-Z-B 的代价  </li>
<li>其它所有的目标节点都使用上述算法  </li>
</ul>
<p><img src="/2022/08/23/computernetworknotes5/DVrouting.png"></p>
<p>距离矢量算法  </p>
<ul>
<li>D<sub>x</sub>(y) = 节点 x 到 y 代价最小值的估计  <ul>
<li>x 节点维护距离矢量 D<sub>x</sub> = [D<sub>x</sub>(y): y ∈ N]</li>
</ul>
</li>
<li>节点 x：<ul>
<li>知道到所有邻居 v 的代价：c(x,v)  </li>
<li>收到并维护一个它邻居的距离矢量集  </li>
<li>对于每个邻居，x 维护 D<sub>v</sub> = [D<sub>v</sub>(y): y ∈ N]</li>
</ul>
</li>
<li>核心思路：  <ul>
<li>每个节点都将自己的距离矢量估计值传送给邻居，定时或者 DV 有变化时，让对方去算  </li>
<li>当 x 从邻居收到 DV 时，自己运算，更新它自己的距离矢量<ul>
<li>采用 B-F equation  </li>
<li><img src="/2022/08/23/computernetworknotes5/BFequation.png">  </li>
</ul>
</li>
<li>D<sub>x</sub>(y) 估计值最终收敛于实际的最小代价值 d<sub>x</sub>(y)  <ul>
<li>分布式、迭代算法  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>异步式、迭代：每次本地迭代被以下事件触发  </p>
<ul>
<li>本地链路代价变化  </li>
<li>从邻居收到 DV 的更新消息  </li>
</ul>
<p>分布式：  </p>
<ul>
<li>每个节点只是在自己的 DV 改变之后向邻居通告  </li>
<li>邻居在有必要时通知它们的邻居  </li>
<li><img src="/2022/08/23/computernetworknotes5/DVhexin.png">  </li>
</ul>
<p>DV 的无穷计算问题  </p>
<ul>
<li>DV 的特点：好消息传得快，坏消息传得慢  </li>
<li>好消息的传播以每一个交换周期前进一格路由器的速度进行  <ul>
<li>好消息：某个路由器接入或有更短的路径  </li>
<li><img src="/2022/08/23/computernetworknotes5/goodnews.png">  </li>
</ul>
</li>
<li>坏消息传播速度非常慢 (无穷计算问题)  <ul>
<li><img src="/2022/08/23/computernetworknotes5/badnews.png">  </li>
</ul>
</li>
<li>水平分裂 (split horizon) 算法：一种对无穷计算问题的解决方法  <ul>
<li><img src="/2022/08/23/computernetworknotes5/splithorizon.png">  </li>
<li>在某些拓扑形式下会失败 (存在环路)  </li>
</ul>
</li>
</ul>
<h3 id="LS-和-DV-算法比较"><a href="#LS-和-DV-算法比较" class="headerlink" title="LS 和 DV 算法比较"></a>LS 和 DV 算法比较</h3><p>消息复杂度：DV 优  </p>
<ul>
<li>LS：有 n 个节点，E 条链路，发送报文 O(nE)个  <ul>
<li>局部的路由信息，全局传播  </li>
</ul>
</li>
<li>DV：只和邻居交换信息  <ul>
<li>全局的路由信息，局部传播  </li>
</ul>
</li>
</ul>
<p>收敛时间：LS 优  </p>
<ul>
<li>LS：O(n<sup>2</sup>) <ul>
<li>有可能震荡  </li>
</ul>
</li>
<li>DV：收敛较慢  <ul>
<li>可能存在路由环路  </li>
<li>count-to-infinity 问题  </li>
</ul>
</li>
</ul>
<p>健壮性：LS 优  </p>
<ul>
<li>LS：<ul>
<li>节点会通告不正确的链路代价  </li>
<li>每个节点只计算自己的路由表  </li>
<li>错误信息影响较小，局部，路由较健壮  </li>
</ul>
</li>
<li>DV：  <ul>
<li>DV 节点可能会通告对全网所有节点的不正确路径代价 (距离矢量)  </li>
<li>每一个节点的路由表可能被其它节点使用 (错误可以扩散到全网)  </li>
</ul>
</li>
</ul>
<br>

<h2 id="自治系统内部的路由选择-内部网关协议"><a href="#自治系统内部的路由选择-内部网关协议" class="headerlink" title="自治系统内部的路由选择 (内部网关协议)"></a>自治系统内部的路由选择 (内部网关协议)</h2><h3 id="RIP-Routing-Information-Protocol"><a href="#RIP-Routing-Information-Protocol" class="headerlink" title="RIP: Routing Information Protocol"></a>RIP: Routing Information Protocol</h3><p>基于 Distance Vector 算法  </p>
<ul>
<li>距离矢量：每条链路 cost = 1，# of hops (max = 15 hops) 跳数  </li>
<li>DV 每隔 30 秒和邻居交换 DV，通告  <ul>
<li>定期，而且在改变路由时发送通告报文  </li>
<li>在对方的请求下可以发送通告报文  </li>
</ul>
</li>
<li>每个通告包括：最多 25 个目标子网  <ul>
<li>目标网络 + 跳数  </li>
</ul>
</li>
</ul>
<h4 id="链路失效和恢复"><a href="#链路失效和恢复" class="headerlink" title="链路失效和恢复"></a>链路失效和恢复</h4><p>如果 180 秒没有收到通告信息 -&gt; 邻居或者链路失效  </p>
<ul>
<li>发现经过这个邻居的路由已失效  </li>
<li>新的通告报文会传递给邻居  </li>
<li>邻居因此发出新的通告 (如果路由变化)  </li>
<li>链路失效快速在整网中传播  </li>
<li>使用毒性逆转 (poison reverse) 阻止 ping-pong 回路 (不可达的剧里：跳数无限 = 16 段)  </li>
</ul>
<h4 id="进程处理"><a href="#进程处理" class="headerlink" title="进程处理"></a>进程处理</h4><p>RIP 以应用进程的方式实现：route-d (daemon)<br>通告报文通过 UDP 报文传送，周期性重复<br>网络层的协议使用了传输层的服务，以应用层实体的方式实现  </p>
<p><img src="/2022/08/23/computernetworknotes5/RIPprocess.png">  </p>
<h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF: Open Shortest Path First"></a>OSPF: Open Shortest Path First</h3><p>open：标准可公开获得<br>使用 LS 算法：  </p>
<ul>
<li>LS 分组在网络中 (一个 AS 内部) 分发  </li>
<li>全局网络拓扑、代价在每一个节点中都保持  </li>
<li>路由计算采用 Dijkstra 算法  </li>
</ul>
<p>OSPF 通告信息中携带：每一个邻居路由器一个表项<br>通告信息会传遍 AS 全部 (通过泛洪)  </p>
<ul>
<li>在 IP 数据包上直接传送 OSPF 报文，而不是通过 UDP 和 TCP  </li>
</ul>
<p>IS-IS 路由协议：几乎和 OSPF 一样  </p>
<h4 id="OSPF-“高级”-特性-在-RIP-中没有"><a href="#OSPF-“高级”-特性-在-RIP-中没有" class="headerlink" title="OSPF “高级” 特性 (在 RIP 中没有)"></a>OSPF “高级” 特性 (在 RIP 中没有)</h4><p>安全：所有的 OSPF 报文都是经过认证的 (防止恶意攻击)<br>允许有多个代价相同的路径存在 (RIP 协议中只有一个)<br>对每一个链路，对不同的 TOS 有多重代价矩阵  </p>
<ul>
<li>eg. 卫星链路代价对于尽力而为的服务代价设置比较低，对实时服务代价设置的比较高  </li>
<li>支持按照不同代价计算最优路径，如按照时间和延迟分别计算最优路径  </li>
</ul>
<p>对单播和多播的集成支持：Multicast OSPF (MOSPF) 使用相同的拓扑数据库，就像在 OSPF 中一样  </p>
<h4 id="层次性的-OSPF-路由"><a href="#层次性的-OSPF-路由" class="headerlink" title="层次性的 OSPF 路由"></a>层次性的 OSPF 路由</h4><p>在大型网络中支持层次性 OSPF  </p>
<p><img src="/2022/08/23/computernetworknotes5/MOSPF.png">  </p>
<p>2 个级别的层次性：本地，骨干  </p>
<ul>
<li>链路状态通告仅仅本地区与 Area 范围内进行  </li>
<li>每一个节点拥有本地区域的拓扑信息：关于其它区域，知道去它的方向，通过区域边界路由器 (最短路径)  </li>
</ul>
<p>区域边界路由器：“汇总 (聚集)” 到自己区域内网络的距离，向其它区域边界路由器通告<br>骨干路由器：仅仅在骨干区域内，运行 OSPF 路由<br>边界路由器：连接其它的 AS’s  </p>
<br>

<h2 id="ISP-之间的路由选择：BGP"><a href="#ISP-之间的路由选择：BGP" class="headerlink" title="ISP 之间的路由选择：BGP"></a>ISP 之间的路由选择：BGP</h2><h3 id="一个平面的路由"><a href="#一个平面的路由" class="headerlink" title="一个平面的路由"></a>一个平面的路由</h3><p>平面路由  </p>
<ul>
<li>一个网络中的所有路由器的地位一样  </li>
<li>通过 LS、DV 或其它路由算法，所有路由器都要知道其它所有路由器 (子网) 如何走  </li>
<li>所有路由器在一个平面  </li>
</ul>
<p>平面路由的问题  </p>
<ul>
<li>规模巨大的网络中，路由信息的存储、传输和计算代价巨大  <ul>
<li>DV：距离矢量很大，且不能够收敛  </li>
<li>LS：几百万个节点的 LS 分组的泛洪传输，存储以及最短路径算法的计算  </li>
</ul>
</li>
<li>管理问题  <ul>
<li>不同的网络所有者希望按照自己的方式管理网络  </li>
<li>希望对外隐藏自己网络的细节  </li>
<li>希望和其它网络互联  </li>
</ul>
</li>
</ul>
<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p>层次路由：将互联网分成一个个 AS (路由器区域)  </p>
<ul>
<li>某个区域内的路由器集合，autonomous systems (AS)  </li>
<li>一个 AS 用 AS Number (ASN) 唯一标示  </li>
<li>一个 ISP 可能包括 1 个或多个 AS  </li>
</ul>
<p>路由变成了 2 个层次路由  </p>
<ul>
<li>AS 内部路由：在同一个 AS 内路由器运行相同的路由协议  <ul>
<li>intra-AS routing protocol：内部网关协议  </li>
<li>不同的 AS 可能运行不同的内部网关协议，如 RIP、OSPF、IGRP  </li>
<li>能够解决规模和管理问题  </li>
<li>网关路由器：AS 边缘路由器，可以连接到其它 AS  </li>
</ul>
</li>
<li>AS 间运行 AS 间路由协议  <ul>
<li>inter-AS routing protocol：外部网关协议  </li>
<li>解决 AS 之间的路由问题，完成 AS 之间的互联互通  </li>
</ul>
</li>
</ul>
<p>层次路由优点  </p>
<ul>
<li>解决了规模问题  <ul>
<li>内部网关协议解决：AS 内部数量有限的路由器互相到达的问题，AS 内部规模可控<ul>
<li>如 AS 节点太多，可分割 AS，使得 AS 内部节点数量有限  </li>
</ul>
</li>
<li>AS 之间的路由规模问题  <ul>
<li>增加一个 AS，对于 AS 之间的路由从总体上来说只是增加了一个节点 = 子网 (每个 AS 可以用一个点来表示)  </li>
<li>对于其他 AS 来说只是增加了一个表项，即新增的 AS 如何走的问题  </li>
<li>扩展性墙：规模增大，但性能不会减得太多  </li>
</ul>
</li>
</ul>
</li>
<li>解决了管理问题  <ul>
<li>各个 AS 可以运行不同的内部网关协议  </li>
<li>可以使自己网络的细节不向外透露  </li>
</ul>
</li>
</ul>
<h3 id="互联网-AS-间路由：BGP"><a href="#互联网-AS-间路由：BGP" class="headerlink" title="互联网 AS 间路由：BGP"></a>互联网 AS 间路由：BGP</h3><p>BGP (Border Gateway Protocol)：自治区域间路由协议 “事实上的” 标准<br>BGP 提供给每个 AS：  </p>
<ul>
<li>eBGP：从相邻的 ASes 哪里获得子网可达信息  </li>
<li>iBGP：将获得的子网可达信息传遍 AS 内部的所有路由器  </li>
<li>根据子网可达信息和策略来决定到达子网的 “好” 路径  </li>
</ul>
<p>允许子网向互联网其它网络通告 “我在这里”<br>基于距离矢量算法 (路径矢量)：不仅是距离矢量，还包括到达哥哥目标网络的详细路径 (AS 序号的列标)，能够避免简单 DV 算法的路由环路问题  </p>
<p><img src="/2022/08/23/computernetworknotes5/eBGPiBGP.png">  </p>
<p>网关路由器同时运行 eBGP 和 iBGP 协议  </p>
<h4 id="BGP-基础"><a href="#BGP-基础" class="headerlink" title="BGP 基础"></a>BGP 基础</h4><p>BGP 会话：2 个 BGP 路由器 (peers) 在一个半永久的 TCP 连接上交换 BGP 报文：  </p>
<ul>
<li>通告向不同目标子网前缀的 “路径” (BGP 是一个 “路径矢量” 协议)  </li>
</ul>
<p><img src="/2022/08/23/computernetworknotes5/BGPbasic.png">  </p>
<h4 id="路径的属性-amp-BGP-路由"><a href="#路径的属性-amp-BGP-路由" class="headerlink" title="路径的属性 &amp; BGP 路由"></a>路径的属性 &amp; BGP 路由</h4><p>当通告一个子网前缀时，通告包括 BGP 属性  </p>
<ul>
<li>prefix + attributes = route  </li>
</ul>
<p>两个重要属性：  </p>
<ul>
<li>AS-PATH：前缀的通告所经过的 AS 列标：AS 67 AS 17  <ul>
<li>检测环路：多路径选择  </li>
<li>在向其它 AS 转发时，需要将自己的 AS 号加在路径上  </li>
</ul>
</li>
<li>NEXT-HOP：从当前 AS 到下一跳 AS 有多个链路，在 NEXT-HOP 属性中，告诉对方通过哪个 I 转发  </li>
<li>其它属性：路由偏好志保，如何被插入的属性  </li>
</ul>
<p>基于策略的路由：  </p>
<ul>
<li>当一个网关路由器接收到一个路由通告，使用输入策略来接收或过来 (accept/decline)  <ul>
<li>eg. 不想经过某个 AS，转发某些前缀的分组  </li>
<li>eg. 已经有了一条往某前缀的偏好路径  </li>
</ul>
</li>
<li>策略决定了是否向它的邻居通告收到的这个路由信息  </li>
</ul>
<p>BGP 路径通告  </p>
<p><img src="/2022/08/23/computernetworknotes5/BGPljtg.png">  </p>
<p><img src="/2022/08/23/computernetworknotes5/BGPljtg2.png">  </p>
<h4 id="BGP-报文"><a href="#BGP-报文" class="headerlink" title="BGP 报文"></a>BGP 报文</h4><p>使用 TCP 协议交换 BGP 报文<br>BGP 报文：  </p>
<ul>
<li>OPEN：打开 TCP 连接，认证发送方  </li>
<li>UPDATE：通告新路径 (或撤销原路径)  </li>
<li>KEEPALIVE：在没有更新时保持连接，也用于对 OPEN 请求确认  </li>
<li>NOTIFICATION：报告以前消息的错误，也用来关闭连接  </li>
</ul>
<h4 id="BGP-路径选择"><a href="#BGP-路径选择" class="headerlink" title="BGP 路径选择"></a>BGP 路径选择</h4><p>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可基于：  </p>
<ul>
<li>本地偏好值属性：偏好策略决定  </li>
<li>最短 AS-PATH：AS 的跳数  </li>
<li>最近的 NEXT-HOP 路由器：热土豆路由  </li>
<li>附加的判据：使用 BGP 标示  </li>
</ul>
<p>一个前缀对应着多种路径，采用消除规则直到留下一条路径  </p>
<h3 id="为什么内-外部网关协议如此不同"><a href="#为什么内-外部网关协议如此不同" class="headerlink" title="为什么内/外部网关协议如此不同"></a>为什么内/外部网关协议如此不同</h3><p>策略：  </p>
<ul>
<li>Inter-AS：管理员需要控制通信路径，谁在使用它的网络进行数据传输  </li>
<li>Intra-AS：一个管理者，无需策略；AS 内部的各子网的主机进肯能地利用资源进行快速路由  </li>
</ul>
<p>规模：  </p>
<ul>
<li>AS 间路由必须考虑规模问题，以便支持全网的数据转发  </li>
<li>AS 内部路由规模不是大问题  <ul>
<li>如果 AS 太大，可继续分为小的 AS，规模可控  </li>
<li>或 AS 内部路由支持层次性，层次性路由节约表空间，降低更新数据流量  </li>
</ul>
</li>
</ul>
<p>性能：  </p>
<ul>
<li>Intra-AS：关注性能  </li>
<li>Inter-AS：策略比性能更重要  </li>
</ul>
<br>

<h2 id="SDN-控制平面"><a href="#SDN-控制平面" class="headerlink" title="SDN 控制平面"></a>SDN 控制平面</h2><h3 id="Software-Defined-Networking-SDN"><a href="#Software-Defined-Networking-SDN" class="headerlink" title="Software Defined Networking (SDN)"></a>Software Defined Networking (SDN)</h3><p>逻辑上集中的控制平面<br>一个不同的 (通常是远程的) 控制器与本地控制代理 (CAs) 交互  </p>
<p><img src="/2022/08/23/computernetworknotes5/SDNway.png">  </p>
<p>逻辑上集中的控制平面：网络管理更容易；基于流表的转发，允许 “可编程” 的路由器；控制平面的开放实现  </p>
<h3 id="SDN-特点"><a href="#SDN-特点" class="headerlink" title="SDN 特点"></a>SDN 特点</h3><p>通用 “flow based”，基于流的匹配 + 行动<br>控制平面和数据平面分离<br>控制平面功能在数据交换设备之外实现<br>可编程控制应用，在控制器之上以网络应用形式实现各种网络功能  </p>
<h3 id="SDN-架构"><a href="#SDN-架构" class="headerlink" title="SDN 架构"></a>SDN 架构</h3><h4 id="数据平面交换机"><a href="#数据平面交换机" class="headerlink" title="数据平面交换机"></a>数据平面交换机</h4><p>快速、简单、商业化交换设备，采用硬件实现通用转发功能<br>流表被控制器计算和安装<br>基于南向 API (如 OpenFlow)，SDN 控制器访问基于流的交换机：定义了哪些可以被控制，哪些不能<br>定义了和控制器的协议 (如 OpenFlow)  </p>
<h4 id="SDN-控制器-网络-OS"><a href="#SDN-控制器-网络-OS" class="headerlink" title="SDN 控制器 (网络 OS)"></a>SDN 控制器 (网络 OS)</h4><p>维护网络状态信息<br>通过上面的北向 API 和网络控制应用交互<br>拖过下面的南向 API 和网络交换机交互<br>逻辑上集中，但在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法实现  </p>
<h4 id="网络控制应用"><a href="#网络控制应用" class="headerlink" title="网络控制应用"></a>网络控制应用</h4><p>控制的大脑：采用下层提供的服务 (SDN 控制器提供的 API)，实现网络功能  </p>
<ul>
<li>路由器 交换机  </li>
<li>接入控制 防火墙  </li>
<li>负载均衡  </li>
<li>其它功能  </li>
</ul>
<p>非绑定：可以被第三方提供，与控制器厂商通常上可以不同，与分组交换机厂商也可以不同  </p>
<p><img src="/2022/08/23/computernetworknotes5/SDNcontroller.png">  </p>
<h3 id="OpenFlow：控制器-交换机报文"><a href="#OpenFlow：控制器-交换机报文" class="headerlink" title="OpenFlow：控制器-交换机报文"></a>OpenFlow：控制器-交换机报文</h3><p>关键的控制器到交换机的报文：  </p>
<ul>
<li>特性：控制器查询交换机特性，交换机应答  </li>
<li>配置：交换机查询/设置交换机的配置参数  </li>
<li>修改状态：增加删除修改 OpenFlow 表中的流表  </li>
<li>packet-out：控制器可以将分组通过特定的端口发出  </li>
</ul>
<p>关键的交换机到控制器的报文：  </p>
<ul>
<li>分组进入：将分组 (和他的控制) 传给控制器，见来自控制器的 packet-out 报文  </li>
<li>流移除：在交换机上删除流表项  </li>
<li>端口状态：报告控制器端口的变化  </li>
</ul>
<p>网络管理员不需要直接通过创建/发送流表来变成交换机，可采用控制器上的 app 自动运算和配置  </p>
<h3 id="OpenDaylight-ODL-控制器"><a href="#OpenDaylight-ODL-控制器" class="headerlink" title="OpenDaylight (ODL) 控制器"></a>OpenDaylight (ODL) 控制器</h3><p>ODL lithium 控制器<br>网络应用可以在 SDN 控制内或外面<br>服务抽象层 SAL：和内部以及外部应用以及服务进行交互  </p>
<p><img src="/2022/08/23/computernetworknotes5/ODL.png">  </p>
<h3 id="ONOS-控制器"><a href="#ONOS-控制器" class="headerlink" title="ONOS 控制器"></a>ONOS 控制器</h3><p>控制应用和控制器分离 (应用 app 在控制器外部)<br>意图架构服务的高级规范：描述什么，而不是如何<br>相当多的重点聚焦在分布式核心上，以提高服务的可靠性、性能的可扩展性  </p>
<p><img src="/2022/08/23/computernetworknotes5/ONOS.png"></p>
<h3 id="SDN-的挑战"><a href="#SDN-的挑战" class="headerlink" title="SDN 的挑战"></a>SDN 的挑战</h3><p>强化控制平面：可靠、可信、性能可扩展性、安全的分布式系统  </p>
<ul>
<li>对于失效的鲁棒性：利用为控制平面可靠分布式系统的强大理论  </li>
<li>可信任、安全：从开始就进行铸造  </li>
</ul>
<p>网络、协议满足特殊任务的需求  </p>
<ul>
<li>eg. 实时性、超高可靠性、超高安全性  </li>
</ul>
<p>互联网络范围内的扩展性  </p>
<ul>
<li>全网部署，而不是仅仅在一个 AS 内部部署</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network Notes 3：Transport Layer</title>
    <url>/2022/04/19/computernetworknotes3/</url>
    <content><![CDATA[<center> 把老师的 PPT 变成 md 文件之计算机网络第三章传输层 </center>
<span id="more"></span>

<br>

<h2 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h2><h3 id="传输服务和协议"><a href="#传输服务和协议" class="headerlink" title="传输服务和协议"></a>传输服务和协议</h3><p>为运行在不同主机上的应用进程提供<strong>逻辑通信</strong>，即进程到进程的远程逻辑通信  </p>
<p>传输协议运行在<strong>端系统</strong>  </p>
<ul>
<li>发送方：将应用层的报文分成<strong>报文段</strong>，然后传递给网络层  </li>
<li>接收方：将报文段重组成报文，然后传递给应用层  </li>
</ul>
<p>有多个传输层协议可供选择  </p>
<ul>
<li>Internet：TCP 和 UDP  </li>
</ul>
<h3 id="传输层-vs-网络层"><a href="#传输层-vs-网络层" class="headerlink" title="传输层 vs 网络层"></a>传输层 vs 网络层</h3><p>网络层服务：主机之间的逻辑通信<br>传输层服务：进程间的逻辑通信  </p>
<ul>
<li>依赖于网络层的服务：延时、带宽 (不可加强)  </li>
<li>加强网络层的服务：弥补可靠性，减少数据丢失、顺序混乱 (不可靠 -&gt; 可靠)；加密 (安全)；复用/解复用  </li>
</ul>
<h3 id="Internet-传输层协议"><a href="#Internet-传输层协议" class="headerlink" title="Internet 传输层协议"></a>Internet 传输层协议</h3><p>可靠地、保序的传输：TCP (字节流)  </p>
<ul>
<li>多路复用、解复用  </li>
<li>拥塞控制  </li>
<li>流量控制  </li>
<li>建立连接  </li>
</ul>
<p>不可靠、不保序的传输：UDP (数据报)  </p>
<ul>
<li>多路复用、解复用  </li>
<li>没有为尽力而为的 IP 服务添加更多的其它额外服务  </li>
</ul>
<p>都不提供的服务：延时保证、带宽保证  </p>
<br>  

<h2 id="多路复用和解复用"><a href="#多路复用和解复用" class="headerlink" title="多路复用和解复用"></a>多路复用和解复用</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>在发送方主机多路复用</strong>：从多个套接字接受来自多个进程的报文，根据套接字对应的 IP 地址和端口号等信息对报文段用头部加以封装，该头部信息用于以后的解复用<br><strong>在接收方主机多路解复用</strong>：根据报文段的头部信息种的 IP 地址和端口号将接收到的报文段发给正确的套接字和对应的应用进程  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPfuyong.png" alt="TCP 复用解复用">  </p>
<p><img src="/2022/04/19/computernetworknotes3/UDPfuyong.png" alt="UDP 复用解复用">  </p>
<h3 id="多路解复用工作原理"><a href="#多路解复用工作原理" class="headerlink" title="多路解复用工作原理"></a>多路解复用工作原理</h3><p><strong>解复用作用</strong>：TCP 或者 UDP 实体采用哪些信息，将报文段的数据部分交给正确的 socket，从而交给正确的进程  </p>
<p>主机收到 IP 数据报  </p>
<ul>
<li>每个数据包有源 IP 地址和目标地址  </li>
<li>每个数据报承载一个传输层报文段  </li>
<li>每个报文段有一个源端口号和目标端口号 (特定应用有著名的端口号)  </li>
</ul>
<p>主机联合使用 <strong>IP 地址</strong>和<strong>端口号</strong>将报文段发送给合适的套接字  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPUDPbaowen.png" alt="TCP/UDP 报文段格式">  </p>
<h4 id="无连接-UDP-多路解复用"><a href="#无连接-UDP-多路解复用" class="headerlink" title="无连接 (UDP) 多路解复用"></a>无连接 (UDP) 多路解复用</h4><p><strong>创建套接字</strong>：  </p>
<ul>
<li>服务器端  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">serverSocket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);  </span><br><span class="line"><span class="built_in">bind</span>(serverSocket, &amp;sad, <span class="built_in"><span class="keyword">sizeof</span></span>(sad));  </span><br><span class="line"><span class="comment">// serverSocket 和 Sad指定的端口号捆绑 (UDP 和 TCP 不同)  </span></span><br></pre></td></tr></table></figure>
</li>
<li>客户端  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClientSocket = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM,<span class="number">0</span>);  </span><br><span class="line"><span class="comment">// 没有Bind、ClientSocket 和 OS 为之分配的某个端口号捆绑  </span></span><br><span class="line"><span class="comment">// 客户端使用什么端口号无所谓，客户端主动找服务器  </span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>在接收端，UDP 套接字用二元组标识 (目标 IP 地址、目标端口号)  </p>
<p>当主机收到 UDP 报文段  </p>
<ul>
<li>检查报文段的目标端口号  </li>
<li>用该端口号将报文段定位给套接字  </li>
</ul>
<p>如果两个不同源 IP 地址/源端口号的数据报，但是<strong>有相同的目标 IP 地址和端口号</strong>，则被定位到相同的套接字  </p>
<ul>
<li>创建拥有本地端口号的套接字  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DatagramSocket mySocket1 = <span class="keyword">new</span> <span class="built_in">DatagramSocket</span>(<span class="number">12534</span>);  </span><br></pre></td></tr></table></figure></li>
<li>当创建 UDP 段采用端口号，可以指定：目标 IP 地址、目标端口号  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/UDPfuyongeg.png" alt="无连接多路复用例子">  </p>
<p><img src="/2022/04/19/computernetworknotes3/mianxianglianjiedejiefuyong.png" alt="面向连接的解复用例子">  </p>
<br>

<h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h2><h3 id="UDP：User-Datagram-Protocol-RFC-768"><a href="#UDP：User-Datagram-Protocol-RFC-768" class="headerlink" title="UDP：User Datagram Protocol [RFC 768]"></a>UDP：User Datagram Protocol [RFC 768]</h3><p>“no frills”, “bare bones” Internet 传输协议<br>“尽力而为”的服务，报文可能丢失、送到应用程序的报文段乱序  </p>
<p><strong>无连接</strong>  </p>
<ul>
<li>UDP 发送端和接收端之间没有握手  </li>
<li>每个 UDP 报文段都被独立地处理  </li>
</ul>
<p>UDP 被用于  </p>
<ul>
<li>流媒体：丢失不敏感，速率敏感、应用可控制传输速率  </li>
<li>DNS  </li>
<li>SNMP  </li>
</ul>
<p>在 UDP 上实现可靠传输：  </p>
<ul>
<li>在应用层增加可靠性  </li>
<li>应用特定的差错恢复  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/UDPform.png" alt="UDP 报文段格式">  </p>
<h3 id="为什么要有-UDP"><a href="#为什么要有-UDP" class="headerlink" title="为什么要有 UDP"></a>为什么要有 UDP</h3><p>不建立连接(会增加延时)<br>简单：在发送端和接收端没有连接状态<br>报文段的头部很小 (开销小)<br>无拥塞控制和流量控制，UDP 可以尽可能快的发送报文段：应用 -&gt; 传输的速率 = 主机 -&gt; 网络的速率  </p>
<h3 id="UDP-校验和-check-sum"><a href="#UDP-校验和-check-sum" class="headerlink" title="UDP 校验和 (check sum)"></a>UDP 校验和 (check sum)</h3><p><strong>目标</strong>：检测在被传输报文段种的差错，如比特反转  </p>
<p>发送方：  </p>
<ul>
<li>将报文段的内容视为 16 比特的整数  </li>
<li>校验和：报文段的加法和 (1 的补运算)  </li>
<li>发送方将校验和放在 UDP 的校验和字段  </li>
</ul>
<p>接收方：  </p>
<ul>
<li>计算接收到的报文段的校验和  </li>
<li>检查计算处的校验和与校验和字段的内容是否相等  <ul>
<li>不相等 —— 检测到差错  </li>
<li>相等 —— 没有检测到差错，但也许还是有差错 (残存错误)  </li>
</ul>
</li>
</ul>
<h4 id="Internet-校验和例子：进位回滚"><a href="#Internet-校验和例子：进位回滚" class="headerlink" title="Internet 校验和例子：进位回滚"></a>Internet 校验和例子：进位回滚</h4><p>当数字相加时，在最高位的进位要回卷，再加到结果上<br>目标端：校验范围 + 校验和 = 1111111111111111 通过校验，否则没有通过校验  </p>
<p><img src="/2022/04/19/computernetworknotes3/jinweihuijuan.png" alt="进位回卷例子"></p>
<p><em>求和时，必须将进位回卷到结果上</em>  </p>
<br>  

<h2 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h2><h3 id="可靠数据传输-RDT"><a href="#可靠数据传输-RDT" class="headerlink" title="可靠数据传输 (RDT)"></a>可靠数据传输 (RDT)</h3><p>RDT 在应用层、传输层和数据链路层都很重要<br>信道的不考考特点决定了可靠数据传输协议的复杂性  </p>
<h4 id="可靠数据传输：问题描述"><a href="#可靠数据传输：问题描述" class="headerlink" title="可靠数据传输：问题描述"></a>可靠数据传输：问题描述</h4><p><img src="/2022/04/19/computernetworknotes3/RDT.png" alt="可靠数据传输：问题描述">  </p>
<p>渐增式地开发可靠数据传输协议 (RDT) 的发送方和接收方<br>只考虑单项数据传输，但控制信息是双向流动的<br>双向的数据传输问题实际上是 2 个单项数据传输问题的综合<br>使用有限状态机 (FSM) 来描述发送方和接收方  </p>
<p><strong>状态</strong>：在该状态时，下一个状态只由下一个事件唯一决定  </p>
<p><img src="/2022/04/19/computernetworknotes3/zhuangtai.png"></p>
<h3 id="可靠数据传输协议：停止-等待"><a href="#可靠数据传输协议：停止-等待" class="headerlink" title="可靠数据传输协议：停止-等待"></a>可靠数据传输协议：停止-等待</h3><h4 id="RDT-1-0：在可靠信道上的可靠数据传输"><a href="#RDT-1-0：在可靠信道上的可靠数据传输" class="headerlink" title="RDT 1.0：在可靠信道上的可靠数据传输"></a>RDT 1.0：在可靠信道上的可靠数据传输</h4><p>下层的信道是完全可靠的  </p>
<ul>
<li>没有比特出错  </li>
<li>没有分组丢失  </li>
</ul>
<p>发送方和接收方的 FSM  </p>
<ul>
<li>发送方将数据发送到下层信道  </li>
<li>接收方从下层信道接收数据  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT1.png">  </p>
<h4 id="RDT-2-0：具有比特差错的信道"><a href="#RDT-2-0：具有比特差错的信道" class="headerlink" title="RDT 2.0：具有比特差错的信道"></a>RDT 2.0：具有比特差错的信道</h4><p>下层信道可能会出错：将分组中的比特翻转  </p>
<ul>
<li>用校验和来检测比特差错  </li>
</ul>
<p>问题：怎样从差错中回复  </p>
<ul>
<li>确认 (ACK)：接收方显示地告诉发送方分组已被正确接收  </li>
<li>否定确认 (NAK)：接收方显示地告诉发送方分组发生了差错；发送方收到 NAK 后，重传分组  </li>
</ul>
<p>RDT 2.0 的新机制：采用差错控制编码进行差错检测  </p>
<ul>
<li>发送方差错控制编码、缓存  </li>
<li>接收方使用编码检错  </li>
<li>接收方的反馈：控制报文 (ACK, NAK)；接收方 -&gt; 发送方  </li>
<li>发送方收到反馈相应的动作  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT2.png">  </p>
<h4 id="缺陷-gt-RDT-2-1"><a href="#缺陷-gt-RDT-2-1" class="headerlink" title="缺陷 (-&gt; RDT 2.1)"></a>缺陷 (-&gt; RDT 2.1)</h4><p>如果 ACK/NAK 出错  </p>
<ul>
<li>发送方不知道接收方发生了什么事情  </li>
<li>发送方重传，可能重复；不重传，可能死锁 (或出错)  </li>
<li>需要引入新的机制：序号 (sequence number)  </li>
</ul>
<p>处理重复  </p>
<ul>
<li>发送方在每个分组中加入序号  </li>
<li>如果 ACK/NAK 出错，发送方<strong>重传</strong>当前分组  </li>
<li>接收方丢弃 (不发给上层) 重复分组  </li>
<li><strong>停等协议</strong>：发送方发送一个分组，然后等待接收方的应答  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT21send.png" alt="RDT 2.1 发送方处理出错的 ACK/NAK">  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT21receive.png" alt="RDT 2.1 接收方处理出错的 ACK/NAK">  </p>
<p>发送方：  </p>
<ul>
<li>在分组中加入序列号  </li>
<li>两个序列号 (0, 1)就足够：一次只发送一个未经确认的分组  </li>
<li>必须检测 ACK/NAK 是否出错 (需要 EDC)  </li>
<li>状态数变成了两倍：必须记住当前分组的序列号是 0 还是 1  </li>
</ul>
<p>接收方：  </p>
<ul>
<li>必须检测接收到的分组是否是重复的：状态会指示希望接收到的分组的序号为 0 还是 1  </li>
<li>接收方并不知道发送方是否正确收到了 ACK/NAK  <ul>
<li>发送方不对收到的 ACK/NAK 给确认，没有安排确认的确认  </li>
<li>接收方发送 ACK，如果后面接收方收到的是老分组 P0，则 ACK 错误；收到下一个分组 P1，则 ACK 正确  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/rdt21ackerror.png" alt="RDT 2.1 ACK error">  </p>
<p><img src="/2022/04/19/computernetworknotes3/rdt21ackright.png" alt="RDT 2.1 ACK right">  </p>
<h4 id="RDT-2-2：无-NAK-的协议"><a href="#RDT-2-2：无-NAK-的协议" class="headerlink" title="RDT 2.2：无 NAK 的协议"></a>RDT 2.2：无 NAK 的协议</h4><p>功能同 RDT 2.1，但只使用 ACK (ACK 要编号)<br>接收方对<strong>最后</strong>正确接收的分组发 ACK，以替代 NAK：接收方必须显示地包含被正确接收分组的<strong>序号</strong><br>当收到重复的 ACK (如再次收到 ACK0) 时，发送方与收到 NAK 采取相同的动作：重传当前分组<br>为后面的一次发送多个数据单位做准备  </p>
<ul>
<li>一次能够发送多个  </li>
<li>每一个的应答都有 ACK/NAK 麻烦  </li>
<li>使用对前一个数据单位的 ACK，代替本数据单位的 NAK  </li>
<li>确认信息减少一半，协议处理简单  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/NAKfree.png" alt="NAK free">  </p>
<p><em>达成不要 NAK 的目标</em>  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT22.png" alt="RDT 2.2 的运行">  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT22xu.png" alt="RDT 2.2 的运行"></p>
<p><img src="/2022/04/19/computernetworknotes3/RDT22SR.png" alt="RDT 2.2：发送方和接收方片段">  </p>
<h4 id="RDT-3-0：具有比特差错和分组丢失的信道"><a href="#RDT-3-0：具有比特差错和分组丢失的信道" class="headerlink" title="RDT 3.0：具有比特差错和分组丢失的信道"></a>RDT 3.0：具有比特差错和分组丢失的信道</h4><p><strong>新的假设</strong>：下层信道可能会丢失分组 (数据或 ACK)  </p>
<ul>
<li>会死锁  </li>
<li>机制还不够处理这种状况：检验和、序列号、ACK、重传</li>
</ul>
<p><strong>方法</strong>：发送方等待 ACK 一段<strong>合理的时间</strong>  </p>
<ul>
<li>发送端超时重传：如果到时没有收到 ACK -&gt; 重传  </li>
<li>问题：如果分组 (或 ACK) 只是被延迟了<ul>
<li>重传会导致数据重复，但利用<strong>序列号</strong>可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号  </li>
</ul>
</li>
<li>需要一个倒数定时器  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT3send.png" alt="RDT 3.0 发送方">  </p>
<p>过早超时 (延迟的 ACK) 也能够正常工作，但是效率较低，一般的分组和确认是重复的<br>设置一个合理的超时时间比较重要  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT3delayedACK.png" alt="RDT 3.0 过早超时">  </p>
<p>性能：  </p>
<ul>
<li>RDT 3.0 可以工作，但链路容量比较大的情况下，性能很差  <ul>
<li>链路容量比较大，一次发一个 PDU 不能充分利用链路的传输能力</li>
<li>瓶颈在于网络协议限制了物理资源的利用  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT3xingneng.png" alt="RDT 3.0 在链路容量大的情况下效率较低">  </p>
<p><img src="/2022/04/19/computernetworknotes3/RDT3xingneng2.png" alt="RDT 3.0 停止-等待">  </p>
<h3 id="可靠数据传输协议：流水线"><a href="#可靠数据传输协议：流水线" class="headerlink" title="可靠数据传输协议：流水线"></a>可靠数据传输协议：流水线</h3><h4 id="流水线-pipeline-协议"><a href="#流水线-pipeline-协议" class="headerlink" title="流水线 (pipeline) 协议"></a>流水线 (pipeline) 协议</h4><p><strong>流水线</strong>：允许发送方在<strong>未得到对方确认</strong>的情况下，一次发送多个分组  </p>
<ul>
<li>必须增加序号的范围：用多个 bit 表示分组的序号  </li>
<li>在发送方/接收方要有缓冲区  <ul>
<li>发送方缓冲：未得到确认，可能需要重传  </li>
<li>接收方缓存：上层用户去用数据的速率 ≠ 接收到的数据速率；接收到的数据可能乱序，排序交付 (可靠)  </li>
</ul>
</li>
<li>两种通用的流水线协议：回退 N 步 (GBN) 和选择重传 (SR)  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/RDT3liushuixian.png" alt="流水线：提高链路利用率">  </p>
<h4 id="通用：滑动窗口-slide-window-协议"><a href="#通用：滑动窗口-slide-window-协议" class="headerlink" title="通用：滑动窗口 (slide window) 协议"></a>通用：滑动窗口 (slide window) 协议</h4><p>发送缓冲区  </p>
<ul>
<li>形式：内存中的一个区域，落入缓冲区的分组可以发送  </li>
<li>功能：用于存放已发送，但是没有得到确认的分组  </li>
<li>必要性：需要重发时可用  </li>
</ul>
<p>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组  </p>
<ul>
<li>停止等待协议 = 1  </li>
<li>流水线协议 &gt; 1；合理的值，不能很大，链路的利用率不能超过 100 %  </li>
</ul>
<p>发送缓冲区中的分组  </p>
<ul>
<li>未发送的：落入发送缓冲区中的分组，可以连续发送出去  </li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除  </li>
</ul>
<p>发送窗口滑动过程 - 相对表示方法  </p>
<ul>
<li>采用相对移动方式表示，分组不动  </li>
<li>可缓冲范围移动，代表一段可以发送的权力  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/xiangduihuadong.png" alt="发送滑动窗口过程的相对表示方法">  </p>
<p><strong>滑动窗口协议 - 发送窗口</strong>  </p>
<ul>
<li>发送窗口  <ul>
<li>发送缓冲区内容的一个范围  </li>
<li>那些已发送但是未经确认分组的序号构成的空间  </li>
</ul>
</li>
<li>发送窗口的最大值 ≤ 发送缓冲区的值  </li>
<li>一开始：没有发送任何一个分组  <ul>
<li>后沿 = 前沿  </li>
<li>之间为发送窗口的尺寸 = 0  </li>
</ul>
</li>
<li>每发送一个分组，前沿移动一个单位  </li>
<li>发送窗口前沿移动的极限：不能超过发送缓冲区</li>
<li>发送窗口后沿移动  <ul>
<li>条件：收到老分组的确认  </li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送  </li>
<li>移动的极限：不能超过前沿，即后沿贴到前沿  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/sendingwindow.png" alt="发送窗口 (sending window)"></p>
<p><strong>滑动窗口协议 - 接收窗口</strong>  </p>
<ul>
<li>接收窗口 (receiving window) = 接收缓冲区  </li>
<li>接收窗口用于控制那些分组可以接收  <ul>
<li>只有收到的分组序号落入接收窗口内才允许接收  </li>
<li>若序号再接收窗口之外，则丢弃 </li>
</ul>
</li>
<li>接收窗口尺寸<ul>
<li>接收窗口尺寸 Wr = 1，则只能顺序接收  </li>
<li>接收窗口尺寸 Wr &gt; 1，则可以乱序接收，但提交给上层的分组要按序  </li>
</ul>
</li>
<li>接收窗口的滑动  <ul>
<li>低序号分组的到来，接收窗口移动  </li>
<li>高序号分组乱序到，缓存但不交付 (因为要实现 RDT，不允许失序)，不滑动  </li>
</ul>
</li>
<li>接收窗口的发送确认  <ul>
<li>接收窗口尺寸 = 1：发送连续收到的最大的分组确认 (累计确认)  </li>
<li>接收窗口尺寸 &gt; 1：收到分组，发送那个分组的确认 (非累计确认/独立确认)  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/receivingwindow.png" alt="接收窗口 (receiving window)"></p>
<p><strong>正常情况下的 2 个窗口互动</strong>  </p>
<ul>
<li>发送窗口  <ul>
<li>有新的分组落入发送缓冲区范围，发送 -&gt; 前沿滑动  </li>
<li>来了老的低序号分组的确认 -&gt; 后沿向前滑动 -&gt; 新的分组可以落入发送缓冲区的范围  </li>
</ul>
</li>
<li>接收窗口  <ul>
<li>收到分组，落入到接收窗口范围内，接收  </li>
<li>是低序号，发送确认给对方  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/WWI.png" alt="发送窗口与接收窗口的互动">  </p>
<h4 id="异常情况下-GBN-与-SR-协议中的窗口互动"><a href="#异常情况下-GBN-与-SR-协议中的窗口互动" class="headerlink" title="异常情况下 GBN 与 SR 协议中的窗口互动"></a>异常情况下 GBN 与 SR 协议中的窗口互动</h4><p>异常情况下 GBN 的 2 窗口互动  </p>
<ul>
<li>发送窗口  <ul>
<li>新分组落入发送缓冲区范围，发送 -&gt; 前沿滑动  </li>
<li>超时重发机制让发送端将发送窗口中的所有分组发送出去  </li>
<li>来了老分组的重复确认 -&gt; 后沿不向前滑动 -&gt; 新的分组无法落入发送缓冲区的范围 (如果此时发送缓冲区有新的分组可以发送)  </li>
</ul>
</li>
<li>接收窗口  <ul>
<li>收到乱序分组，没有落入到接收窗口范围内，抛弃  </li>
<li>(重复) 发送老分组的确认，累计确认  </li>
</ul>
</li>
</ul>
<p>异常情况下 SR 的 2 窗口互动  </p>
<ul>
<li>发送窗口<ul>
<li>新分组落入发送缓冲区范围，发送 -&gt; 前沿滑动  </li>
<li>超时重发机制让发送端将超时的分组重新发送出去  </li>
<li>来了乱序分组的确认 -&gt; 后沿不向前滑动 -&gt; 新的分组无法落入发送缓冲区的范围 (如果此时发送缓冲区有新的分组可以发送)  </li>
</ul>
</li>
<li>接收窗口  <ul>
<li>收到乱序分组，落入到接收窗口范围内，接收  </li>
<li>发送该分组的确认，单独确认  </li>
</ul>
</li>
</ul>
<p><em>每发送一个分组，就要设定一个超时定时器，接收到分组确认时取消定时器</em></p>
<p>GBN 协议和 SR 协议的相同之处    </p>
<ul>
<li>发送窗口 &gt; 1  </li>
<li>一次可发送多个未经确认的分组  </li>
</ul>
<p>GBN 协议和 SR 协议的不同之处 (主要由于接收窗口大小不同)  </p>
<ul>
<li>GBN：接收窗口尺寸 = 1  <ul>
<li>接收端：只能顺序接收  </li>
<li>发送端：从表现来看，一旦一个分组没有发送成功，就要退回重发 (如 0，1，2，3，4 中 1 未成功，234 都发送出去，要返回 1 再发送：GB1)</li>
</ul>
</li>
<li>SR：接收窗口尺寸 &gt; 1  <ul>
<li>接收端：可以乱序接收  </li>
<li>发送端：发送0，1，2，3，4 中 1 未成功，234 都发送出去，无需重发，选择性发送 1  </li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><strong>GO-back-N</strong>  </p>
<ul>
<li>发送端最多在流水线中有 N 个未确认的分组  </li>
<li>接收端只是发送累计型确认 (cumulative ack)：接收端如果发现 gap，不确认信道来的分组  </li>
<li>发送端拥有对最老的未确认分组的定时器  <ul>
<li>秩序设置一个定时器  </li>
<li>当定时器到时时，重传所有未确认分组  </li>
</ul>
</li>
</ul>
<p>GBN：发送方扩展的 FSM  </p>
<p><img src="/2022/04/19/computernetworknotes3/GBNFSM.png" alt="GBN：发送方扩展的 FSM">  </p>
<p>GBN：接收方扩展的 FSM  </p>
<p><img src="/2022/04/19/computernetworknotes3/GBNFSMr.png" alt="GBN：接收方扩展的 FSM">  </p>
<ul>
<li>只发送 ACK：对顺序接收的最高序号的分组  <ul>
<li>可能会产生重复的 ACK  </li>
<li>只需记住 expectedseqnum；接收窗口 = 1；只一个变量就可以表示接收窗口  </li>
</ul>
</li>
<li>对乱序的分组  <ul>
<li>丢弃 (不缓存) -&gt; 在接收方不缓存  </li>
<li>对顺序接收的最高序号的分组进行确认 - 累计确认  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/runningGBN.png" alt="运行中的 GBN"></p>
<p><strong>Selective Repeat</strong>  </p>
<ul>
<li>发送端最多在流水线中有 N 个未确认的分组  </li>
<li>接收方对每个到来的分组单独确认 ACKn (individual ack)：非累计确认  <ul>
<li>接收窗口 &gt; 1，可以缓存乱序的分组  </li>
<li>最终将分组按顺序交付给上层</li>
</ul>
</li>
<li>发送方为每个未确认的分组保持一个定时器：当超时定时器到时时，只重发到时未确认分组  </li>
<li>发送窗口的最大值 (发送缓冲区) 限制发送未确认分组的个数  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/SRsummary.png">  </p>
<p><img src="/2022/04/19/computernetworknotes3/RunningSR.png" alt="选择重传 SR 的运行"></p>
<p><strong>对比 GBN 和 SR</strong>  </p>
<p><img src="/2022/04/19/computernetworknotes3/GBNvsSR.png">  </p>
<p>适用范围：  </p>
<ul>
<li>出错率低：比较适合 GBN，出错非常罕见，没有必要用复杂的 SR，为罕见的事件做日常准备和复杂处理  </li>
<li>链路容量大 (延迟大、带宽大)：适合 SR 而不是 GBN，否则一点出错代价太大  </li>
</ul>
<br>  

<h2 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h2><h3 id="TCP-概述"><a href="#TCP-概述" class="headerlink" title="TCP 概述"></a>TCP 概述</h3><p><strong>点对点</strong>：一个发送方，一个接收方<br><strong>可靠的、按顺序的字节流</strong>：没有报文边界<br><strong>管道化</strong> **(流水线)**：TCP 拥塞控制和流量控制设置窗口大小<br><strong>发送和接受缓存</strong><br><strong>全双工数据</strong>：在同一连接中数据流双向流动；MSS：最大报文段<br><strong>面向连接</strong>：在数据交换之前，通过握手 (交换控制报文) 初始化发送方、接收方的状态变量<br><strong>有流量控制</strong>：发送方不会淹没接收方  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPform.png" alt="TCP 报文段结构">  </p>
<h4 id="TCP-序号、确认号"><a href="#TCP-序号、确认号" class="headerlink" title="TCP 序号、确认号"></a>TCP 序号、确认号</h4><p><strong>序号</strong>：报文段首字节在字节流的编号<br><strong>确认号</strong>：期望从零乙方收到的下一个字节的序号；累计确认<br>Q：接收方如何处理乱序的报文段 - 没有规定  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPnumber.png">  </p>
<h3 id="TCP-往返延时-RTT-和超时"><a href="#TCP-往返延时-RTT-和超时" class="headerlink" title="TCP 往返延时 (RTT) 和超时"></a>TCP 往返延时 (RTT) 和超时</h3><h4 id="怎样设置-TCP-超时"><a href="#怎样设置-TCP-超时" class="headerlink" title="怎样设置 TCP 超时"></a>怎样设置 TCP 超时</h4><p>比 RTT 要长，但 RTT 是变化的<br>太短：太早超时，不必要的重传<br>太长：对报文段丢失反应太慢，消极  </p>
<h4 id="怎样估计-RTT？"><a href="#怎样估计-RTT？" class="headerlink" title="怎样估计 RTT？"></a>怎样估计 RTT？</h4><p>sampleRTT：测量从报文段发出到收到确认的时间</p>
<ul>
<li>如果又重传，忽略此次测量</li>
<li>定期测量  </li>
<li>sampleRTT 会变化，因此估计的 RTT 应该比较平滑</li>
<li>对几个最近的测量值求平均，而不是仅用当前的 sampleRTT  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/sampleRTT.png">  </p>
<h4 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h4><p>EstimtedRTT + 安全便捷时间：  </p>
<ul>
<li>EstimatedRTT 变化大 (方差大) -&gt; 较大的安全边界时间  </li>
</ul>
<p>SampleRTT 会偏离 EstimatedRTT 多远： </p>
<ul>
<li>DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT|  </li>
<li>推荐值：β = 0.25  </li>
</ul>
<p>超时时间间隔设置为：</p>
<ul>
<li>TimeoutInterval = EstimatedRTT + 4 * DevRTT  </li>
</ul>
<h3 id="TCP：可靠数据传输"><a href="#TCP：可靠数据传输" class="headerlink" title="TCP：可靠数据传输"></a>TCP：可靠数据传输</h3><p>TCP 在 IP 不可靠服务的基础上建立了 RDT  </p>
<ul>
<li>管道化 (pipeline) 的报文段：GBN or SR  </li>
<li>累计确认 (像 GBN)  </li>
<li>单个重传定时器 (像 GBN)  </li>
<li>是否可以接受乱序报文没有规范  </li>
</ul>
<p>通过以下事件触发重传  </p>
<ul>
<li>超时：只重发那个最早的未确认段 (SR)  </li>
<li>重复的确认：收到了 ACK50 之后又收到 3 个 ACK50  </li>
</ul>
<h4 id="简化的-TCP-发送方"><a href="#简化的-TCP-发送方" class="headerlink" title="简化的 TCP 发送方"></a>简化的 TCP 发送方</h4><ul>
<li>忽略重复的确认  </li>
<li>忽略流量控制和拥塞控制  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/TCPsendersimple.png" alt="TCP 发送方 (简化版)"></p>
<h4 id="TCP-发送方事件"><a href="#TCP-发送方事件" class="headerlink" title="TCP 发送方事件"></a>TCP 发送方事件</h4><p>从应用层接收数据：  </p>
<ul>
<li>用 nextseq 创建报文段  </li>
<li>序号 nextseq 为报文段首字节的字节流编号  </li>
<li>如果还没有运行，启动定时器  <ul>
<li>定时器与最早未确认的报文段关联  </li>
<li>过期间隔：TimeOutInterval  </li>
</ul>
</li>
</ul>
<p>超时：  </p>
<ul>
<li>重传后沿最老的报文段  </li>
<li>重新启动定时器  </li>
</ul>
<p>收到确认：  </p>
<ul>
<li>如果是对尚未确认的报文段确认  <ul>
<li>更新已被确认的报文序号  </li>
<li>如果当前还有违背确认的报文段，重新启动定时器  </li>
</ul>
</li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/TCPsendersimplecode.png" alt="简化的 TCP 发送方伪码">  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPresend.png" alt="TCP 重传">  </p>
<h4 id="产生-TCP-ACK-的建议"><a href="#产生-TCP-ACK-的建议" class="headerlink" title="产生 TCP ACK 的建议"></a>产生 TCP ACK 的建议</h4><p><img src="/2022/04/19/computernetworknotes3/TCPACKsuggestion.png"></p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><ul>
<li>超时周期往往太长：在重传丢失报文段之前的延时太长  </li>
<li>通过重复的 ACK 来检测报文段丢失  <ul>
<li>发送方通常连续发送大量报文段  </li>
<li>如果报文段丢失，通常会引起多个重复的 ACK  </li>
</ul>
</li>
<li>如果发送方收到统一数据的 3 个冗余 ACK，重传最小序号的段  <ul>
<li><strong>快速重传</strong>：在定时器过时之前重发报文段  </li>
<li>它假设跟在呗确认的数据后面的数据丢失了  <ul>
<li>第一个 ACK 是正常的  </li>
<li>收到第二个该段的 ACK，表示接收方到收到一个该段后的乱序段  </li>
<li>收到第 3、4 个该段的 ACK，表示接收方收到该段之后的 2 个、3 个乱序段，可能性非常大段丢失了  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>缓冲区 TCP 往里面写，app 从当中读取  </p>
<p><img src="/2022/04/19/computernetworknotes3/TCPstreamcontrol.png" alt="接收方协议栈">  </p>
<p><strong>流量控制</strong>：接收方控制发送方，不让发送方发送太多、太快以至于让接收方的缓冲区溢出  </p>
<p>接收方在其向发送方的 TCP 段头部的 rwnd 字段 “通告” 其空闲 brffer 大小  </p>
<ul>
<li>RcvBuffer 大小通过 socket 选项设置 (典型默认大小为 4096 字节)  </li>
<li>很多操作系统自动调整 RcvBuffer  </li>
</ul>
<p>发送方限制未确认 (in-flight) 字节的个数 ≤ 接收方发送过来的 rwnd 值<br>保证接收方不会被淹没  </p>
<p><img src="/2022/04/19/computernetworknotes3/rcvbuffer.png" alt="接收方 buffer 大小">  </p>
<p><img src="/2022/04/19/computernetworknotes3/rcvwindow.png" alt="接收方 Recieve Window">  </p>
<h3 id="TCP-连接建立"><a href="#TCP-连接建立" class="headerlink" title="TCP 连接建立"></a>TCP 连接建立</h3><p>在正式交换数据之前，发送方和接收方握手建立通信关系：  </p>
<ul>
<li>同意建立连接 (每一方抖直到对方愿意建立连接)  </li>
<li>同意连接参数  </li>
</ul>
<h4 id="同意建立连接"><a href="#同意建立连接" class="headerlink" title="同意建立连接"></a>同意建立连接</h4><p>Q：在网格中，2 次握手建立连接总是可行吗？  </p>
<ul>
<li>变化的延迟 (连接请求的段没有丢，但可能超时)  </li>
<li>由于丢失造成的重传 (eg. req_conn(x))  </li>
<li>报文乱序  </li>
<li>互相看不到对方  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/hellofailure.png" alt="2 次握手失败场景">  </p>
<p>解决方案：变化的初始序号 + 双方确认对方的序号 (3 次握手)</p>
<p><img src="/2022/04/19/computernetworknotes3/3hello.png" alt="TCP 3 次握手">  </p>
<p><img src="/2022/04/19/computernetworknotes3/3hello2.png" alt="TCP 3 次握手">  </p>
<p><img src="/2022/04/19/computernetworknotes3/3helloFSM.png" alt="TCP 3 次握手">  </p>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>客户端、服务器分别关闭自己这一侧的连接  </p>
<ul>
<li>发送 FIN bit = 1 的 TCP 段  </li>
</ul>
<p>一旦接收到 FIN，用 ACK 回应  </p>
<ul>
<li>接到 FIN 段，ACK 可以和它自己发出的 FIN 段一起发送</li>
</ul>
<p>可以处理同时的 FIN 交换  </p>
<br>

<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="拥塞"><a href="#拥塞" class="headerlink" title="拥塞"></a>拥塞</h3><p>非正式的定义：太多数据需要网络传输，超过了网络的处理能力<br>与流量控制不同<br>拥塞的表现：  </p>
<ul>
<li>分组丢失 (路由器缓冲区溢出)  </li>
<li>分组经历比较长的延迟 (在路由器的队列中排队)  </li>
</ul>
<h4 id="拥塞的原因-代价：场景-1"><a href="#拥塞的原因-代价：场景-1" class="headerlink" title="拥塞的原因/代价：场景 1"></a>拥塞的原因/代价：场景 1</h4><p><img src="/2022/04/19/computernetworknotes3/jam1.png">  </p>
<h4 id="拥塞的原因-代价：场景-2"><a href="#拥塞的原因-代价：场景-2" class="headerlink" title="拥塞的原因/代价：场景 2"></a>拥塞的原因/代价：场景 2</h4><p><img src="/2022/04/19/computernetworknotes3/jam2.png">  </p>
<p>现实情况：重复  </p>
<ul>
<li>分组可能丢失，由于缓冲器满而被丢弃  </li>
<li>发送端最终超时，发送第二个拷贝，两个分组都被传到  </li>
</ul>
<p>拥塞代价：  </p>
<ul>
<li>为了达到一个有效输出，网络需要做更多的工作 (重传)  </li>
<li>没有必要的重传，链路中包括了多个分组的拷贝：是那些没有丢失，经历的时间比较长 (拥塞状态) 但超时的分组；降低了的 “goodput”  </li>
</ul>
<h4 id="拥塞的原因-代价：场景-3"><a href="#拥塞的原因-代价：场景-3" class="headerlink" title="拥塞的原因/代价：场景 3"></a>拥塞的原因/代价：场景 3</h4><p><img src="/2022/04/19/computernetworknotes3/jam3.png">  </p>
<p>拥塞代价：当分组丢失时，任何 “关于这个分组的上游传输能力” 都被浪费  </p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><h4 id="网络辅助的拥塞控制"><a href="#网络辅助的拥塞控制" class="headerlink" title="网络辅助的拥塞控制"></a>网络辅助的拥塞控制</h4><p>路由器提供给端系统以反馈信息  </p>
<ul>
<li>单个 bit 置位，显示有拥塞 (SNA，DECbit，TCP/IP ECN，ATM)  </li>
<li>显式提供发送端可以采用的速率  </li>
</ul>
<h4 id="端到端拥塞控制"><a href="#端到端拥塞控制" class="headerlink" title="端到端拥塞控制"></a>端到端拥塞控制</h4><p>没有来自网络的显示反馈<br>端系统根据延迟和丢失事件推断是否有拥塞<br>TCP 采用的方法  </p>
<h4 id="ATM-ABR-拥塞控制"><a href="#ATM-ABR-拥塞控制" class="headerlink" title="ATM ABR 拥塞控制"></a>ATM ABR 拥塞控制</h4><p>ABR：available bit rate  </p>
<ul>
<li>弹性服务  </li>
<li>如果发送端的路径 “轻载”：发送方使用可用带宽  </li>
<li>如果发送方的路径用色了，发送方限制其发送的速度到一个最小保障速率上  </li>
</ul>
<p>RM (资源管理) 信元  </p>
<ul>
<li>有发送端发送，在数据心愿中间隔插入  </li>
<li>RM 信元中的比特被交换机设置 (网络辅助)  <ul>
<li>NI bit：no increase in rate (轻微拥塞)速率不要增加了  </li>
<li>CI bit：congestion indication 拥塞指示  </li>
</ul>
</li>
<li>发送端发送的 RM 信元被接收端返回，接收端不做任何改变  </li>
</ul>
<p>在 RM 信元中的 2 个字节 ER (explicit rate) 字段  </p>
<ul>
<li>拥塞的交换机可能会降低信元中 ER 的值  </li>
<li>发送端发送速度因此是最低的可支持速率  </li>
</ul>
<p>数据信元中的 EFCI bit：备用色的交换机设置为 1  </p>
<ul>
<li>如果在管理信元 RM 前面的数据信元 EFCI 被设置成了 1，接收端在返回的 RM 信元中设置 CI bit  </li>
</ul>
<br>

<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><h4 id="端到端的拥塞控制机制"><a href="#端到端的拥塞控制机制" class="headerlink" title="端到端的拥塞控制机制"></a>端到端的拥塞控制机制</h4><p>路由器不向主机有关拥塞反馈信息  </p>
<ul>
<li>路由器的负担较轻  </li>
<li>符合网络核心简单的 TCP/IP 架构远离  </li>
</ul>
<p>端系统根据自身的到的信息，判断是否发生拥塞，从而采取动作  </p>
<h4 id="拥塞控制的几个问题"><a href="#拥塞控制的几个问题" class="headerlink" title="拥塞控制的几个问题"></a>拥塞控制的几个问题</h4><p>如何检测拥塞  </p>
<ul>
<li>轻微拥塞  </li>
<li>拥塞  </li>
</ul>
<p>控制策略  </p>
<ul>
<li>在拥塞发生时如何动作降低速率：轻微拥塞和拥塞分别如何降低  </li>
<li>在拥塞缓解时如何动作增加速率  </li>
</ul>
<h3 id="拥塞感知"><a href="#拥塞感知" class="headerlink" title="拥塞感知"></a>拥塞感知</h3><h4 id="发送端如何探测到拥塞"><a href="#发送端如何探测到拥塞" class="headerlink" title="发送端如何探测到拥塞"></a>发送端如何探测到拥塞</h4><p>某个段超时 (丢失事件)：拥塞  </p>
<ul>
<li>超时时间到，某个段的确认没有来  </li>
<li>原因 1：网络拥塞 (某个路由器缓冲区没空间了，被丢弃)，概率大  </li>
<li>原因 2：出错被丢弃 (各级错误，没有通过校验，被丢弃)，概率小  </li>
<li>一旦超时，就认为拥塞会有一定误判，但总体控制方向是对的  </li>
</ul>
<p>有关某个段的 3 次重复 ACK：轻微拥塞  </p>
<ul>
<li>段的第 1 个 ACK，正常，确认绿段，期待红段  </li>
<li>段的第 2 个重复 ACK，意味着红段的后一段收到了，蓝段乱序到达  </li>
<li>段的第 2、3、4 个 ACK 重复，意味着红段的后第 2、3、4 个段收到了，橙段乱序到达，同时红段丢失的可能性很大 (后面 3 个段都到了，红段还没到)  </li>
<li>网络这时还能够进行一定程度的传输，拥塞但情况比第一种好  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/yongseganzhi.png">  </p>
<h3 id="速率控制方法"><a href="#速率控制方法" class="headerlink" title="速率控制方法"></a>速率控制方法</h3><h4 id="如何控制发送端发送的速率"><a href="#如何控制发送端发送的速率" class="headerlink" title="如何控制发送端发送的速率"></a>如何控制发送端发送的速率</h4><p>维持一个拥塞窗口的值：CongWin<br>发送端限制已发送但是未确认的数据量 (的上限)  </p>
<ul>
<li>LastByteSent-LastByteAcked ≤ CongWin  </li>
</ul>
<p>从而粗略地控制发送方往网络中注入的速率  </p>
<p><img src="/2022/04/19/computernetworknotes3/sulvkongzhi.png"></p>
<p>CongWin 是动态的，是感知到的网络拥塞程度的函数  </p>
<ul>
<li>超时或者 3 个重复 ACK，CongWin：<ul>
<li>超时时：CongWin 降为 1 MSS，进入 SS 阶段然后再倍增到 CongWin / 2 (每个 RTT)，从而进入 CA 阶段  </li>
<li>3 个重复 ACK：CongWin 降为 CongWin / 2，CA 阶段  </li>
</ul>
</li>
<li>否则 (正常收到 ACK，没有发送以上情况)：CongWin 跃跃欲试  <ul>
<li>SS 阶段：加倍增加 (每个 RTT)  </li>
<li>CA 阶段：线性增加 (每个 RTT)</li>
</ul>
</li>
</ul>
<h4 id="TCP-拥塞控制和流量控制的联合动作"><a href="#TCP-拥塞控制和流量控制的联合动作" class="headerlink" title="TCP 拥塞控制和流量控制的联合动作"></a>TCP 拥塞控制和流量控制的联合动作</h4><p>联合控制方法：  </p>
<ul>
<li>发送段控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求  <ul>
<li>SendWin = min{CongWin, RecvWin}  </li>
<li>同时满足拥塞控制和流量控制要求  </li>
</ul>
</li>
</ul>
<h3 id="TCP-拥塞控制：策略概述"><a href="#TCP-拥塞控制：策略概述" class="headerlink" title="TCP 拥塞控制：策略概述"></a>TCP 拥塞控制：策略概述</h3><p>拥塞控制策略：  </p>
<ul>
<li>慢启动  </li>
<li>AIMD：线性增、乘性减少  </li>
<li>超时时间后的保守策略  </li>
</ul>
<h3 id="TCP-慢启动"><a href="#TCP-慢启动" class="headerlink" title="TCP 慢启动"></a>TCP 慢启动</h3><p>当连接开始时，指数性增加 (每个 RTT) 发送速率直到发生丢失事件  </p>
<ul>
<li>每一个 RTT，CongWin 加倍  </li>
<li>每收到一个 ACK 时，CongWin 加 1  </li>
<li>慢启动阶段：只要不超时或 3 个重复 ACK，一个 RTT，CongWin 加倍  </li>
</ul>
<p>总结：初始速率很慢，但加速确是指数性的  </p>
<ul>
<li>指数增加，SS 时间很短，长期来看可以忽略  </li>
</ul>
<h4 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h4><p>乘性减：丢失事件后将 CongWin 降为 1，将 CongWin / 2 作为阈值，进入到慢启动阶段 (倍增直到 CongWin / 2)<br>加性增：当 CongWin &gt; 阈值时，一个 RTT 如没有发生丢失事件，将 CongWin 加 1 MSS (探测)</p>
<p>当收到 3 个重复的 ACKs  </p>
<ul>
<li>CongWin 减半  </li>
<li>窗口 (缓冲区大小) 之后线性增长  </li>
</ul>
<p>当超时事件发生时  </p>
<ul>
<li>CongWin 被设置成 1 MSS，进入 SS 阶段  </li>
<li>之后窗口指数增长  </li>
<li>增长到一个阈值 (上次发生拥塞的窗口的一半) 时，再线性增加  </li>
</ul>
<p>思路：  </p>
<ul>
<li>3 个重复的 ACK 表示网络还有一定的段传输能力  </li>
<li>超时之前的 3 个重复的 ACK 表示 “警报”  </li>
</ul>
<p>改进  </p>
<ul>
<li>什么时候应该将指数性增长变成线性  </li>
<li>在超时之前，当 CongWin 变成上次超时时的窗口的一半  </li>
</ul>
<p>实现  </p>
<ul>
<li>变量：Threshold  </li>
<li>出现丢失，Threshold 设置成 CongWin 的 1/2  </li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当 CongWin &lt; Threshold，发送端处于慢启动阶段 (slow-start)，窗口指数型增长<br>当 CongWin &gt; Threshold，发送端处于拥塞避免阶段 (congestion-avoidance)，窗口线性增长<br>当收到三个重复的 ACKs (triple duplicate ACK)，Threshold 设置成 CongWin / 2，CongWin = Threshold + 3<br>当超时事件发生时 (timeout)，Threshold = CongWin / 2，CongWin = 1 MSS，进入 SS 阶段</p>
<p><img src="/2022/04/19/computernetworknotes3/TCPsendercongcon.png" alt="TCP 发送端拥塞控制"></p>
<h3 id="TCP-吞吐量"><a href="#TCP-吞吐量" class="headerlink" title="TCP 吞吐量"></a>TCP 吞吐量</h3><p>W：发生丢失事件时的窗口尺寸 (单位：字节)  </p>
<ul>
<li>平均窗口尺寸 (#in-filght 字节)：3/4 W  </li>
<li>平均吞吐量：RTT 事件吞吐 3/4 W  </li>
</ul>
<p><img src="/2022/04/19/computernetworknotes3/inout.png" alt="TCP 吞吐量"></p>
<h3 id="TCP-公平性"><a href="#TCP-公平性" class="headerlink" title="TCP 公平性"></a>TCP 公平性</h3><p>公平性目标：如果 K 个 TCP 会话分享一个链路带宽为 R 的瓶颈，每一个绘画的有效带宽为 R/K  </p>
<h4 id="为什么-TCP-是公平的"><a href="#为什么-TCP-是公平的" class="headerlink" title="为什么 TCP 是公平的"></a>为什么 TCP 是公平的</h4><p>2 个竞争的 TCP 会话：  </p>
<ul>
<li>加性增加，斜率为 1，吞吐量增加  </li>
<li>乘性减，吞吐量比例减少  </li>
</ul>
<h4 id="公平性和-UDP"><a href="#公平性和-UDP" class="headerlink" title="公平性和 UDP"></a>公平性和 UDP</h4><p>多媒体应用通常不是 TCP  </p>
<ul>
<li>应用发送的数据速率希望不受拥塞控制的节制  </li>
</ul>
<p>使用 UDP：  </p>
<ul>
<li>音视频应用泵出数据的速率是恒定的，忽略数据的丢失  </li>
</ul>
<p>研究领域：TCP 友好性  </p>
<h4 id="公平性和并行-TCP-连接"><a href="#公平性和并行-TCP-连接" class="headerlink" title="公平性和并行 TCP 连接"></a>公平性和并行 TCP 连接</h4><p>2 个主机间可以打开多个并行的 TCP 连接<br>Web 浏览器  </p>
<p>例如：带宽为 R 的链路支持了 9 个连接  </p>
<ul>
<li>如果新的应用要求建 1 个 TCP 连接，获得带宽 R/10  </li>
<li>如果新的应用要求建 11 个 TCP 连接，获得带宽 R/2  </li>
</ul>
<h3 id="Explicit-Congestion-Notification-ECN"><a href="#Explicit-Congestion-Notification-ECN" class="headerlink" title="Explicit Congestion Notification (ECN)"></a>Explicit Congestion Notification (ECN)</h3><p>网络辅助拥塞控制：  </p>
<ul>
<li>TOS 字段中 2 个 bit 被网络路由器标记，用于只是是否发生拥塞  </li>
<li>拥塞指示被传送到接收主机  </li>
<li>在接受方到发送方的 ACK 中，接收方 (在 IP 数据报中看到了拥塞指示)设置 ECE bit，指示发送方发生了拥塞</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS：一款赛博乐高</title>
    <url>/2022/08/13/cyberlego/</url>
    <content><![CDATA[<center> 简单总结一下在 VPS 上折腾的一些小东西 </center>
<span id="more"></span>

<br>

<h2 id="Mastodon"><a href="#Mastodon" class="headerlink" title="Mastodon"></a>Mastodon</h2><p>买这个 VPS 就是为了长毛象，搭建过程非常缓慢，详细搭建过程见：<a href="https://tech.musain.club/2022/03/02/buildmastodon/">Mastodon 建站笔记</a>。搭建过程中遇到的很多问题，都在这篇中有提到。搭建一个长毛象实例并不难，后期装修维护才是挑战。各种各样零散的问题都会出现，甚至直到前几天才发现原来之前一直看错了 dockerhub 的报错信息。等有空需要给所有装修都总结成一篇装修笔记，以免以后忘记做过哪些东西。<br>目前站点除去朋友注册和 bot 账号约有四十多人，但由于很多人都只是建个魂器，所以总体开销并没有预期大，保持目前的配置扩建至 100 人应该没有问题。不过人少也有人少的好处，站点真的像一个咖啡馆，有经常来的熟客也有偶尔来喝一杯的生客。总得来说达到了我预想的结果，后续如果能有更多熟客就更好了。  </p>
<h2 id="Plume"><a href="#Plume" class="headerlink" title="Plume"></a>Plume</h2><p>虽然已经有很多博客，但还是搭建了 plume。一开始的想法是来咖啡馆的人应该多多少少都会写同人，搭个 plume 比在咖啡馆直接发长文好，还能和咖啡馆直接互通，对创作者和读者之间的交流十分友好。但实际上大多数人都只是注册一下，然后放着不用。就连我自己也只是注册了一个账号，没有往这个账号搬运任何文。对我来说 plume 只是一个替代平台，除非 hugo + vercel 和 AO3 (甚至是 wordpress) 都不好用才会考虑用 plume。<br>搭建 plume 并不难，只在配置 ngnix 时出错重来过一次。也有很多教程，所以没有记录如何搭建。在这里存一个教程：<a href="https://blog.tantalum.life/posts/build-plume-in-docker/">Plume | 利用Docker-compose搭建Fedi开源博客平台</a></p>
<h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><p>之前为了找一个不受审查还不被墙的即时聊天软件搜遍全网，直到自己有了一台 VPS，终于依靠搭建 matrix 从这种情况中脱离出来。虽然 matrix 由于发送每条消息都需要加密，所以发送图片还是很慢，但日常聊天可以忍这一点小毛病。这也是除了 mastodon 以外，我服务器上最活跃的应用。拼 lego 是自嗨游戏，搭好之后还是有人用更快乐。<br>不过 matrix 也不是没有被墙的风险，但和 mastodon 类似，一个服务器被墙还有无数个服务器可以选择。唯一的问题是很多搭建 matrix 的站长都不喜欢对外开放注册，我也是这样，而 matrix 大站已经被墙。这其实间接导致很多人无法真正开始使用 matrix，毕竟朋友都不能用的话，聊天软件也就失去意义。可能这就是为什么站内要账号的人不少，真正使用的人不多吧。<br>搭建 matrix 主要参考了两个教程：<a href="https://www.b612.me/code/223.html">使用docker搭建Synapse(Matrix)</a> 和 <a href="https://tech.konata.co/2022-04-10-matrix/">Matrix | 使用 docker 搭建 Synapse 记录</a>。我的搭建过程并没有记录下来，现在想想虽然都是别人写过的东西，也还是应该记录一份自己完成的过程。下次一定。  </p>
<h2 id="Bot"><a href="#Bot" class="headerlink" title="Bot"></a>Bot</h2><p>这部分算是我的一时兴起，以及想知道如何做到这件事而进行的两个尝试。即使一开始就知道写的 bot 无人在意，但还是很用心地完成了这两个 bot。算是我买了这个 VPS 之后最意外的收获，发现自己竟还有探索欲，竟然能够纯粹为了满足自己而去做一件事。  </p>
<h3 id="自动发嘟的喵喵喵"><a href="#自动发嘟的喵喵喵" class="headerlink" title="自动发嘟的喵喵喵"></a>自动发嘟的喵喵喵</h3><p>象上实现自动发嘟的 bot 有很多，在没有自己的站点和服务器时就很好奇这些 bot 如何运营。稍微看点教程就发现如果只是在自己电脑上运行的话，很可能需要一直开着电脑。如果想要完全自动化，最好还是有一个自己的服务器。所以在建好站点之后，有个很小的由头就火速写了喵喵喵。关于 bot 背后的原理其实并不完全清楚，但不知道 why 并不影响 how，所以还是很顺利完成了这个非常简单的 bot。<br>搭建过程：<a href="https://tech.musain.club/2022/07/12/catsama/">CATsama：如何做一个定时发嘟的 Mastodon bot</a><br>喵喵本喵：<a href="https://musain.cafe/@CATsama">喵喵喵</a>  </p>
<h3 id="自动回复的汪汪汪"><a href="#自动回复的汪汪汪" class="headerlink" title="自动回复的汪汪汪"></a>自动回复的汪汪汪</h3><p>学会了自动发嘟就自然而然想学会自动回复，但整个过程比自动发嘟波折得多。幸好即使最初参考的教程非常详细，也在一开始就边做边记录，所以整个波折的过程也被写下来。虽然可能不具有什么真正的参考性，但自己回顾时会觉得很开心，抓耳挠腮想办法也很开心。最后这个 bot 只能说是可以运行，并没有真正实现我一开始想要的那种自动回复。但由于问题在站点设置，而不在代码，站点又是我根据教程一步步来的，完全不知道从何改起，目前来讲这个 bot 只能这样子了。<br>搭建过程：<a href="https://tech.musain.club/2022/07/20/dogchan/">DOGchan：如何做一个能够自动回复的 Mastodon bot</a><br>汪汪本汪：<a href="https://musain.cafe/@DOGchan">汪汪汪</a>  </p>
<h2 id="说点感想"><a href="#说点感想" class="headerlink" title="说点感想"></a>说点感想</h2><p>写完才发现其实在 VPS 上搞的东西也不算多，但每一个都是自己想去做就做了的。就像在 bot 部分说的，这个 VPS 带给我的最大惊喜是竟然还有这么多东西我想去探索、想知道如何实现。这个列表在未来还会继续变多，说不定什么时候看到感兴趣的东西就又在服务器上折腾点什么。但目前来讲更重要的是维护已有东西的稳定，在此基础之上搞搞装修。<br>忘记是哪里看到的，说 VPS 就是一款赛博乐高，的确如此。  </p>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>DOGchan：如何做一个能够自动回复的 Mastodon bot</title>
    <url>/2022/07/20/dogchan/</url>
    <content><![CDATA[<center> 任何时间，任何地点，可爱狗狗，认真汪汪！ </center>
<span id="more"></span>

<br>

<p>缪尚咖啡馆已经有只傲娇猫猫，当然也要有可爱狗狗！于是决定学习制作一个能够自动回复的狗狗 bot，让缪尚咖啡馆实现猫狗双全。让我们有请小狗汪汪！  </p>
<h2 id="利用-Node-及-mastodon-api-实现自动回复-bot"><a href="#利用-Node-及-mastodon-api-实现自动回复-bot" class="headerlink" title="利用 Node 及 mastodon-api 实现自动回复 bot"></a>利用 Node 及 mastodon-api 实现自动回复 bot</h2><p>由于这一方法在尝试过程中 bug 百出，且没有找到合适的解决方案，暂时搁置，转而使用 <code>Mastodon.py</code>。<br>但此方法本身较为好懂，油管教程也也非常详细、容易上手。虽然很不想承认，但我没有搭建成功应该是我的问题，可能会在以后更熟悉 JavaScript 时再回头看这个教程。  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>长毛象顶流：<a href="https://github.com/TheTarr/mastodon_bot">操操</a><br>油管教程：<a href="https://www.youtube.com/playlist?list=PLRqwX-V7Uu6byiVX7_Z1rclitVhMBmNFQ">Mastodon API and Bots: Node.js</a>  </p>
<h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>选择一个合适的站点注册 bot 账号，并修改资料，注意选中 “这是一个 bot 账号 / This is a bot account”。<br>在管理面板找到开发/Development-创建新应用/New Application，创建新应用并给予读写权限，复制访问令牌。  </p>
<h3 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 node</h3><p>由于服务器上还没有安装 npm，所以第一步需要先安装。直接使用命令安装。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install npm</span><br><span class="line">mkdir dogchan <span class="comment"># 为 bot 相关文件新建目录</span></span><br><span class="line"><span class="built_in">cd</span> dogchan</span><br></pre></td></tr></table></figure>

<p>接下来运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p>根据提示一步步填写初始化信息：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm help json` for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (dogchan) dogchan</span><br><span class="line">version: (<span class="number">1.0</span><span class="number">.0</span>) <span class="number">0.0</span><span class="number">.1</span></span><br><span class="line">description: A dog bot</span><br><span class="line">entry point: (index.js) bot.js</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords: bot, mastodon</span><br><span class="line">author: melocery</span><br><span class="line">license: (ISC) MIT</span><br><span class="line">About to write to /root/miniconda/dogchan/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;dogchan&quot;</span>,</span><br><span class="line"><span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line"><span class="attr">&quot;description&quot;</span>: <span class="string">&quot;A dog bot&quot;</span>,</span><br><span class="line"><span class="attr">&quot;main&quot;</span>: <span class="string">&quot;bot.js&quot;</span>,</span><br><span class="line"><span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;keywords&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;bot&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mastodon&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">&quot;author&quot;</span>: <span class="string">&quot;melocery&quot;</span>,</span><br><span class="line"><span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this OK? (yes) yes</span><br></pre></td></tr></table></figure>

<p>现在查看 <code>dogchan</code> 目录下会多出一个名为 <code>package.json</code> 的文件，内容是刚才初始化填写的信息。  </p>
<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>运行命令：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install dotenv</span><br></pre></td></tr></table></figure>

<p>出现问题：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm WARN notsup Unsupported engine <span class="keyword">for</span> dotenv@16.0.1: wanted: &#123;<span class="string">&quot;node&quot;</span>:<span class="string">&quot;&gt;=12&quot;</span>&#125; (current: &#123;<span class="string">&quot;node&quot;</span>:<span class="string">&quot;10.19.0&quot;</span>,<span class="string">&quot;npm&quot;</span>:<span class="string">&quot;6.14.4&quot;</span>&#125;)</span><br><span class="line">npm WARN notsup Not compatible with your version of node/npm: dotenv@16.0.1</span><br></pre></td></tr></table></figure>

<p>提醒安装的 <code>node</code> 和 <code>npm</code> 版本不足。查找教程升级版本后，再次运行命令出现新的报错：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node:internal/modules/cjs/loader:936</span><br><span class="line">  throw err;</span><br><span class="line">  ^</span><br><span class="line"></span><br><span class="line">Error: Cannot find module <span class="string">&#x27;semver&#x27;</span></span><br><span class="line">Require stack:</span><br><span class="line">- /usr/share/npm/lib/utils/unsupported.js</span><br><span class="line">- /usr/share/npm/bin/npm-cli.js</span><br><span class="line">    at Function.Module._resolveFilename (node:internal/modules/cjs/loader:933:15)</span><br><span class="line">    at Function.Module._load (node:internal/modules/cjs/loader:778:27)</span><br><span class="line">    at Module.require (node:internal/modules/cjs/loader:1005:19)</span><br><span class="line">    at require (node:internal/modules/cjs/helpers:102:18)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/usr/share/npm/lib/utils/unsupported.js:2:14)</span><br><span class="line">    at Module._compile (node:internal/modules/cjs/loader:1105:14)</span><br><span class="line">    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1159:10)</span><br><span class="line">    at Module.load (node:internal/modules/cjs/loader:981:32)</span><br><span class="line">    at Function.Module._load (node:internal/modules/cjs/loader:822:12)</span><br><span class="line">    at Module.require (node:internal/modules/cjs/loader:1005:19) &#123;</span><br><span class="line">code: <span class="string">&#x27;MODULE_NOT_FOUND&#x27;</span>,</span><br><span class="line">requireStack: [</span><br><span class="line">    <span class="string">&#x27;/usr/share/npm/lib/utils/unsupported.js&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/usr/share/npm/bin/npm-cli.js&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谷歌解决方法大多数是完全卸载后重装，但无论卸载重装多少次，总会遇到 <code>Error: Cannot find module &#39;semver&#39;</code>。最后的解决方式是：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完全 uninstall node 和 npm</span></span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/bin/npm /usr/<span class="built_in">local</span>/share/man/man1/node* ~/.npm</span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/lib/node*</span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/bin/node*</span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/include/node*</span><br><span class="line"></span><br><span class="line">sudo apt-get purge nodejs npm</span><br><span class="line">sudo apt autoremove</span><br><span class="line"></span><br><span class="line"><span class="comment"># reinstall</span></span><br><span class="line">wget https://nodejs.org/dist/v16.16.0/node-v16.16.0-linux-x64.tar.xz</span><br><span class="line">tar -xf node-v16.16.0-linux-x64.tar.xz</span><br><span class="line">sudo mv node-v16.16.0-linux-x64/bin/* /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">sudo mv node-v16.16.0-linux-x64/lib/node_modules/ /usr/<span class="built_in">local</span>/lib/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装情况</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>这里再次出现状况，运行 <code>npm -v</code> 时报错：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-bash: /usr/bin/npm: No such file or directory</span><br></pre></td></tr></table></figure>

<p>但如果换为运行 <code>/usr/local/bin/npm -v</code> 则能够正常显示版本号。没有再次搜索问题原因，直接在 <code>.bashrc</code> 文件中增加一行：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias npm=&#x27;/usr/local/bin/npm&#x27;</span><br></pre></td></tr></table></figure>

<p>而后执行 <code>source .bashrc</code>。此时运行 <code>npm -v</code> 即可正常显示版本号。  </p>
<p>重新进行关于 npm 的所有命令，直到安装完成 <code>dotenv</code>。安装完成后出现提醒信息：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">added 1 package, and audited 236 packages in 1s</span><br><span class="line"></span><br><span class="line">5 packages are looking for funding</span><br><span class="line">run `npm fund` for details</span><br><span class="line"></span><br><span class="line">8 vulnerabilities (2 moderate, 3 high, 3 critical)</span><br><span class="line"></span><br><span class="line">To address issues that do not require attention, run:</span><br><span class="line">npm audit fix</span><br><span class="line"></span><br><span class="line">Some issues need review, and may require choosing</span><br><span class="line">a different dependency.</span><br><span class="line"></span><br><span class="line">Run `npm audit` for details.</span><br></pre></td></tr></table></figure>

<p>没有找到解决方法，运行 <code>npm audit fix --force</code> 也无法解决 8 vulnerabilities，暂时搁置。  </p>
<p>新建文件 <code>.env</code>，将前述步骤中得到的 bot 访问令牌填入文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 应用 ID</span><br><span class="line">CLIENT_KEY= </span><br><span class="line"># 应用密钥</span><br><span class="line">CLIENT_SECRET=</span><br><span class="line"># 访问令牌</span><br><span class="line">ACCESS_TOKEN= </span><br><span class="line"># bot 所在站点</span><br><span class="line">API_URL=https://musain.cafe/api/v1/ </span><br></pre></td></tr></table></figure>

<p>保存并退出。<br>新建 <code>bot.js</code> 文件，在文件内写入：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>).config();</span><br></pre></td></tr></table></figure>

<p>由于后续会将整个 bot 的代码上传至 github，所以需要将真正的 <code>.env</code> 隐藏起来而上传一个示例文件。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano .env-example</span><br><span class="line"></span><br><span class="line"><span class="comment">## 写入如下内容后保存并退出，文件中不需要 &#x27;#&#x27;，此处该符号仅为标记文件内容</span></span><br><span class="line"><span class="comment"># CLIENT_KEY=</span></span><br><span class="line"><span class="comment"># CLIENT_SECRET=</span></span><br><span class="line"><span class="comment"># ACCESS_TOKEN=</span></span><br><span class="line"><span class="comment"># API_URL=https://musain.cafe/api/v1/</span></span><br><span class="line"></span><br><span class="line">nano .gitignore</span><br><span class="line"><span class="comment">## 写入如下内容后保存并退出，文件中不需要 &#x27;#&#x27;，此处该符号仅为标记文件内容</span></span><br><span class="line"><span class="comment"># .env</span></span><br></pre></td></tr></table></figure>

<h3 id="connect-to-mastodon"><a href="#connect-to-mastodon" class="headerlink" title="connect to mastodon"></a>connect to mastodon</h3><p>与 mastodon 连接需要使用 node package (<a href="https://github.com/vanita5/mastodon-api">mastodon-api</a>)，安装命令：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save mastodon-api</span><br></pre></td></tr></table></figure>

<p>安装完成后目录下会多出一个目录 <code>node_modules</code> 和一个文件 <code>package-lock.json</code>。查看 <code>package.json</code> 会发现其中多出一段：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;mastodon-api&quot;</span>: <span class="string">&quot;^1.3.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要连接 mastodon 则需要编辑 <code>bot.js</code> 文件，在文件内写入：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mastodon = <span class="built_in">require</span>(<span class="string">&#x27;mastodon-api&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> M = <span class="keyword">new</span> Mastodon(&#123;</span><br><span class="line"><span class="attr">client_key</span>: process.env.CLIENT_KEY, <span class="comment">// read the .env file</span></span><br><span class="line"><span class="attr">client_secret</span>: process.env.CLIENT_SECRET,</span><br><span class="line"><span class="attr">access_token</span>: process.env.ACCESS_TOKEN,</span><br><span class="line"><span class="attr">timeout_ms</span>: <span class="number">60</span> * <span class="number">1000</span>,  <span class="comment">// optional HTTP request timeout to apply to all requests.</span></span><br><span class="line"><span class="attr">api_url</span>: process.env.API_URL, <span class="comment">// optional, defaults to https://mastodon.social/api/v1/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="log-file"><a href="#log-file" class="headerlink" title="log file"></a>log file</h3><p>每一次发送嘟文会在屏幕上打印一大串内容，包括嘟文发送情况、嘟文的链接等等，但并不需要每一次都打印详细信息，只需要将 debug 所需的信息输出到 log 文件即可。<br>在 <code>bot.js</code> 文件中写入：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// toot example</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.randon()*<span class="number">100</span>);</span><br><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">`The meaning of life is <span class="subst">$&#123;num&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// log</span></span><br><span class="line">M.post(<span class="string">&#x27;statuses&#x27;</span>, params, <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fs.writeFileSync(&#x27;data.json&#x27;, JSON.stringify(data, null, 2));</span></span><br><span class="line">        <span class="comment">// console.log(data);</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`ID: <span class="subst">$&#123;data.id&#125;</span> and timestamp: <span class="subst">$&#123;data.created_at&#125;</span>`</span>); <span class="comment">// get the id and time</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Posted: <span class="subst">$&#123;data.content&#125;</span>`</span>); <span class="comment">// get the content of toot</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码实际实现了一次完整的发送嘟文，因此可以封装为一个函数，即：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">// toot function: pick a random num, create a status, and toot it</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toot</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// toot example</span></span><br><span class="line">    <span class="keyword">const</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.randon()*<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="string">`The meaning of life is <span class="subst">$&#123;num&#125;</span>`</span></span><br><span class="line">        <span class="comment">// if want to use cw</span></span><br><span class="line">        <span class="comment">// spoiler_text: &quot; The meaning of life is&quot;,</span></span><br><span class="line">        <span class="comment">// status: num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// log</span></span><br><span class="line">    M.post(<span class="string">&#x27;statuses&#x27;</span>, params, <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fs.writeFileSync(&#x27;data.json&#x27;, JSON.stringify(data, null, 2));</span></span><br><span class="line">            <span class="comment">// console.log(data);</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`ID: <span class="subst">$&#123;data.id&#125;</span> and timestamp: <span class="subst">$&#123;data.created_at&#125;</span>`</span>); <span class="comment">// get the id and time</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Posted: <span class="subst">$&#123;data.content&#125;</span>`</span>); <span class="comment">// get the content of toot</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="streaming-api-user"><a href="#streaming-api-user" class="headerlink" title="streaming api: user"></a>streaming api: user</h3><p>目前 bot 已经实现自动发嘟，但如果想做一个可以自动回复、给特定人点星而不是随机骚扰用户，则需要监听 streaming api 中的用户部分，并根据所得信息进行相应回应。<br>在 <code>bot.js</code> 文件中写入：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listener = M.stream(<span class="string">&#x27;streaming/user&#x27;</span>)</span><br><span class="line"></span><br><span class="line">listener.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    fs.writeFileSync(<span class="string">`data<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&#125;</span>.json`</span>, <span class="built_in">JSON</span>.stringify(msg, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`usr event`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过 <code>node bot.js</code> 运行 bot，并利用其它账号 @bot 或关注等操作测试 bot 是否正确运行。这一步遇到问题：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Mastodon Bot starting...</span><br><span class="line">node:events:505</span><br><span class="line">    throw er; // Unhandled <span class="string">&#x27;error&#x27;</span> event</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">Error: aborted</span><br><span class="line">    at connResetException (node:internal/errors:692:14)</span><br><span class="line">    at TLSSocket.socketCloseListener (node:_http_client:414:19)</span><br><span class="line">    at TLSSocket.emit (node:events:539:35)</span><br><span class="line">    at node:net:709:12</span><br><span class="line">    at TCP.done (node:_tls_wrap:582:7)</span><br><span class="line">Emitted <span class="string">&#x27;error&#x27;</span> event on StreamingAPIConnection instance at:</span><br><span class="line">    at IncomingMessage.&lt;anonymous&gt; (/root/miniconda/dogchan/node_modules/mastodon-api/lib/streaming-api-connection.js:141:30)</span><br><span class="line">    at IncomingMessage.emit (node:events:539:35)</span><br><span class="line">    at emitErrorNT (node:internal/streams/destroy:157:8)</span><br><span class="line">    at emitErrorCloseNT (node:internal/streams/destroy:122:3)</span><br><span class="line">    at processTicksAndRejections (node:internal/process/task_queues:83:21) &#123;</span><br><span class="line">code: <span class="string">&#x27;ECONNRESET&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过一整天的搜索和试图 debug 决定放弃，转而使用 python 中的 <code>Mastodon.py</code>，即 CATsama 使用的包。  </p>
<h2 id="利用-Mastodon-py-实现自动回复-bot"><a href="#利用-Mastodon-py-实现自动回复-bot" class="headerlink" title="利用 Mastodon.py 实现自动回复 bot"></a>利用 Mastodon.py 实现自动回复 bot</h2><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p>Mastodon.py: <a href="https://mastodonpy.readthedocs.io/en/stable/index.html#">Docs</a> , <a href="https://github.com/halcy/Mastodon.py">GitHub</a><br>mastodon-bot-template: <a href="https://github.com/Lynnesbian/mastodon-bot-template/blob/9e72f6a490734f7af5897c40f20b4aecb0c2308b/reply.py">reply.py</a><br>mstdn-ebooks: <a href="https://github.com/Lynnesbian/mstdn-ebooks/blob/master/reply.py">reply.py</a></p>
<h3 id="注册账号-1"><a href="#注册账号-1" class="headerlink" title="注册账号"></a>注册账号</h3><p>选择一个合适的站点注册 bot 账号，并修改资料，注意选中 “这是一个 bot 账号 / This is a bot account”。<br>在管理面板找到开发/Development-创建新应用/New Application，创建新应用并给予读写权限，复制访问令牌。  </p>
<h3 id="安装-Mastodon-py"><a href="#安装-Mastodon-py" class="headerlink" title="安装 Mastodon.py"></a>安装 Mastodon.py</h3><p>安装 miniconda3：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir miniconda</span><br><span class="line"><span class="built_in">cd</span> miniconda</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 python 最新版本并用 bash 安装</span></span><br><span class="line">wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">sh Miniconda3-latest-Linux-x86_64.sh //用bash安装</span><br></pre></td></tr></table></figure>

<p>通过 <code>pip</code> 安装 Mastodon.py：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install requests beautifulsoup4 Mastodon.py <span class="comment"># 安装mastodon.py</span></span><br><span class="line">mkdir dogchan</span><br><span class="line"><span class="built_in">cd</span> dogchan</span><br><span class="line">nano mybot_usercred.secret <span class="comment"># 写入刚才复制的访问令牌，保存退出</span></span><br><span class="line">nano dogchan.py <span class="comment"># 发嘟脚本</span></span><br></pre></td></tr></table></figure>

<h3 id="编辑脚本"><a href="#编辑脚本" class="headerlink" title="编辑脚本"></a>编辑脚本</h3><p>整个过程基本上属于一边参考现有的利用 Mastodon.py 实现自动回复的库，一边自己悟每一步都是做什么的。<br>其中最实用的一个库是: <a href="https://github.com/Lynnesbian/mastodon-bot-template/">mastodon-bot-template</a>。这个库不仅包括了自动回复模板，也包括了自动发嘟模板。本项目中的 <code>extract_text</code> 函数、<code>process_mention</code> 函数和处理 notifications 都直接借用模板或稍加修改。模板作者要求使用该模板时引用原库，且使用同样的 license (AGPL-3.0 license)。  </p>
<h4 id="自动回复脚本"><a href="#自动回复脚本" class="headerlink" title="自动回复脚本"></a>自动回复脚本</h4><p>自动回复脚本需要完成接收到 notification、判定 notification 是 mention 、对 mention 嘟文内容进行处理、作出相应的回复。其中所需的函数较多，因此将大多数函数存在 <code>Woof.py</code> 中，大框架放在 <code>dogchan.py</code> 中。<br>代码基本参考前面提到的 <a href="https://github.com/Lynnesbian/mastodon-bot-template/blob/9e72f6a490734f7af5897c40f20b4aecb0c2308b/reply.py">mastodon-bot-template: reply.py</a>。其中代码的注释非常详细，此处不再重复。  </p>
<p>完成脚本后使用 <code>systemd</code> 设置定时任务，让服务器自动每 30 秒执行一次脚本。这里的自动执行不如前面尝试失败的方法 <code>利用 mastodon-api 实现自动回复 bot</code> 优雅，如果能够进一步提升将在此处指出。<br>在服务器上安装 systemd:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install systemd</span><br></pre></td></tr></table></figure>

<p>任务设置模板 (来自于 mastodon-bot-template)：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># an example for systemd</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Reply service for my bot</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=bots</span><br><span class="line">WorkingDirectory=/path/to/bot</span><br><span class="line">ExecStart=/usr/bin/python3 /path/to/bot/reply.py</span><br><span class="line">TimeoutSec=3600</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=30</span><br><span class="line">StartLimitBurst=3</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h4 id="自动发嘟脚本"><a href="#自动发嘟脚本" class="headerlink" title="自动发嘟脚本"></a>自动发嘟脚本</h4><p>自动发嘟脚本 <code>selfie.py</code> 主要用于实现每周三上午九点发一张汪汪照片。相关代码可参考 <a href="https://gist.github.com/RustingSword/772f0c5582bb55a50270c339e948fc76">一个简单的 mastodon bot</a> 或前面提到的 <a href="https://github.com/Lynnesbian/mastodon-bot-template/">mastodon-bot-template</a>。<br>若想要在嘟嘟中添加图片，则需要调用模板以外的函数，具体如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机选取指定目录中的一个文件，path2selfie.txt 中含有该目录下所有文件的绝对路径</span></span><br><span class="line">media_file = random.choice(<span class="built_in">open</span>(<span class="string">&quot;path2selfie.txt&quot;</span>).read().splitlines())</span><br><span class="line"><span class="comment"># 处理图片路径，使其成为可用于 mastodon.status_post 的参数</span></span><br><span class="line">selfie =  mastodon.media_post(media_file)</span><br><span class="line"><span class="comment"># 带上图片发嘟</span></span><br><span class="line">mastodon.status_post(</span><br><span class="line">        status = content,</span><br><span class="line">        media_ids = selfie,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>定时每周三上午九点发送一张带有照片的嘟嘟：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 9 * * 3  cd /root/miniconda/dogchan &amp;&amp; /root/miniconda3/envs/mastbot/bin/python selfie.py &gt;&gt; /root/miniconda/dogchan/log/selfie_log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h3 id="奇怪的报错"><a href="#奇怪的报错" class="headerlink" title="奇怪的报错"></a>奇怪的报错</h3><p>谷歌一圈，也在 Mastodon.py 提了 <a href="https://github.com/halcy/Mastodon.py/issues/243">issue</a>，还是没有解决。推测这个 bug 是我的站点设置造成的，但完全没有头绪究竟是哪里有问题，用 mstdn.social 的账号测试就没有问题。回看尝试 Node.js 放弃时的报错，很有可能也是同样的问题导致 API 报错，但已经懒得验证。  </p>
<h4 id="2022-08-08-更新"><a href="#2022-08-08-更新" class="headerlink" title="2022.08.08 更新"></a>2022.08.08 更新</h4><p>提的 <a href="https://github.com/halcy/Mastodon.py/issues/243">issue</a> 得到回复，确定是站点设置的问题。但作者不清楚是哪里出现问题，给出的建议是每当出现该报错就重建一次 streaming，但有可能丢失部分 notifications。<br>还有一个解决办法是每十分钟从上次读到的 notifications 并进行操作以实现自动回复。这种方法其实是 “伪自动回复”，因此需要设置定时任务，如每十分钟执行一次脚本。目前 DOGchan 使用这种方法实现自动回复。  </p>
<h2 id="将代码上传至-GitHub"><a href="#将代码上传至-GitHub" class="headerlink" title="将代码上传至 GitHub"></a>将代码上传至 GitHub</h2><p>之前的 CATsama 已经上传过一次，但这次上传还是完全不记得怎么搞，所以决定记录一下。  </p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>在 GitHub 创建新的仓库以存放代码。根据实际需要，为仓库添加 <code>README.md</code> 和 <code>license</code>。创建完成后，在仓库右上角点击绿色的 <code>Code</code>，复制相应链接。  </p>
<p><img src="/2022/07/20/dogchan/repository.png"></p>
<h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>可直接参考 <a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">生成新 SSH 密钥并添加到 ssh-agent</a>  </p>
<h3 id="Personal-access-tokens"><a href="#Personal-access-tokens" class="headerlink" title="Personal access tokens"></a>Personal access tokens</h3><p>在 GitHub 创建 token 以便于后续代码上传时身份验证。<code>点击个人头像 - Setting -  Developer settings - Personal access tokens - Generate new token</code>，根据实际情况选择 token 的执行权限，完成后复制 token。<br>将创建的 Personal access tokens 整合到前述步骤复制的仓库链接中备用，具体格式如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://Personal_access_tokens@github.com/your_username/repository_name.git</span><br></pre></td></tr></table></figure>

<h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>在服务器上存放代码的目录下执行如下操作：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GitHub 默认分支已经改为 main，但 git init 的默认分支还是 master，这一步用于将 git 的默认分支改为 main</span><br><span class="line">git config --global init.defaultBranch main</span><br><span class="line"></span><br><span class="line"># 初始化库</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"># 添加当前目录下所有文件，也可添加指定文件</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"># commit</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line"></span><br><span class="line"># 添加远程仓库并命名为 origin，粘贴前述步骤中整合后的仓库链接</span><br><span class="line">git remote add origin https://Personal_access_tokens@github.com/your_username/repository_name.git</span><br><span class="line"></span><br><span class="line"># 如果提示远程仓库已存在，则执行如下命令后再添加一次</span><br><span class="line"># git remote rm origin</span><br><span class="line"></span><br><span class="line"># 拉取远程仓库中的内容，否则 push 时也会因为未同步远程仓库内容而失败</span><br><span class="line"># 如果远程仓库为空，则不需要这一步</span><br><span class="line">git pull origin main --allow-unrelated-histories</span><br><span class="line"></span><br><span class="line"># 将 commit 推送到远程仓库</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<p>此时刷新 GitHub 库的页面，即可看到新上传的内容。<br>DOGchan 的 GitHub 库：<a href="https://github.com/melocery/DOGchan">DOGchan：一个能够关键字触发自动回复的长毛象机器人</a>  </p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>整个搭建过程非常漫长，先是觉得油管教程很详细不可能有任何问题，但随着一步步搭建发现问题不少，而且由于对 node.js 完全不熟悉，连报错都看不懂，只能粘贴到谷歌搜索，但也不能得到很好的解决。又问了很多在象上拥有自动回复 bot 的象友，想参考一下，但大家的方法也不能完全适用。最后还是在 GitHub 一个个项目看过去 (感谢愿意开源的人们)，找到了现在参考的这个方法。虽然也有不足，但是是目前确实能顺利运行一段时间的方法。接下来只需要思考为什么我的站点 streaming 不能长时间访问，修改好就能顺利运行。<br>总得来说，也算是一次很快乐的尝试。做这些小小的 project 比科研有趣多了！或许以后还会做这些有趣的小项目，快乐的同时还能丰富 GitHub 的库。  </p>
<p>一开始这个 bot 只是为了让缪尚猫狗双全，但做着做着就想起家里的狗狗。在真实世界它已经返回汪星，但它在我自己搭建的赛博世界玩耍。因此从发嘟的照片和头像都用了狗狗的照片，就让它在我的咖啡馆继续做一只快乐小狗吧！  </p>
]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Bot</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
        <tag>Python</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>在文章中插入图片的各种方式</title>
    <url>/2021/10/19/imginblog/</url>
    <content><![CDATA[<center>终于还是没能避免想要在文章中用到图片，所以有了本文记录在Hexo博客中插入图片的各种方式</center>  
<span id="more"></span>  

<br>

<h2 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>安装插件<code>hexo-asset-image</code></p>
<pre><code>npm install hexo-asset-image --save
</code></pre>
<p>安装成功后，打开<code>/node_modules/hexo-asset-image/index.js</code>，替换成下列内容：</p>
<pre><code>&#39;use strict&#39;;
var cheerio = require(&#39;cheerio&#39;);

// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string
function getPosition(str, m, i) &#123;
return str.split(m, i).join(m).length;
&#125;

var version = String(hexo.version).split(&#39;.&#39;);
hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;
var config = hexo.config;
if(config.post_asset_folder)&#123;
    var link = data.permalink;
if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)
    var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;
else
    var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;
// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.
var endPos = link.lastIndexOf(&#39;/&#39;) + 1;
    link = link.substring(beginPos, endPos);
var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];
for(var i = 0; i &lt; toprocess.length; i++)&#123;
var key = toprocess[i];

var $ = cheerio.load(data[key], &#123;
    ignoreWhitespace: false,
    xmlMode: false,
    lowerCaseTags: false,
    decodeEntities: false
&#125;);

$(&#39;img&#39;).each(function()&#123;
if ($(this).attr(&#39;src&#39;))&#123;
// For windows style path, we replace &#39;\&#39; to &#39;/&#39;.
var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);
if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;
    !/^\s*\//.test(src)) &#123;
    // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.
    // In addition, to support multi-level local directory.
    var linkArray = link.split(&#39;/&#39;).filter(function(elem)&#123;
    return elem != &#39;&#39;;
    &#125;);
    var srcArray = src.split(&#39;/&#39;).filter(function(elem)&#123;
    return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;
    &#125;);
    if(srcArray.length &gt; 1)
    srcArray.shift();
    src = srcArray.join(&#39;/&#39;);
    $(this).attr(&#39;src&#39;, config.root + link + src);
    console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);
&#125;
&#125;else&#123;
console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);
console.info&amp;&amp;console.info($(this));
    &#125;
&#125;);
data[key] = $.html();
    &#125;
&#125;
&#125;);
</code></pre>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>当整个博客图片内容较少时，可将所有的图片都放在<code>source/images</code>文件夹下，通过<code>markdown</code>语法访问。  </p>
<pre><code>![](/images/img1.png)
</code></pre>
<p>对于图片较少切命名清晰的情况，这种方式存放图片足够。</p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>除了将图片存放在<code>source/images</code>文件夹下，还可以将图片存放在文章自己的目录中。文章目录可通过修改配置文件生成：  </p>
<pre><code>post_asset_folder: true  
</code></pre>
<p>将配置文件中<code>post_asset_folder</code>修改为<code>true</code>后，执行命令</p>
<pre><code>hexo new post newblog
</code></pre>
<p>会在<code>source/_posts</code>生成<code>newblog.md</code>和同名文件夹<code>newblog</code>。将图片存在该同名文件夹中，即可通过相对路径的方式在文章中添加图片。</p>
<pre><code>![](img.png)
</code></pre>
<p>这一方法能够在文章中显示图片，但无法在首页正常显示图片，如需在首页显示图片可使用如下方式：</p>
<pre><code>&#123;% asset_img img.png This is an image %&#125;
</code></pre>
<p>当图片内容较多，使用相对路径存放图片的方式更易于整理。</p>
<h4 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h4><p>如遇到修改配置文件后运行<code>hexo new newblog</code>命令无法正常建立一个同名文件夹，可以手动在<code>_POST</code>目录下建立一个同名文件夹，仍能够达到同样的效果。<br>实际上，md文件也可以手动新建。根据使用者的习惯，怎么新建md文件和同名文件夹都是可以的。<br>平时写文章不常用到图片，也可以使用手动建立同名文件夹的方式。  </p>
<h2 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h2><p>将图片上传到一些CDN服务中并使用对应的url地址引用图片也是一个很好的方式。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo博客搭建之在文章中插入图片</a><br>[2] <a href="https://fuhailin.github.io/Hexo-images/">在Hexo博客中插入图片的各种方式</a><br>[3] <a href="https://www.cxyzjd.com/article/m0_43401436/107191688">hexo博客中插入图片失败——解决思路及个人最终解决办法</a><br>[4] <a href="http://sdman.tech/2019/07/23/%E8%A7%A3%E5%86%B3Hexo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/">解决 Hexo 框架博客图片不显示的问题</a></p>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s conda!</title>
    <url>/2025/04/22/miniconda/</url>
    <content><![CDATA[<center> 早就该搞定的 miniconda + vscode 直到开始写论文了才真的认认真真配置好 </center>
<span id="more"></span>

<h2 id="安装-miniconda"><a href="#安装-miniconda" class="headerlink" title="安装 miniconda"></a>安装 miniconda</h2><p>参照<a href="https://www.anaconda.com/docs/getting-started/miniconda/install">官网</a>下载适合版本的miniconda。<br>安装过程中有两个提醒比较在意，一个是 Register Miniconda3 as my default Python 3.12。选择这个选项意味着让 Miniconda 安装的 Python (默认是 3.12 版本) 成为系统中默认的 Python 版本，也就是其他程序 (比如 vscode、PyCharm) 默认会用这个。但我的电脑上已经有一个 <del>很成熟</del> 用了很久的 <code>python 3.10.10</code>，不想让这两个互相影响，导致一堆乱七八糟的冲突，最后没有选择打勾。<br>另一个是不推荐 Add Miniconda3 to PATH environment variable，有点反直觉。问了 ChatGPT 老师，说原因是：  </p>
<ul>
<li>Conda 的环境机制很依赖 <code>conda activate</code>，不希望你用系统 PATH 中的 python 跑错环境。  </li>
<li>把 miniconda 加入 PATH 会让你在终端中直接输 <code>python</code> 时，不确定到底是哪个 python (系统的、miniconda的、其他的？)。  </li>
<li>加了 PATH，容易发生冲突，特别是你以后还可能装 pyenv、虚拟环境、或者系统工具。  </li>
</ul>
<p>所以听从推荐，没有加入到 PATH。  </p>
<p>安装完成后，可通过开始菜单中的 Anaconda Prompt (miniconda) 或 Anaconda Powershell Prompt (miniconda) 中输入 <code>code</code> 启动 vscode。然后可以在 vscode terminal 中运行 conda 相关的命令，如 <code>conda --version</code> 来检查 conda 的安装是否正确。一旦用这种方式打开一次，之后 vscode 就能识别所有 Conda 环境，包括选择 Jupyter kernel 和解释器 (引用自 ChatGPT)。<br>可以将 conda 加入 vscode 的配置中，让它每次启动都可以识别 Conda 环境：  </p>
<ul>
<li>打开 vscode 的 Command Palette：<code>Ctrl+Shift+P</code></li>
<li>输入 Preferences: Open User Settings (JSON)，打开 settings.json 添加如下内容：  </li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;terminal.integrated.env.windows&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;PATH&quot;</span>: <span class="string">&quot;PATH_TO_MINICONDA;PATH_TO_MINICONDA\\Scripts;$&#123;env:PATH&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，也就是我的配置：  </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="string">&quot;terminal.integrated.env.windows&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;PATH&quot;</span>: <span class="string">&quot;D:\\miniconda;D:\\miniconda\\Scripts;$&#123;env:PATH&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这条配置是告诉 vscode：每次打开 Terminal 时，自动把 Conda 路径加进去。这样就可以直接打开 vscode，不需要再用 Anaconda Prompt。  </p>
<h2 id="使用-conda"><a href="#使用-conda" class="headerlink" title="使用 conda"></a>使用 conda</h2><p>配置终端环境，在第一次 activate 前需要先 init 一次。运行：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># initiate conda</span></span><br><span class="line">conda init</span><br></pre></td></tr></table></figure>

<p>遇到了一个报错 <code>无法加载文件 C:\Users\username\Documents\WindowsPowerShell\profile.ps1，因为在此系统上禁止运行脚本</code>。解决方法是以管理员身份打开 PowerShell，输入：  </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser</span><br></pre></td></tr></table></figure>

<p>这条命令的意思：允许本地脚本运行 (比如 Conda 的 profile.ps1)；依然保护你不会执行从网上随便下载的未签名脚本；只改你当前用户的设置，不影响系统其他人 (ChatGPT)。设置完成后重启 vscode，打开 terminal 查看是否还有同样的报错。如果一切正常，此时 Terminal 每行行首应该出现 <code>(base)</code>  </p>
<p>创建所需的 conda 环境并激活：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># conda 会根据 python=3.10 最新子版本，也可直接指定，如 python=3.10.10</span></span><br><span class="line">conda create -n myenv python=3.10</span><br><span class="line">conda activate myenv</span><br></pre></td></tr></table></figure>

<p>激活成功之后，行首的 <code>base</code> 会变为环境名 <code>myenv</code>。<br>安装 jupyter 和 ipykernel 到这个环境中：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install jupyter ipykernel</span><br></pre></td></tr></table></figure>

<p>把这个环境注册为 Jupyter Kernel：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --user --name=myenv --display-name <span class="string">&quot;Python (myenv)&quot;</span></span><br></pre></td></tr></table></figure>

<p>之后使用 <code>.ipynb</code> 时就可以在 vscode 的 <code>select kernel</code> 中找到这个 kernel。  </p>
<p>最后一点 ChatGPT 的叮嘱 ——<br>只有在下面这些情况才需要手动 <code>conda activate</code>：  </p>
<ul>
<li>在 VSCode 的 Terminal 里手动运行脚本 (例如 python script.py)  </li>
<li>用 pip, conda, jupyter 命令装东西  </li>
<li>Debug/测试一些非 notebook 的东西  </li>
</ul>
<p>所以大部分时候只是打开 VSCode 写 <code>.ipynb</code>，根本不用管 activate 不 activate，已经自动切好啦。  </p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>一个小问题，conda 安装 <code>igraph</code> 时需要指定是 python 版本，使用如下命令安装：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge python-igraph</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tools</category>
        <category>miniconda</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>长毛象使用指南</title>
    <url>/2021/09/21/mstdn/</url>
    <content><![CDATA[<center>不少朋友被我安利到长毛象(mastodon)玩耍，本着对他们负责的态度，写下这篇长毛象使用指南。</center>
<span id="more"></span>

<br>

<h2 id="什么是mastodon"><a href="#什么是mastodon" class="headerlink" title="什么是mastodon"></a>什么是mastodon</h2><p>Mastodon(长毛象)是一个开源、去中心化的社交平台。简单来说，这里没有屏蔽词，没有限流，没有铺天盖地的营销号，没有Doctor看了都想重启宇宙的混乱时间线，只是一个纯粹的社交平台。长毛象将内容、社交网络交还给用户，更加尊重用户而不是平台“霸权”。<br><strong>如果将联邦宇宙(Fediverse)看做一个宇宙，那么每一个长毛象站点(Mastodon Society)就像一颗颗星球。</strong> 也就是说，你可以选择任何一颗星球定居，哪怕只是居住着一个人，只要它与宇宙相通，那么你就可以联系到宇宙中任何一个人而不会孤单。(摘自pullopen对长毛象的介绍：<a href="https://pullopenbluebox.wordpress.com/2020/06/30/mastodon-introduction/">长毛象（Mastodon）：更尊重用户的社交平台</a> )</p>
<h2 id="如何在mastodon拥有一个账号"><a href="#如何在mastodon拥有一个账号" class="headerlink" title="如何在mastodon拥有一个账号"></a>如何在mastodon拥有一个账号</h2><h3 id="选择站点"><a href="#选择站点" class="headerlink" title="选择站点"></a>选择站点</h3><p>长毛象有各种各样的站点(或称实例)，如二次元相关站、LGBTQ站、艺术类站，或者按照语言划分的小语种站点等等。可以在官网列出的<a href="https://joinmastodon.org/communities">站点列表</a>里找到一个喜欢又适合的站点。<br>一开始使用建议在一些大型的国际站点注册，限制较少，每天都有很多世界各地的人在时间线上灌水，如</p>
<ul>
<li><a href="https://mastodon.social/">https://mastodon.social</a></li>
<li><a href="https://mastodon.online/">https://mastodon.online</a></li>
<li><a href="https://mstdn.social/">https://mstdn.social</a>  </li>
</ul>
<p>使用一段时间，对各项操作都熟悉之后，可进一步选择更适合自己的小站点注册并迁移账号，或者继续呆在国际站点也无妨。<br>也可以在中文站点，或者中文用户较多的站点注册。这样在查看local timeline(本地轴)时都是中文，方便遇到志同道合的朋友。但无论在哪个站点注册，都建议阅读过<strong>服务器规则</strong>和<strong>服务条款</strong>后再进行，这两项通常都放在注册页面。<br>熟悉长毛象后，发现没有一个站点完全符合自己的想法，也可以自建站加入长毛象宇宙。搭建长毛象站点有很多简单易上手的教程可供参考，即使是计算机小白也能拥有属于自己的站点。可参考的教程：</p>
<ul>
<li><a href="https://docs.joinmastodon.org/zh-cn/admin/prerequisites/">官方建站文档</a></li>
<li><a href="https://www.notion.so/Mastodon-042a05ee29a048df8b2c1afd49e4c49b">长毛象（Mastodon）社区搭建详解</a></li>
<li><a href="https://pullopen.github.io/%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/2020/07/19/How-to-build-a-mastodon-instance.html">技术小白如何搭建Mastodon实例</a></li>
<li><a href="https://morikka.me/blog/mastodon-personal-instance/">长毛象个人向建站</a></li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>只要在一个站点注册，就可以连上整个长毛象宇宙，看到所有在用户和他们公开可见的嘟文，所以只需选择一个合适的站点注册账号即可。但由于站点服务器大多在中国境外，有被墙掉的风险，很多人会选择在多个站点注册账号，避免一个站点被GFW盯上ban掉就难以连上长毛象宇宙。<br>邮箱是各站点注册的必须品，注册成功后也可以更改。建议使用gmail、protonmail等邮箱服务，避免使用qq邮箱一类能直接指向使用者的邮箱。一些站点还需要填写入站申请或入站理由等以便站长和管理员审核注册人，通过审核之后便可成功注册，在长毛象宇宙自由玩耍。</p>
<h2 id="如何使用mastodon"><a href="#如何使用mastodon" class="headerlink" title="如何使用mastodon"></a>如何使用mastodon</h2><h3 id="Timeline-时间轴"><a href="#Timeline-时间轴" class="headerlink" title="Timeline(时间轴)"></a>Timeline(时间轴)</h3><p>Timeline简称为TL，完全按照时间来排列嘟文，不必担心出现时间线混乱、只给你看热度高的嘟文或塞给你不想看的广告、推广。<br>一般情况下，时间线有三种：</p>
<ul>
<li><strong>Home</strong> timeline，简称HTL，即首页。这是账号持有人自行关注而产生的时间线，能看到public、unlist、followers-only的嘟文(包括回复)以及提到你的direct message。</li>
<li><strong>Local</strong> timeline，简称LTL，即本站(地)轴。这是账号所在站点的时间线，只有该站点的公开嘟文会出现在这里。</li>
<li><strong>Federate</strong> timeline，简称FTL，即跨站轴。这是无论站点、所有账号嘟出的public内容共同组成的时间轴，能够看到世界各地的人都在这里发出自己的嘟嘟。</li>
</ul>
<p>通过设置<code>preferences (首选项) -&gt; other (其它) -&gt; PUBLIC TIMELINES-Filter languages (公共时间轴-语言过滤)</code>，可过滤时间线上的语言，只留下自己想看的语言。但这个过滤并不完全，公共轴或本站轴仍会出现一些应该被过滤掉的语言。 </p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul>
<li><p>发嘟  </p>
<ul>
<li>可见范围<br>发嘟可选择四种可见范围：public (公开)，unlist (公开，但不出现在公共时间轴)，followers-only (仅关注者可见)，direct message (私信，也可用作发仅自己可见的嘟文)。在设置中可以选择默认发嘟可见范围。</li>
<li>cw折叠功能<br>一些不想被直接看到或者含有可能令人不适内容的嘟文推荐使用cw。点击发嘟窗口下方的cw就会出现一个新的小窗口，在这个新的小窗口填上内容提示信息，在发嘟主要窗口填写主要内容。<del>这个功能也很好地被用来讲冷笑话</del>  </li>
<li>标记敏感内容<br>如果发的嘟文/图片含有not safe for work(NSFW，包括色情、暴力、血腥等)的内容，需要在发嘟时将图片标记为敏感信息，且善用cw折叠功能。</li>
</ul>
</li>
<li><p>回复<br>左下角箭头是回复功能，回复也可以设置不同的可见范围。在此处如果设置followers-only，被回复者即使没有关注你，也可以看到。回复的嘟嘟仅会出现在同时关注对话双方的账号首页时间线(Home Timeline)。这样尽最大可能避免参与对话者以外的人的打扰，使对话双方处于平等地位，不会出现因一方粉丝过多看到回复一拥而上的现象。各个时间轴设置(一般在主区域右上角)中可设置该时间轴不显示回复类嘟文。</p>
</li>
<li><p>转发<br>长毛象的转发是仅转发，不能带文字。这样很好的避免了类似微博上转发挂人形成骂战的现象。在账号设置中选择<code>在时间轴中合并转嘟</code>，以避免一篇嘟文被太多人转发刷屏时间轴的情况。各个时间轴设置(一般在主区域右上角)中可设置该时间轴不显示转发类嘟文，公共轴一般默认不显示转发。</p>
</li>
<li><p>喜欢<br>这里的⭐是favourite的意思，类似点赞功能。点赞代表赞同、安慰还是这里有个言论我mark一下就看使用者自己的想法，但通常来说都是<strong>赞</strong>！  </p>
</li>
<li><p>书签<br>bookmark是书签，或者称为收藏功能，这个功能与大多数平台相似，不再赘述。</p>
</li>
</ul>
<h3 id="头像、昵称、profile、标签"><a href="#头像、昵称、profile、标签" class="headerlink" title="头像、昵称、profile、标签"></a>头像、昵称、profile、标签</h3><p>一些站点固定期限内没有头像、昵称和嘟文的“三无账号”会被清除收回，注意阅读站点规则避免注册之后账号被回收。既然已经决定抛弃微博等在用户时间线上搞动作的平台，就不要只是注册个账号放着，用起来！</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ul>
<li><p>锁嘟<br>锁定账号(选项在个人资料页面)，需要手动审核所有关注请求。即每个想要关注你账号的人需要先发送关注请求，你通过之后方可关注你的账号以及看到你的followers-only的嘟文。与instgram的锁账号不同，即使挂上小锁其他人仍能看到公开可见的嘟文。如果有较多敏感嘟文不想随意被人看到，可定期删除或选择followers-only、direct message这两种可见范围。</p>
</li>
<li><p>语言<br>通过<code>Preferences (首选项) -&gt; Appearance (外观) -&gt; Interface language (界面语言)</code>设置平台语言。由于各语种都是志愿者翻译，可能会出现错误或词不达意，但基本不影响使用。</p>
</li>
<li><p>过滤器<br>这里的过滤器是真的过滤掉包含关键字的嘟文，但可能会在原本应该是一条嘟文的地方出现<code>filtered</code>的提醒。过滤器可以设置失效时间、作用场景等。</p>
</li>
<li><p>邮件通知<br><code>Preferences (首选项) -&gt; Notifications (通知)</code>里的邮件提醒建议关掉，避免发送过多邮件给站长的邮件服务造成不必要的负担。</p>
</li>
<li><p>其它<br>界面语言设置为惯用语言后，其它设置可自行探索。</p>
</li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>Mastodon故意弱化了搜索功能，避免形成“广场”，从而导致有人随便搜索一个关键词便前来抬杠或骂人的行为。但这也在一定程度上造成使用者的不便，比如明明有印象一条嘟嘟，但根本找不到，所以需要使用者自己多注意收藏有用的信息。有些站点开了全文搜索，会让搜索结果好一些，如自己的嘟文或转发、点赞过的嘟文能够搜索，但无法实现真正的“搜索”。 </p>
<h3 id="block-mute"><a href="#block-mute" class="headerlink" title="block / mute"></a>block / mute</h3><p>block即拉黑/屏蔽。拉黑后，该账号无法与你互动、关注，嘟文不会出现在你的时间线。<br>mute即隐藏。隐藏后，该账号的嘟文不会出现在你的时间线，但仍可与你互动、关注，而你不会收到任何提醒。</p>
<h3 id="迁移账号"><a href="#迁移账号" class="headerlink" title="迁移账号"></a>迁移账号</h3><p>长毛象的一大优点就是站点多，且类型丰富。如果看上了别的站点，可以在新站点注册账号后将账号迁移过去。迁移账号可以自动将followers/following转移到新账号，但无法迁移旧帐号的嘟文。</p>
<h3 id="账号备份"><a href="#账号备份" class="headerlink" title="账号备份"></a>账号备份</h3><p>长毛象自带的备份功能可以备份follower列表、following列表、mute列表、block列表等。如果想要备份嘟文，可以使用象友提供的<a href="https://github.com/slashyn/mastodon-archive-viewer-modified">备份插件</a>。<br>由于各个站点的维护仅依赖站长和可能有的站点管理员，所以可能会有不稳定、服务器出问题等状况出现，有时整个站点也会关闭不再运行，及时备份账号内容是个好习惯。</p>
<h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>长毛象作为一个去中心化的平台，最佳访问方式是直接浏览器访问，如Chrome、Firefox、safari等。这些浏览器可以在手机主屏幕创建快捷方式，在手机桌面单独形成一个图标和有一个app没有太大差别。<br>如果仍需要一个app，可选择的有：</p>
<ul>
<li><p><strong>Android</strong>: Tusky, Subway Tooter, Fedilab(付费)</p>
</li>
<li><p><strong>iOS</strong>: Metatext, Mercury, iMast, Amaroq, Mast(付费), Toot!(付费)  </p>
</li>
<li><p><strong>tooot</strong>：对于中文用户，推荐使用tooot。这是一个专注于中文社区的简洁、开源长毛象手机客户端，跨平台支持iOS和Android。 </p>
</li>
<li><p><strong>其它</strong>：其它平台应用推荐可查看<a href="https://joinmastodon.org/apps">官网应用推荐</a>。  </p>
</li>
</ul>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>作为一个公共社交网络，这里也可以带话题(tag)发嘟。格式和Instagram一样，只需要一个<code>#</code>，如<code>#tag</code>。<br>长毛象已经有很多有趣或有用的tag，如<code>#长毛象中文使用指南</code>、<code>#长毛象安利交换大会</code>、<code>#资源分享</code>、<code>#菜谱</code>，还有季节性的赏花、赏月tag。也可以创建自己的专属tag，把某类嘟文存在这个tag下，方便自己查看。</p>
<h3 id="一些好玩的账号"><a href="#一些好玩的账号" class="headerlink" title="一些好玩的账号"></a>一些好玩的账号</h3><ul>
<li><p>骰寶機<br>吃喝玩乐都可以找它！想不到晚饭吃什么，发嘟@骰宝问吃什么，不出一分钟就会回复一种食物。问它喝什么同理。还有好玩又有趣的答案之书和对不对判断。具体玩法可查看骰宝账号主页了解。</p>
</li>
<li><p>妙仙包<br>想知道心中之事的结果？找大师求签、塔罗牌都能给你一个奇妙的答案。选择困难症？找包包真普选，轻松治愈选择困难。心中有愿还可对着大师许愿，有机会被大师选中实现。具体玩法查看妙仙包账号主页了解。</p>
</li>
<li><p>sci咖啡屋<br>这里可以点单饮品、套餐，但一定要吃完不可浪费。累了还可以在这里撸猫，猫猫送上缓解疲惫。具体玩法查看sci咖啡屋账号主页了解。</p>
</li>
<li><p>Mature[マツレ]<br>Mature是长毛象上最早的科学期刊之一，也是长毛象最权威及最有名望的学术期刊之一。每周最重要、最前沿的研究结果是在「Mature」中以论文导读的形式发表的。欢迎订阅，支持投稿。投稿方法详见Mature账号主页。</p>
</li>
</ul>
<p>以上有趣账号可通过搜索名称获得，在此不提供具体账号以免给站点造成麻烦。</p>
<h2 id="More-than-Mastodon"><a href="#More-than-Mastodon" class="headerlink" title="More than Mastodon"></a>More than Mastodon</h2><p>其实mastodon只是这个宇宙中的一部分，还有Misskey、pleroma、funkwhale、peertube等和mastodon类似的社交平台共同组成整个联邦宇宙。<br>何必拘泥于处处受限的一隅，这里有更广阔的宇宙等你。<br>Enjoy yourself！</p>
]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Use</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
        <tag>UserGuide</tag>
      </tags>
  </entry>
  <entry>
    <title>Computational Deconvolution for More Precise Biological Data</title>
    <url>/2021/12/08/deconmixeddata/</url>
    <content><![CDATA[<center> 文献阅读：解卷积可从混合的生物学数据中解得各细胞类型比例，或估计各细胞类型的表达谱，为研究提供更准确的样本数据 </center>
<span id="more"></span>

<br>

<h2 id="Deconvolution"><a href="#Deconvolution" class="headerlink" title="Deconvolution"></a>Deconvolution</h2><p><strong>Deconvolution</strong> 译作反卷积或解卷积。解卷积是一种基于算法的过程，用于反转卷积对记录数据的影响。<br>生物学数据，如 DNA expression、RNA sequencing、Protein expression 等，很难真正得到来自特定组织的“纯数据”。如血液中含有来自不同组织的细胞、外泌体等，由此得来的生物学数据将是不同类型细胞的混合数据。这时就需要通过解卷积，从混合的生物数据中解得不同类型细胞的比例、表达谱。  </p>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><p>测得的数据为不同类型细胞按照一定比例混合在一起的结果。  </p>
<ul>
<li>测得的表达矩阵为 <em>X</em>，则 x<sub>ij</sub> 表示 gene<sub>i</sub> 在 sample<sub>j</sub> 中的表达量或表达强度  </li>
<li>比例矩阵为 <em>R</em>，则 r<sub>kj</sub> 表示 k 类细胞在 sample<sub>j</sub> 中所占比例  </li>
<li>各细胞真实表达谱组成的矩阵为 <em>S</em>，则 s<sub>ik</sub> 表示表示 gene<sub>i</sub> 在 k 类细胞中的表达量或表达强度  </li>
</ul>
<p><img src="/2021/12/08/deconmixeddata/decon.png">  </p>
<h2 id="解卷积算法"><a href="#解卷积算法" class="headerlink" title="解卷积算法"></a>解卷积算法</h2><p>针对不同情况有不同的算法，根据项目中的先验知识选择合适的解卷积方法以达到最佳效果。<br>生物数据解卷积分为完全解卷积和不完全解卷积。  </p>
<ul>
<li><strong>完全解卷积</strong>：指混合细胞类型数目、比例和各细胞表达谱未知，仅依赖混合表达数据将它们解出来，即已知混合表达矩阵 <em>X</em>，解比例矩阵 <em>R</em> 和各细胞表达矩阵 <em>S</em>。完全解卷积的完全指细胞表达谱和比例都在算法中一次性解得。  </li>
<li><strong>不完全解卷积</strong>：指已知混合表达谱、细胞类型数目、比例，解各细胞表达谱，即已知比例矩阵 <em>R</em> 和混合表达矩阵 <em>X</em>，解矩阵各细胞表达矩阵 <em>S</em>。不完全是相对于完全解卷积而言，仅解得各细胞表达谱。  </li>
</ul>
<h3 id="完全解卷积"><a href="#完全解卷积" class="headerlink" title="完全解卷积"></a>完全解卷积</h3><h4 id="LinSeed"><a href="#LinSeed" class="headerlink" title="LinSeed"></a><a href="https://doi.org/10.1038/s41467-019-09990-5">LinSeed</a></h4><p>通过计算共线性网络 (Collinearity Network) 得到各类型细胞的 markers，利用 markers 对混合数据进行完全解卷积，同时得到各组分的比例和表达谱。<br><img src="/2021/12/08/deconmixeddata/LinSeed.jpg"></p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/ctlab/linseed">https://github.com/ctlab/linseed</a>  </li>
</ul>
<h4 id="Deblender"><a href="#Deblender" class="headerlink" title="Deblender"></a><a href="https://doi.org/10.1186/s12859-018-2442-5">Deblender</a></h4><p>Deblender 是一个灵活的完全去卷积工具。基于用户对已知标记基因列表和细胞/组织组成信息的访问 (access)，以半/无监督模式运行。在没有先验知识的情况下，全局基因表达的变异性被用于混合数据的聚类，以聚类集代替标记集。<br><img src="/2021/12/08/deconmixeddata/Debledner.jpg">  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>MATLAB  </li>
<li><a href="https://github.com/kondim1983/Deblender/">https://github.com/kondim1983/Deblender/</a>  </li>
</ul>
<h4 id="CDSeq"><a href="#CDSeq" class="headerlink" title="CDSeq"></a><a href="https://doi.org/10.1371/journal.pcbi.1007510">CDSeq</a></h4><p>CDSeq 仅使用来自大量组织样本的 RNA-Seq 数据来同时估计细胞类型比例和细胞类型特异性表达谱。<br><img src="/2021/12/08/deconmixeddata/CDSeq1.jpg"><br><img src="/2021/12/08/deconmixeddata/CDSeq2.jpg">  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>MATLAB and Octave  </li>
<li><a href="https://github.com/kkang7/CDSeq">https://github.com/kkang7/CDSeq</a>  </li>
</ul>
<h4 id="Deconf"><a href="#Deconf" class="headerlink" title="Deconf"></a><a href="https://doi.org/10.1186/1471-2105-11-27">Deconf</a></h4><p>Deconf 证明了从单个样本的基因表达数据中预测构成细胞类型的比例的可行性，这是基于去粗取精的分类方法的前提条件。  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://static-content.springer.com/esm/art%3A10.1186%2F1471-2105-11-27/MediaObjects/12859_2009_3484_MOESM1_ESM.ZIP">example data and script</a>  </li>
</ul>
<h3 id="不完全解卷积"><a href="#不完全解卷积" class="headerlink" title="不完全解卷积"></a>不完全解卷积</h3><h4 id="Rodeo"><a href="#Rodeo" class="headerlink" title="Rodeo"></a><a href="https://doi.org/10.1093/nargab/lqaa110">Rodeo</a></h4><p>Rodeo 是一种基于稳健线性回归的方法，可以实现简单而稳健的表达式反卷积。  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/elolab/Rodeo">https://github.com/elolab/Rodeo</a></li>
</ul>
<h4 id="cs-lsfit-amp-cs-qprog"><a href="#cs-lsfit-amp-cs-qprog" class="headerlink" title="cs-lsfit &amp; cs-qprog"></a><a href="https://doi.org/10.1371/journal.pone.0006098">cs-lsfit &amp; cs-qprog</a></h4><p>cs-lsfit 和 cs-qprog 属于 CellMix 中的两个解卷积算法，使用CellMix时可选择使用哪一个来进行解卷积步骤。</p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/r-forge/cellmix/tree/master/pkg/CellMix">https://github.com/r-forge/cellmix/tree/master/pkg/CellMix</a></li>
</ul>
<h4 id="LRCDE"><a href="#LRCDE" class="headerlink" title="LRCDE"></a><a href="https://doi.org/10.1186/s12859-016-1226-z">LRCDE</a></h4><p>LRCDE 在逐个基因的基础上执行基于线性回归的细胞类型特异性差异表达(反卷积)检测。考虑到细胞类型特异性基因表达估计的变异性，它计算差异检测的每个基因 t 统计量、p 值、基于 t 统计量的灵敏度、组特异性均方误差和几个基因特异性诊断指标。  </p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/ERGlass/lrcde.dev">https://github.com/ERGlass/lrcde.dev</a></li>
</ul>
<h4 id="csSAM"><a href="#csSAM" class="headerlink" title="csSAM"></a><a href="https://doi.org/10.1038/nmeth.1439">csSAM</a></h4><p>csSAM 根据测量的细胞比例计算细胞特异性差异表达。<br><img src="/2021/12/08/deconmixeddata/csSAM.jpg"></p>
<p><strong>Code availability:</strong>   </p>
<ul>
<li>R  </li>
<li><a href="https://github.com/shenorrLab/csSAM">https://github.com/shenorrLab/csSAM</a>  </li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Maria K Jaakkola, Laura L Elo, Computational deconvolution to estimate cell type-specific gene expression from bulk data, NAR Genomics and Bioinformatics, Volume 3, Issue 1, March 2021, lqaa110, <a href="https://doi.org/10.1093/nargab/lqaa110">https://doi.org/10.1093/nargab/lqaa110</a><br>[2] 具体算法参考文献见算法介绍部分</p>
]]></content>
      <categories>
        <category>Paper</category>
        <category>DeconvoluteMixedBioData</category>
      </categories>
      <tags>
        <tag>Bioinformatics</tag>
        <tag>DeconvoluteMixedBioData</tag>
      </tags>
  </entry>
  <entry>
    <title>终于到了要掌握 branch 这一步</title>
    <url>/2025/05/18/gitbranch/</url>
    <content><![CDATA[<center> 基础的 git 已经完全掌握 (真的吗？)，现在来学习一下用 branch 管理代码吧！ </center>
<span id="more"></span>

<p>搭 Mastodon 就开始偷别人的 branch 用，现在终于到了想试试用 branch 管理代码的这天。<br>因为代码是我的 Thesis 相关分析，所以维护人只有我一个，并没有真的让 branch 发挥最大作用。但就这样吧，以后有多人协作的时候再水一篇。  </p>
<h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p>在库中的代码应该有如下简单结构：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repository/</span><br><span class="line">├── main         # 主分支，存储稳定、可复现的分析流程与结果</span><br><span class="line">│</span><br><span class="line">├── development  # 开发分支，用于功能的集成与测试，准备合并进 main</span><br><span class="line">│</span><br><span class="line">└── daily-dev    # 日常维护分支，进行日常更新、调试与实验性修改</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="main-分支"><a href="#main-分支" class="headerlink" title="main 分支"></a>main 分支</h4><p>代码的稳定版本<br>仅用于存储经过验证的、稳定的分析流程和结果。<br>所有面向他人共享或写论文前的代码版本，均以 main 为准。<br>合并到 main 前，代码应先通过 development 分支验证。  </p>
<h4 id="development-分支"><a href="#development-分支" class="headerlink" title="development 分支"></a>development 分支</h4><p>开发版本<br>用于集成 daily-dev 的更新或功能模块，做阶段性整合和测试。<br>可以多人协作，完成后合并进 main。<br>较 daily-dev 更稳定，但仍可能频繁更新。  </p>
<h4 id="daily-dev-分支"><a href="#daily-dev-分支" class="headerlink" title="daily-dev 分支"></a>daily-dev 分支</h4><p>日常维护<br>用于日常开发和维护，比如 bug 修复、分析修改、新图测试等。<br>自由度最高，适合个人工作。<br>重要变更建议定期合并进 development。  </p>
<h4 id="Tag（标签）的作用"><a href="#Tag（标签）的作用" class="headerlink" title="Tag（标签）的作用"></a>Tag（标签）的作用</h4><p>用于记录关键的版本节点，方便快速回溯。<br>常用于标记：  </p>
<ul>
<li>某次分析的正式版本（如 v0.2.1-analysis）</li>
<li>提交给导师或合作作者的版本</li>
<li>某个数据/包版本对应的代码快照</li>
</ul>
<h3 id="初始化和初次-push"><a href="#初始化和初次-push" class="headerlink" title="初始化和初次 push"></a>初始化和初次 <code>push</code></h3><p>在 GitHub 创建一个要存代码的空库，然后在本地执行如下操作：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin &lt;your-repo-url&gt;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p>这里的操作和基本使用一样。还可以进一步使用 <code>tag</code>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag stable-0.0.1</span><br><span class="line">git push origin stable-0.0.1</span><br></pre></td></tr></table></figure>

<p>标记这一份代码是一份能跑通的稳定代码。  </p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>创建新的开发分支：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b development</span><br></pre></td></tr></table></figure>

<p>这个新的分支会默认基于<strong>当前分支</strong>，如果需要基于某个分支，可以先切过去，比如基于 main 的话：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch                    <span class="comment"># 查看当前处于哪个分支</span></span><br><span class="line">git checkout main             <span class="comment"># 切换到 main</span></span><br><span class="line">git pull origin main          <span class="comment"># 更新为最新版本（很重要）</span></span><br><span class="line">git checkout -b development</span><br></pre></td></tr></table></figure>

<p>或直接指定分支：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b development main</span><br></pre></td></tr></table></figure>

<p>创建分支后推送到远程库：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin development</span><br></pre></td></tr></table></figure>

<p><code>-u</code> 表示将本地分支和远程分支绑定，之后只需用 <code>git push</code> 就可以自动推送到对应远程分支。</p>
<p>使用同样的办法来创建日常开发所用的分支，但记得检查想要基于哪个分支。日常开发一般基于 <code>development</code>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b daily-dev development</span><br></pre></td></tr></table></figure>

<p>日常操作都在 <code>daily-dev</code> 上进行，包括代码实验、小修改、调试。稳定后可通过如下方式合并到 <code>development</code>：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout development</span><br><span class="line">git merge daily-dev</span><br></pre></td></tr></table></figure>

<p>然后 <code>git push</code> 推送更新后的 development。  </p>
<h3 id="单人-vs-多人"><a href="#单人-vs-多人" class="headerlink" title="单人 vs 多人"></a>单人 vs 多人</h3><p>如果是单人开发，目前的步骤已经够用。日常用 <code>daily-dev</code>，某些部分稳定之后可以适时合并到 <code>development</code>，代码全部稳定之后就合并到 <code>main</code>。不需要频繁重建分支，只要保持分支更新同步。即：  </p>
<ul>
<li>日常开发全部在 daily-dev 分支进行  </li>
<li>某个功能或分析稳定之后，可以合并到 development 分支  </li>
<li>整体代码成熟、分析结果稳定时，再将 development 合并进 main，用于归档发布    </li>
<li><strong>注意</strong>：不需要频繁重建分支，只要注意分支间保持同步更新，避免长时间分支内容差异太大  </li>
</ul>
<p>如果是多人开发，日常维护的分支可能需要频繁基于最新的 <code>development</code> 重建，再以最新代码为基础做修改。具体如下：  </p>
<ul>
<li>所有人都从最新的 development 分支拉取一个自己的功能分支（例如 feature-x, fix-y, userA-dev 等），基于该分支进行开发  </li>
<li>每次开发前务必同步更新 development 分支，确保基于最新代码。如果已有分支落后较多，应基于最新的 development 重建分支  </li>
<li>开发完成后发起 Pull Request（PR）合并回 development，进行代码审查、测试等  </li>
<li>当多个功能合并并验证无误后，再由维护者将 development 合并到 main，形成一个稳定版本  </li>
<li><strong>注意</strong>：为每个功能或任务使用新的临时分支，完成后清理，以保持分支结构清晰可控。  </li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Mastodon 升级到特定版本</title>
    <url>/2023/07/08/mstdnupdate/</url>
    <content><![CDATA[<center> 这个互联网如果没有一点小事都会写个教程的网友，我将寸步难行 </center>
<span id="more"></span>

<br>  

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>蓝盒子站长：<a href="https://pullopen.github.io/%E8%BF%9B%E9%98%B6%E9%AD%94%E6%94%B9/2020/11/01/Mastodon-on-Docker-2.html">如何利用Docker搭建Mastodon实例（二）：进阶魔改篇 - 升级（2023-07-08修改）</a>  </p>
<h2 id="升级到-v3-5-10"><a href="#升级到-v3-5-10" class="headerlink" title="升级到 v3.5.10"></a>升级到 v3.5.10</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>打开 GitHub Desktop，在 mastodon repository 右键，Open in Command Prompt。<br>在打开的命令行窗口中输入命令查看远程仓库连接情况：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>远程仓库应包含自己的仓库 (origin) 和官方仓库 (upstream)，如下图：  </p>
<p><img src="/2023/07/08/mstdnupdate/gitremote.png"></p>
<p>如果没有官方仓库，可通过命令添加：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add upstream https://github.com/mastodon/mastodon.git</span><br></pre></td></tr></table></figure>

<p>然后拉取合并官方仓库中的更新：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch --tags upstream</span><br><span class="line">git merge v3.5.10   <span class="comment">#要升级的tag名</span></span><br></pre></td></tr></table></figure>

<p>GitHub Desktop 会在出现冲突时提醒冲突文件，并提示依次到 VS code 中修改。修改时注意查看冲突的具体内容，不要无脑接受。这次升级中遇到的冲突主要是因为本站有官方版本中没有的 local-only，根据提示保留更新的代码和原本属于 local-only 的部分。  </p>
<p>在自己的仓库中为 v3.5.10 创建新的 tag：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -f v3.5.10   <span class="comment">#将相应tag标注在你最新提交的修改上</span></span><br><span class="line">git push origin v3.5.10    <span class="comment">#将这个tag推送到远程github库中</span></span><br></pre></td></tr></table></figure>

<p>这之后，点开在 github 上的库，可以看到相应的 tag，在 Action 栏目中可以看到正在对该 tag 进行编译。  </p>
<p>将本地的更改推送到远程仓库后，到服务器执行如下操作：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/mastodon/mastodon</span><br><span class="line">docker pull melocery/mastodon:v3.5.10</span><br></pre></td></tr></table></figure>

<p>修改文件 <code>docker-compose.yml</code> 中 web、streaming 和 sidekiq 的 image 部分，与镜像 tag 保持一致。之后重启镜像：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p>合并 v3.5.10 后，在 <code>.github/workflows</code> 路径下多出一个和 docker image 相关的文件 <code>build-image.yml</code>，会在 Actions 中编译相关的镜像。但耗时很长，截至目前已经近两小时但还没编译完成，无法得知编译完成后在 Docker Hub 是什么样子、用什么 tag。<br>之前一直使用另一个文件 <code>docker-image.yml</code> 来编译 docker image，且在前面处理冲突时保留了这个文件，所以 Actions 中也会根据这个文件编译镜像并推送到 Docker Hub，在服务器端也是用的这个文件编译的镜像来建站。<br>反正都能用，不是什么大问题。等什么时候想起来看看第一个的编译结果再来更新第一个到底编译了个什么东西。  </p>
<p>update：没看出来编译了个啥，Docker Hub 里还是只有我用 <code>docker-image.yml</code> 编译出来的镜像。  </p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>docker 日志可放心删除，避免占用过多服务器资源：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;truncate -s 0 /var/lib/docker/containers/*/*-json.log&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Build</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
      </tags>
  </entry>
  <entry>
    <title>Mastodon 装修笔记：建站后还可以做什么</title>
    <url>/2022/08/16/mstdndecoration/</url>
    <content><![CDATA[<center> 简单记录一下建站后都对站点进行了哪些改动，文中每一步都已有大佬写过教程，本文仅作记录 </center>
<span id="more"></span>

<br>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文主要参考的教程：<br>[1] <a href="https://pullopen.github.io/%E7%AB%99%E7%82%B9%E7%BB%B4%E6%8A%A4/2020/11/26/mastodon-manage.html">如何装饰你的站点：自定义CSS、中继站和自定义表情</a><br>[2] <a href="https://pullopen.github.io/%E8%BF%9B%E9%98%B6%E9%AD%94%E6%94%B9/2020/11/14/mastodon-modify.html">进阶魔改：修改字数上限、媒体上限、投票上限、添加自定义主题、界面用语、非登陆用户有限显示、优化中文搜索，附阻止本站嘟文流入某站点方法</a>  </p>
<h2 id="装修升级命令"><a href="#装修升级命令" class="headerlink" title="装修升级命令"></a>装修升级命令</h2><p>如果使用 DockerHub 建立镜像辅助搭建、修改实例，则每次装修可电脑上修改完成后，push 到 GitHub，GitHub 自动编译完成且推送到 DockerHub后，在服务器端直接使用命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/mastodon/mastodon</span><br><span class="line">docker pull melocery/mastodon:latest</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>教程：<a href="https://pullopen.github.io/%E8%BF%9B%E9%98%B6%E9%AD%94%E6%94%B9/2020/11/01/Mastodon-on-Docker-2.html">如何利用Docker搭建Mastodon实例（二）：进阶魔改篇</a>  </p>
<h2 id="利用脚本缩写-tootctl-命令"><a href="#利用脚本缩写-tootctl-命令" class="headerlink" title="利用脚本缩写 tootctl 命令"></a>利用脚本缩写 tootctl 命令</h2><p>根据官方文档：<a href="https://docs.joinmastodon.org/zh-cn/admin/tootctl/">使用管理命令行</a>，每次需要运行的命令行很长，使用脚本可以将命令缩写。<br>打开 mastodon 的目录，并写入脚本：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/mastodon/mastodon</span><br><span class="line">nano tootctl.sh</span><br></pre></td></tr></table></figure>

<p>脚本内容为：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">lpwd=<span class="variable">$PWD</span></span><br><span class="line">mypath=`dirname <span class="variable">$0</span>`</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$mypath</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ge 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span> </span><br><span class="line">		<span class="string">&quot;restart&quot;</span>)</span><br><span class="line">			docker-compose restart</span><br><span class="line">		;;</span><br><span class="line">		<span class="string">&quot;reload&quot;</span>)</span><br><span class="line">			docker-compose down &amp;&amp; docker-compose up -d</span><br><span class="line">		;;</span><br><span class="line">		<span class="string">&quot;stop&quot;</span>)</span><br><span class="line">			docker-compose down</span><br><span class="line">		;;</span><br><span class="line">		<span class="string">&quot;start&quot;</span>)</span><br><span class="line">			docker-compose up -d</span><br><span class="line">		;;</span><br><span class="line">		<span class="string">&quot;psql&quot;</span>)</span><br><span class="line">			docker-compose <span class="built_in">exec</span> db $*</span><br><span class="line">		;;</span><br><span class="line">		*)</span><br><span class="line">			docker-compose run --rm web bin/tootctl $*</span><br><span class="line">		;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;please use tootctl help for help&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$lpwd</span></span><br></pre></td></tr></table></figure>

<p>保存并退出后，执行命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /home/mastodon/mastodon/tootctl.sh</span><br><span class="line">echo &quot;alias tootctl=&#x27;home/mastodon/mastodon/tootctl.sh&#x27; &quot; &gt;&gt; ~/.bashrc </span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>之后使用管理命令就可以直接使用 <code>tootctl</code>。  </p>
<h2 id="待处理的数据库迁移"><a href="#待处理的数据库迁移" class="headerlink" title="待处理的数据库迁移"></a>待处理的数据库迁移</h2><p>这个一般出现在经历较大的站点升级或较多魔改之后 (我的站点初始搭建之后就出现了这行提醒)，在管理员账号的管理面板会出现的一个提醒：有待处理的数据库迁移。请运行它们以确保应用程序正常运行。<br>找了很多 docker 搭建教程都没有提到这一步，由于对 docker 不熟悉，也不知道从何改起，直到看到<a href="https://blog.tantalum.life/posts/notes-on-modifying-mastodon-in-docker/#%E5%90%8E%E7%BB%AD%E5%B7%A5%E4%BD%9C">Mastodon | 记录大型魔改过程</a>。此时需要数据库迁移：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose run --rm web rails db:migrate</span><br></pre></td></tr></table></figure>

<p>另外，还需要运行命令 <code>tootctl cache clear</code> 以避免出现与站外通信延迟较高的问题。成功执行后，运行命令重启服务器，否则数据库迁移不生效。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose down</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="自定义-CSS"><a href="#自定义-CSS" class="headerlink" title="自定义 CSS"></a>自定义 CSS</h2><p>参考来自：<a href="https://pullopen.github.io/%E7%AB%99%E7%82%B9%E7%BB%B4%E6%8A%A4/2020/11/26/mastodon-manage.html">如何装饰你的站点：自定义CSS、中继站和自定义表情</a><br>所有更改在 <code>管理—网站设置-自定义css</code> 进行。  </p>
<h3 id="表情包鼠标悬停放大"><a href="#表情包鼠标悬停放大" class="headerlink" title="表情包鼠标悬停放大"></a>表情包鼠标悬停放大</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* START mastodon emoji scaling by @eh5@eh5.me */</span></span><br><span class="line"><span class="selector-class">.account__header__content</span>,</span><br><span class="line"><span class="selector-class">.reply-indicator__content</span>,</span><br><span class="line"><span class="selector-class">.status__content</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.status__content--collapsed</span>) &#123;</span><br><span class="line"><span class="attribute">overflow</span>: unset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account__header__content</span> <span class="selector-class">.emojione</span>,</span><br><span class="line"><span class="selector-class">.reply-indicator__content</span> <span class="selector-class">.emojione</span>,</span><br><span class="line"><span class="selector-class">.status__content</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.status__content--collapsed</span>) <span class="selector-class">.emojione</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line"><span class="attribute">transform-origin</span>: center;</span><br><span class="line"><span class="comment">/* Animation duration */</span></span><br><span class="line"><span class="attribute">transition</span>: <span class="number">200ms</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account__header__content</span> <span class="selector-class">.emojione</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.reply-indicator__content</span> <span class="selector-class">.emojione</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.status__content</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.status__content--collapsed</span>) <span class="selector-class">.emojione</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">z-index</span>: <span class="number">11</span>;</span><br><span class="line"><span class="comment">/* Scale up 2.3 times */</span></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2.3</span>);</span><br><span class="line"><span class="comment">/* shadows around image edges */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">drop-shadow</span>(<span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">#282c37</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.directory__card</span> <span class="selector-class">.account__header__content</span> <span class="selector-class">.emojione</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: unset;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* END mastodon emoji scaling by @eh5@eh5.me */</span></span><br></pre></td></tr></table></figure>

<h3 id="长图补丁"><a href="#长图补丁" class="headerlink" title="长图补丁"></a>长图补丁</h3><p>使具体图片铺满整个页面：  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.image-loader</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.zoomable-image</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">98%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.zoomable-image</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">	<span class="attribute">max-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">max-width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tag高亮显示（蓝色）"><a href="#Tag高亮显示（蓝色）" class="headerlink" title="Tag高亮显示（蓝色）"></a>Tag高亮显示（蓝色）</h3><p>颜色可以通过修改background-color和border-color修改。  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*hashtag style blue by slashine 071320*/</span></span><br><span class="line"><span class="selector-class">.mention</span><span class="selector-class">.hashtag</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#93AEFD</span>36;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">4px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line"><span class="attribute">text-decoration</span>: none;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">border-style</span>: dashed;</span><br><span class="line"><span class="attribute">border-color</span>: <span class="number">#93AEFD</span>;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">0.5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">2px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义表情"><a href="#自定义表情" class="headerlink" title="自定义表情"></a>自定义表情</h2><h3 id="网页端：管理员界面"><a href="#网页端：管理员界面" class="headerlink" title="网页端：管理员界面"></a>网页端：管理员界面</h3><p>管理员账号的 <code>首选项 - 管理 - 自定义表情 - 上传新表情</code>，可上传大小不超过 50kb 的 png 或 gif 格式的图作为表情包。<br>偷别站表情可通过 <code>首选项 - 管理 - 自定义表情 - 远程</code>，选择想要的表情包，复制后即可在本站看到并管理该表情。  </p>
<h3 id="服务器端：偷表情神器"><a href="#服务器端：偷表情神器" class="headerlink" title="服务器端：偷表情神器"></a>服务器端：偷表情神器</h3><p>使用 <a href="https://github.com/Starainrt/emojidownloader">emojidownloader</a> 直接从他站复制一个或多个分类下的表情。<br>在项目的 <a href="https://github.com/Starainrt/emojidownloader/releases">releases</a> 界面找到 <code>emoji_downloader_linux_x86_64</code>，右键复制链接。在服务器合适的目录下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Starainrt/emojidownloader/releases/download/v0.1.0/emoji_downloader_linux_x86_64 # 复制的链接，可能有变化</span><br><span class="line">chmod +x ./emoji_downloader_linux_x86_64</span><br><span class="line">./emoji_downloader_linux_x86_64</span><br></pre></td></tr></table></figure>

<p>运行 <code>./emoji_downloader_linux_x86_64</code>，根据提示一步步操作即可。此处具体步骤可参考：<a href="https://blog.tantalum.life/posts/notes-on-modifying-mastodon-in-docker/#%E4%BB%8E%E4%BB%96%E7%AB%99%E7%88%AC%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%83%85%E5%8C%85">Mastodon | 记录大型魔改过程 #从他站爬取自定义表情包</a>  </p>
<p>表情包下载至服务器后需要拷贝到容器中，并导入数据库：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 以 neodb 的星星表情为例</span><br><span class="line">docker cp /root/myEmojis/neodb.tar.gz mastodon_web_1:/tmp/neodb.tar.gz</span><br><span class="line">docker-compose exec web bin/tootctl emoji import --category=neodb /tmp/neodb.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="定期清理外站存储"><a href="#定期清理外站存储" class="headerlink" title="定期清理外站存储"></a>定期清理外站存储</h2><p>参考此方的教程：<a href="https://tech.konata.co/2022-02-20-mastodon-backup/">Mastodon 媒体存储和数据库备份</a>，直接启动容器执行tootctl命令。<br>通过 <code>crontab -e</code> 设置定时任务：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30 2 * * *  docker exec mastodon_web_1 tootctl media remove --days=14 &gt;&gt; /home/mastodon/log/mastodon/all.log 2&gt;&amp;1</span><br><span class="line">30 2 * * *  docker exec mastodon_web_1 tootctl media remove-orphans &gt;&gt; /home/mastodon/log/mastodon/all.log 2&gt;&amp;1</span><br><span class="line">30 2 * * *  docker exec mastodon_web_1 tootctl statuses remove --days=180 &gt;&gt; /home/mastodon/log/mastodon/all.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h2 id="修改实例字数上限"><a href="#修改实例字数上限" class="headerlink" title="修改实例字数上限"></a>修改实例字数上限</h2><p>参考 <a href="https://github.com/pullopen/mastodon/commit/2bf275ba3b81e4c28d817511407680b0b7abc7fe">commit</a> 在相应位置进行修改。修改后 precompile 和重启。<br><strong>蓝盒子站长提示：</strong>3.3.0 版本后，<code>app/javascript/mastodon/features/compose/components/compose_form.js</code> 修改会发生变化，请先接受官方文件，然后在该文件中将所有 500 改成你的字数上限，一共2处。  </p>
<h2 id="修改投票上限"><a href="#修改投票上限" class="headerlink" title="修改投票上限"></a>修改投票上限</h2><p>参考 <a href="https://github.com/pullopen/mastodon/commit/537c4fe6eb9a484546dda4776d765114fbb7c50a">Commit</a> 在相应位置进行修改。修改后 precompile 和重启。  </p>
<h2 id="添加自定义主题"><a href="#添加自定义主题" class="headerlink" title="添加自定义主题"></a>添加自定义主题</h2><p>直接从他站拷贝主题：  </p>
<ol>
<li>进入他站代码库的 <code>app/javascript</code> 文件夹，在 fonts、images 和 styles 文件夹内选择想要添加的主题，将相关文件复制入代码库。  <ul>
<li>蓝盒子站代码库：<a href="https://github.com/pullopen/mastodon/tree/master/app/javascript">pullopen</a>   </li>
<li>蓝盒子站长提示：Win95 主题还需要在 <code>config/webpacker.yml</code> 中加一行 <code>- .gif</code> 才可编译。</li>
</ul>
</li>
<li>修改 <code>config/themes.yml</code>  <ul>
<li>根据格式 <code>witches-town: styles/witches-town.scss</code> 将添加的主题都写入文件  </li>
</ul>
</li>
<li>(可选) 修改 <code>config/locales/en.yml</code> 和 <code>config/locale/zh-CN.yml</code> 的 <code>themes</code> 部分，给主题起英文名和中文名。注意这里需要按照原名的字母顺序排列。  </li>
<li>precompile 和重启。  </li>
</ol>
<p>自己写主题则将主题文件放在相应的位置，修改配置文件，precompile 和重启即可。  </p>
<h2 id="修改界面用语"><a href="#修改界面用语" class="headerlink" title="修改界面用语"></a>修改界面用语</h2><p>修改中文界面用语，可通过修改 <code>app/javascript/mastodon/locales/zh-CN.json</code> 实现。<br>如开启 “注册时需要批准” 功能，可在 “你为什么想要加入？” 下加入一段注册提示语。 在 <code>mastodon/config/locales/simple_form.zh-CN.yml</code> 找到 <code>invite_request</code> 项，修改 <code>text</code>。</p>
<h2 id="主页对非登陆用户只显示10条嘟文"><a href="#主页对非登陆用户只显示10条嘟文" class="headerlink" title="主页对非登陆用户只显示10条嘟文"></a>主页对非登陆用户只显示10条嘟文</h2><p>根据 <a href="https://github.com/orani-admin/mastodon/commit/e06d04b7acf42137efe5b8de9c4b83839537d723">Commit</a> 修改相应文件。  </p>
<h2 id="Docker-安装优化中文搜索"><a href="#Docker-安装优化中文搜索" class="headerlink" title="Docker 安装优化中文搜索"></a>Docker 安装优化中文搜索</h2><p>参考 <a href="https://pullopen.github.io/%E8%BF%9B%E9%98%B6%E9%AD%94%E6%94%B9/2020/11/14/mastodon-modify.html">进阶魔改：修改字数上限、媒体上限、投票上限、添加自定义主题、界面用语、非登陆用户有限显示、优化中文搜索，附阻止本站嘟文流入某站点方法</a> 的 “Docker 安装优化中文搜索（2022-04-25新增）” 部分。  </p>
<h2 id="阻止本站嘟文流入某站"><a href="#阻止本站嘟文流入某站" class="headerlink" title="阻止本站嘟文流入某站"></a>阻止本站嘟文流入某站</h2><p>在服务器修改 nginx 配置：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano /etc/nginx/sites-available/musain.cafe # 以本站为例，一般为实例名</span><br></pre></td></tr></table></figure>

<p>在  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl http2;</span><br><span class="line">  server_name musian.cafe;</span><br></pre></td></tr></table></figure>

<p>后添加  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($http_user_agent ~* &quot;对方域名不带前后缀&quot;) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>保存并退出。使用命令 <code>systemctl reload nginx</code> 重启 nginx。  </p>
<h2 id="屏蔽国内浏览器及搜索爬虫"><a href="#屏蔽国内浏览器及搜索爬虫" class="headerlink" title="屏蔽国内浏览器及搜索爬虫"></a>屏蔽国内浏览器及搜索爬虫</h2><p><strong>蓝盒子站长提示</strong>：此方法有一定机率误伤使用国内手机的用户，请务必全面通知后再使用！  </p>
<p>使用 Cloudflare 可在防火墙规则中添加：如果  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(http.host eq &quot;【站点地址】&quot; and not lower(http.user_agent) contains &quot;feedly&quot; and not lower(http.user_agent) contains &quot;pleroma&quot;) and ((lower(http.user_agent) contains &quot;2345&quot;) or (lower(http.user_agent) contains &quot;360&quot;) or (lower(http.user_agent) contains &quot;ali-&quot;) or (lower(http.user_agent) contains &quot;alipay&quot;) or (lower(http.user_agent) contains &quot;baidu&quot;) or (lower(http.user_agent) contains &quot;bingbot&quot;) or (lower(http.user_agent) contains &quot;bytespider&quot;) or (lower(http.user_agent) contains &quot;coolnovo&quot;) or (lower(http.user_agent) contains &quot;duckduckgo&quot;) or (lower(http.user_agent) contains &quot;easou&quot;) or (lower(http.user_agent) contains &quot;facebook&quot;) or (lower(http.user_agent) contains &quot;google&quot;) or (lower(http.user_agent) contains &quot;huaweibrowser&quot;) or (lower(http.user_agent) contains &quot;iaskspider&quot;) or (lower(http.user_agent) contains &quot;iqiyi&quot;) or (lower(http.user_agent) contains &quot;jike&quot;) or (lower(http.user_agent) contains &quot;lbbrowser&quot;) or (lower(http.user_agent) contains &quot;liebao&quot;) or (lower(http.user_agent) contains &quot;maxthon&quot;) or (lower(http.user_agent) contains &quot;meizu&quot;) or (lower(http.user_agent) contains &quot;metasr&quot;) or (lower(http.user_agent) contains &quot;micromessenger&quot;) or (lower(http.user_agent) contains &quot;miui&quot;) or (lower(http.user_agent) contains &quot;miuibrowser&quot;) or (lower(http.user_agent) contains &quot;msnbot&quot;) or (lower(http.user_agent) contains &quot;oneplus&quot;) or (lower(http.user_agent) contains &quot;oppo&quot;) or (lower(http.user_agent) contains &quot;qihoo&quot;) or (lower(http.user_agent) contains &quot;qiyu&quot;) or (lower(http.user_agent) contains &quot;qq&quot;) or (lower(http.user_agent) contains &quot;saayaa&quot;) or (lower(http.user_agent) contains &quot;se 1.x&quot;) or (lower(http.user_agent) contains &quot;se 2.x&quot;) or (lower(http.user_agent) contains &quot;sina&quot;) or (lower(http.user_agent) contains &quot;sogou&quot;) or (lower(http.user_agent) contains &quot;soso&quot;) or (lower(http.user_agent) contains &quot;taobao&quot;) or (lower(http.user_agent) contains &quot;taobrowser&quot;) or (lower(http.user_agent) contains &quot;tencent&quot;) or (lower(http.user_agent) contains &quot;teoma&quot;) or (lower(http.user_agent) contains &quot;the world&quot;) or (lower(http.user_agent) contains &quot;twitter&quot;) or (lower(http.user_agent) contains &quot;ucweb&quot;) or (lower(http.user_agent) contains &quot;vivo&quot;) or (lower(http.user_agent) contains &quot;wechat&quot;) or (lower(http.user_agent) contains &quot;weibo&quot;) or (lower(http.user_agent) contains &quot;xiaomi&quot;) or (lower(http.user_agent) contains &quot;yahoo&quot;) or (lower(http.user_agent) contains &quot;yandexbot&quot;) or (lower(http.user_agent) contains &quot;yisou&quot;) or (lower(http.user_agent) contains &quot;yodao&quot;) or (lower(http.user_agent) contains &quot;youdao&quot;) or (lower(http.user_agent) contains &quot;zte&quot;))</span><br></pre></td></tr></table></figure>

<p>则阻止。  </p>
<p>不使用 Cloudflare 可在 nginx 的配置文件的 server { } 括号中添加：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($http_user_agent ~* (2345|360|ali-|alipay|archive|baidu|bingbot|bytespider|coolnovo|duckduckgo|easou|facebook|google|huaweibrowser|iaskspider|iqiyi|jike|lbbrowser|liebao|maxthon|meizu|metasr|micromessenger|miui|miuibrowser|msnbot|oneplus|oppo|qihoo|qiyu|qq|saayaa|se\ 1.x|se\ 2.x|sina|sogou|soso|taobao|taobrowser|tencent|teoma|the\ world|twitter|ucweb|vivo|wechat|weibo|xiaomi|yahoo|yandexbot|yisou|yodao|youdao|zte)) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为站点添加-local-only"><a href="#为站点添加-local-only" class="headerlink" title="为站点添加 local-only"></a>为站点添加 local-only</h2><p>参考此方的教程：<a href="https://tech.konata.co/2022-03-16-local-only/?highlight=local">Mastodon | 以 local-only 代码合并为例浅谈如何合并特定 commit</a>，具体步骤不再赘述。  </p>
<h2 id="增加-sidekiq-线程"><a href="#增加-sidekiq-线程" class="headerlink" title="增加 sidekiq 线程"></a>增加 sidekiq 线程</h2><p>参考 <a href="https://note.southfox.me/#/page/mastodon%20%E5%A2%9E%E5%8A%A0%20sidekiq%20%E7%BA%BF%E7%A8%8B">mastodon 增加 sidekiq 线程</a> 修改相应内容。  </p>
<h2 id="修改昵称字数上限"><a href="#修改昵称字数上限" class="headerlink" title="修改昵称字数上限"></a>修改昵称字数上限</h2><p>参考 <a href="https://github.com/rararwg/mastodon/commit/f12b89fb3d3694223f5e55ae8907636c190b8de4">Commit</a> 修改相应内容。  </p>
]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Build</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
      </tags>
  </entry>
  <entry>
    <title>Satan：如何做一个嘟嘟中转站</title>
    <url>/2022/12/14/satan/</url>
    <content><![CDATA[<center> 缪尚咖啡馆快闪活动：撒旦老人关心您！帮您传递悄悄话并接收您的愿望！ </center>
<span id="more"></span>

<br>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>不好意思直说的心意，撒旦老人帮您转达。<br>无法自己言说的心愿，撒旦老人帮您一键广播。<br>撒旦老人为圣诞节、新年快闪活动，活动时间为 22.12.15 - 23.02.05。活动结束后将清空账号内容，请自行保存您发送或收到的内容。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>由于撒旦老人背后灵懒得写容错性健壮性强的代码，请大家联系撒旦老人时严格遵循以下格式：<br>如果您想讲悄悄话：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Satan # 向撒旦老人发送私信</span><br><span class="line">悄悄话 # 表达心意关键词</span><br><span class="line">向谁说： # 对方账号，包括实例部分但不需要第一个&#x27;@&#x27;符号</span><br><span class="line">内容： # 一行，即这一部分不要换行，写完再敲回车</span><br><span class="line">匿名：是或否，默认匿名</span><br><span class="line">可见度：[private, public, unlisted, direct] 四选一</span><br></pre></td></tr></table></figure>

<p>示例  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Satan</span><br><span class="line">悄悄话</span><br><span class="line">向谁说：Satan@musain.cafe</span><br><span class="line">内容：Do you hear the Santa sing?</span><br><span class="line">匿名：是</span><br><span class="line">可见度：direct</span><br></pre></td></tr></table></figure>

<p>如果您想许愿：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Satan # 向撒旦老人发送私信</span><br><span class="line">许愿 # 表达心愿关键词</span><br><span class="line">愿望：# 一行内，写完再敲回车</span><br><span class="line">匿名：是或否，默认匿名</span><br><span class="line">可见度：[private, public, unlisted] 三选一</span><br></pre></td></tr></table></figure>

<p>示例  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Satan</span><br><span class="line">许愿</span><br><span class="line">愿望：Beyond the barricade, there is a world we long to see.</span><br><span class="line">匿名：否</span><br><span class="line">可见度：unlisted</span><br></pre></td></tr></table></figure>

<h2 id="创造一个撒旦老人需要什么准备"><a href="#创造一个撒旦老人需要什么准备" class="headerlink" title="创造一个撒旦老人需要什么准备"></a>创造一个撒旦老人需要什么准备</h2><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>在缪尚新注册一个账号：@<a href="mailto:&#83;&#97;&#116;&#97;&#x6e;&#64;&#x6d;&#x75;&#115;&#97;&#105;&#x6e;&#x2e;&#99;&#97;&#102;&#101;">&#83;&#97;&#116;&#97;&#x6e;&#64;&#x6d;&#x75;&#115;&#97;&#105;&#x6e;&#x2e;&#99;&#97;&#102;&#101;</a>，修改基本资料，注意选中 “这是一个 bot 账号 / This is a bot account”。<br>在管理面板找到 <code>开发/Development-创建新应用/New Application</code>，创建新应用并给予读写权限，复制访问令牌。  </p>
<h3 id="安装-Mastodon-py"><a href="#安装-Mastodon-py" class="headerlink" title="安装 Mastodon.py"></a>安装 Mastodon.py</h3><p>安装 miniconda3：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir miniconda</span><br><span class="line"><span class="built_in">cd</span> miniconda</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 python 最新版本并用 bash 安装</span></span><br><span class="line">wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">sh Miniconda3-latest-Linux-x86_64.sh //用bash安装</span><br></pre></td></tr></table></figure>

<p>通过 <code>pip</code> 安装 Mastodon.py：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install requests beautifulsoup4 Mastodon.py <span class="comment"># 安装mastodon.py</span></span><br><span class="line">mkdir satan</span><br><span class="line"><span class="built_in">cd</span> satan</span><br><span class="line">nano mybot_usercred.secret <span class="comment"># 写入刚才复制的访问令牌，保存退出</span></span><br><span class="line">nano satan.py <span class="comment"># 发嘟脚本</span></span><br></pre></td></tr></table></figure>

<p>最新 mastodon.py 已经更新至<code>1.8.0</code> (最新版本查询：<a href="https://github.com/halcy/Mastodon.py/releases">mastodon.py release</a>)，代码结构有较大变动。但由于之前写 DOGchan 和 CATsama 已经安装过 mastodon.py，satan 仍使用之前下载的版本 <code>1.5.1</code> ( <a href="https://github.com/halcy/Mastodon.py/archive/refs/tags/1.5.1.zip">代码下载</a> )。  </p>
<h2 id="撒旦本体"><a href="#撒旦本体" class="headerlink" title="撒旦本体"></a>撒旦本体</h2><p>因为不想仔细写代码，所以对用户发嘟的要求较高，每一步代码也都是默认用户会按照要求向撒旦老人发私信来写的，每一步处理都简单粗暴。如果明年还会有这个快闪活动，或许会修改代码，提高容错和健壮性。  </p>
<h3 id="提取嘟文主体"><a href="#提取嘟文主体" class="headerlink" title="提取嘟文主体"></a>提取嘟文主体</h3><p>代码基本与 DOGchan 时参考的代码一致，但删减了部分不需要的修改，最终使用版本如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_toot</span>(<span class="params">toot</span>):</span></span><br><span class="line">    toot = toot.replace(<span class="string">&quot;&amp;apos;&quot;</span>, <span class="string">&quot;&#x27;&quot;</span>) <span class="comment">#convert HTML stuff to normal stuff</span></span><br><span class="line">    toot = toot.replace(<span class="string">&quot;&amp;quot;&quot;</span>, <span class="string">&#x27;&quot;&#x27;</span>) <span class="comment">#ditto</span></span><br><span class="line">    soup = BeautifulSoup(toot, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> lb <span class="keyword">in</span> soup.select(<span class="string">&quot;br&quot;</span>): <span class="comment">#replace &lt;br&gt; with linebreak</span></span><br><span class="line">        lb.insert_after(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        lb.decompose()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> soup.select(<span class="string">&quot;p&quot;</span>): <span class="comment">#ditto for &lt;p&gt;</span></span><br><span class="line">        p.insert_after(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        p.unwrap()</span><br><span class="line">    <span class="keyword">for</span> ht <span class="keyword">in</span> soup.select(<span class="string">&quot;a.hashtag&quot;</span>): <span class="comment">#make hashtags no longer links, just text</span></span><br><span class="line">        ht.unwrap()</span><br><span class="line">    text = soup.get_text()</span><br><span class="line">    text = text.rstrip(<span class="string">&quot;\n&quot;</span>) <span class="comment">#remove trailing newline</span></span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure>

<p>利用 extract_toot 提取嘟文内容将只剩下需要处理判断的部分，后续只需要根据关键词送入不同的 <code>if</code> 处理文本。<br>上述两个例子处理后的文本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Satan\n悄悄话\n向谁说：Satan@musain.cafe\n内容：Do you hear the Santa sing?\n匿名：是\n可见度：direct</span><br><span class="line">@Satan\n许愿\n愿望：Beyond the barricade, there is a world we long to see.\n匿名：否\n可见度：unlisted</span><br></pre></td></tr></table></figure>

<h3 id="许愿"><a href="#许愿" class="headerlink" title="许愿"></a>许愿</h3><p>许愿主要实现投稿愿望，Satan 账号根据投稿时标注的相关要求，将心愿发布。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pattern2.search(mention_text):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Wish!&quot;</span>)</span><br><span class="line">    mention_text_temp = mention_text.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    mention_text_len = <span class="built_in">len</span>(mention_text_temp)</span><br><span class="line">    mention_text = mention_text_temp[(mention_text_len-<span class="number">3</span>):]</span><br><span class="line">    wish_text = mention_text[<span class="number">0</span>].split(<span class="string">&#x27;：&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    anonymous_if = mention_text[<span class="number">1</span>].split(<span class="string">&#x27;：&#x27;</span>)[<span class="number">1</span>].lower() == (<span class="string">&#x27;否&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">    to_visibility = mention_text[<span class="number">2</span>].split(<span class="string">&#x27;：&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> anonymous_if:</span><br><span class="line">        content = wish_text + <span class="string">&#x27;\n 来自 &#x27;</span> + acct + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content = wish_text</span><br><span class="line">        mastodon.status_post(</span><br><span class="line">        status = content, </span><br><span class="line">        visibility=to_visibility </span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="悄悄话"><a href="#悄悄话" class="headerlink" title="悄悄话"></a>悄悄话</h3><p>悄悄话主要实现根据投稿人提供的悄悄话内容和其它范围要求，将悄悄话转发给投稿人希望的用户。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pattern1.search(mention_text):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Whisper!&quot;</span>)</span><br><span class="line">    mention_text_temp = mention_text.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    mention_text_len = <span class="built_in">len</span>(mention_text_temp)</span><br><span class="line">    mention_text = mention_text_temp[(mention_text_len-<span class="number">4</span>):]</span><br><span class="line">    to_account_id = <span class="string">&#x27;@&#x27;</span> + mention_text[<span class="number">0</span>].split(<span class="string">&#x27;：&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    whisper_text = mention_text[<span class="number">1</span>].split(<span class="string">&#x27;：&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    anonymous_if = mention_text[<span class="number">2</span>].split(<span class="string">&#x27;：&#x27;</span>)[<span class="number">1</span>].lower() == (<span class="string">&#x27;否&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">    to_visibility = mention_text[<span class="number">3</span>].split(<span class="string">&#x27;：&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> anonymous_if:</span><br><span class="line">        content = to_account_id + <span class="string">&#x27; \n&#x27;</span> + whisper_text + <span class="string">&#x27;\n 来自&#x27;</span> + acct + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content = to_account_id + <span class="string">&#x27; \n&#x27;</span> + whisper_text</span><br><span class="line">        mastodon.status_post(</span><br><span class="line">        status = content,</span><br><span class="line">        visibility = to_visibility </span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Satan 的代码部分来源于 mastodon-bot-template，并参考了 mstdn-ebooks 和 Mastodon.py。<br>Mastodon.py: <a href="https://mastodonpy.readthedocs.io/en/stable/index.html#">Docs</a> , <a href="https://github.com/halcy/Mastodon.py">GitHub</a><br>mastodon-bot-template: <a href="https://github.com/Lynnesbian/mastodon-bot-template/blob/9e72f6a490734f7af5897c40f20b4aecb0c2308b/reply.py">reply.py</a><br>mstdn-ebooks: <a href="https://github.com/Lynnesbian/mstdn-ebooks/blob/master/reply.py">reply.py</a></p>
<p>功能与自动回复的汪汪相差不大，所以参考仍然是上次写汪汪时的参考。  </p>
]]></content>
      <categories>
        <category>Mastodon</category>
        <category>Bot</category>
      </categories>
      <tags>
        <tag>Mastodon</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Methods to Analyze Multi-Omicis Data</title>
    <url>/2021/12/01/multiomics/</url>
    <content><![CDATA[<center>文献阅读：多组学数据的整合、解读方法及公开可用的多组学数据库</center>
<span id="more"></span>

<br>

<h2 id="Multi-Omics"><a href="#Multi-Omics" class="headerlink" title="Multi-Omics"></a>Multi-Omics</h2><p><strong>Multi-Omics</strong>指同时获得两个或两个以上组学数据，如基因组、转录组、蛋白质组等，并将它们结合在一起分析、挖掘，以获得更全面、更系统的生物学解释、分子作用机制等。  </p>
<h2 id="多组学研究的意义"><a href="#多组学研究的意义" class="headerlink" title="多组学研究的意义"></a>多组学研究的意义</h2><p>整合多组学数据，提供不同层次的生物分子信息，有望系统地、整体地理解复杂的生物学。<br>多组学研究以顺序或同时的方式结合各组学数据，以了解分子之间的相互作用。<br>有助于评估从一个组学水平到另一个组学水平的信息流，从而有助于弥合从基因型到表型的差距。<br>多组学数据能够为研究提供整体视角，有助于提高疾病表型的预后和预测准确性，进而帮助更好地治疗和预防。  </p>
<h2 id="多组学研究的困难"><a href="#多组学研究的困难" class="headerlink" title="多组学研究的困难"></a>多组学研究的困难</h2><p>多组学的研究通常与非组学数据相关联，如临床数据等，这导致多组学研究面临许多困难。  </p>
<h3 id="非组学数据复杂且主观定义"><a href="#非组学数据复杂且主观定义" class="headerlink" title="非组学数据复杂且主观定义"></a>非组学数据复杂且主观定义</h3><p>非组学数据通常十分复杂且主观性较强，需要标准化后将其加入预测或分类模型中。流行病学数据受制于调查模式、调查问题标准化以及背景，这可能会影响数据质量和可比性，并最终影响这些变量在结果预测中的贡献。不同研究者或组织由于收集程序不一致，也可能产生差异。临床数据受到其定义复杂性的影响，需要有统一的标准。目前有一些标准化的规则可供使用，如Clinical Data Interchange Standards Consortium (CDISC)，Study Data Tabulation Model (SDTM)，Analysis Data Model (ADaM)。这些非组学数据是基于评估者的技能和先前知识的复杂阐述过程产生的主观评估，这可能会导致报告偏差。  </p>
<h3 id="非组学数据具有异质性"><a href="#非组学数据具有异质性" class="headerlink" title="非组学数据具有异质性"></a>非组学数据具有异质性</h3><p>非组学数据缺乏统一性，如不同尺度测量的定性或定量变量等，在分析之前需要对它们进行数据转换或归一化步骤。  </p>
<h3 id="非组学数据规模大"><a href="#非组学数据规模大" class="headerlink" title="非组学数据规模大"></a>非组学数据规模大</h3><p>目前，许多多组学数据与非组学数据相结合的研究方法基于小尺度、低纬度的数据，而现在的非组学数据已经成为“大数据”——大规模，高维度。可穿戴监测装置和EHR (e-health records)的出现使非组学数据更易获取并向更高维度发展，且在处理客观和主观特征以及结构化和非结构化数据方面也更具有挑战性。<br>非组学数据的高维度也意味着存在</p>
<ul>
<li>变量之间的相关结构  </li>
<li>大规模纵向数据  </li>
<li>数据稀疏性（即药物、实验室或诊断测试）  </li>
<li>与组学数据相比，数据缺失与参与个体无关  </li>
</ul>
<p>这些因素都需要在后续分析建模时，将其考虑在内。  </p>
<h3 id="将组学和非组学数据联系"><a href="#将组学和非组学数据联系" class="headerlink" title="将组学和非组学数据联系"></a>将组学和非组学数据联系</h3><p>在病例对照设计中，组学数据和非组学数据的整合可能会受到确认偏差的影响。<br>组学和非组学数据之间的相互作用也会对研究产生影响。在建模的过程中，重要的是要将这种相互作用考虑在内。这些相互作用也可能非常复杂，如基因表达变化可能意味着表型异常，这导致分子数据和临床数据之间的关系更加复杂。  </p>
<h3 id="其它困难"><a href="#其它困难" class="headerlink" title="其它困难"></a>其它困难</h3><p>每个变量或块对结果的贡献是否应该相等。<br>当与高通量数据集结合时，如何防止临床变量被惩罚(penalized)。<br>亚型的出现会给模型增加复杂性，在建模时是否要将亚型考虑在内。</p>
<h2 id="多组学数据库"><a href="#多组学数据库" class="headerlink" title="多组学数据库"></a>多组学数据库</h2><p>多组学数据覆盖基因组、蛋白组、转录组、代谢组和表观遗传组的数据，含有这些组学数据两种或两种以上的数据库可成为多组学数据库。  </p>
<h3 id="TCGA"><a href="#TCGA" class="headerlink" title="TCGA"></a>TCGA</h3><p>The Cancer Genome Altas (<a href="https://cancergenome.nih.gov/">TCGA</a>) 是最大的多组学数据库之一，涵盖超过 33 种不同类型癌症的20000个个体肿瘤样本。TCGA旨在产生、整合、分析和解释肿瘤样本产生的DNA、RNA、蛋白质及表观遗传数据的特征以及临床和组织学数据。</p>
<h3 id="CPTAC"><a href="#CPTAC" class="headerlink" title="CPTAC"></a>CPTAC</h3><p>Clinical Proteomic Tumor Analysis Consortium (<a href="https://cptac-data-portal.georgetown.edu/cptacPublic/">CPTAC</a>) 是通过对TCGA库中的生物样本通过质谱技术进行分析，获取的蛋白质组数据。如果实验中同时测得基因组数据，也可在该库获得。  </p>
<h3 id="ICGC"><a href="#ICGC" class="headerlink" title="ICGC"></a>ICGC</h3><p>International Cancer Genomics Consortium (<a href="https://icgc.org/">ICGC</a>) 从20383名捐献者的21个原发癌位点的76个癌症项目中协调大规模生成基因组研究。  </p>
<h3 id="CCLE"><a href="#CCLE" class="headerlink" title="CCLE"></a>CCLE</h3><p>Cancer Cell Line Encyclopedia (<a href="https://portals.broadinstitute.org/ccle">CCLE</a>) 包含947种人类细胞系和36种肿瘤的基因表达、拷贝数和测序数据。还包含479种癌细胞系中24种抗癌药物的药理学特征。  </p>
<h3 id="METABRIC"><a href="#METABRIC" class="headerlink" title="METABRIC"></a>METABRIC</h3><p>Molecular Taxonomy of Breast Cancer International Consortium (<a href="http://molonc.bccrc.ca/apariciolab/research/metabric/">METABRIC</a>) 包含来自乳腺肿瘤的临床特征、表达、单核苷酸多态性和拷贝数变异数据。  </p>
<h3 id="TARGET"><a href="#TARGET" class="headerlink" title="TARGET"></a>TARGET</h3><p><a href="https://ocg.cancer.gov/programs/target">TARGET</a> 包含 24 种癌症分子类型的临床信息、基因表达、miRNA 表达、拷贝数和测序数据。  </p>
<h3 id="OmicsDI"><a href="#OmicsDI" class="headerlink" title="OmicsDI"></a>OmicsDI</h3><p>Omics Discovery Index (<a href="https://www.omicsdi.org/">OmicsDI</a>) 包含来自公共数据结构中的 11 个存储库的数据集。是一个开源平台，用于访问、发现和整合基因组学、转录组学、蛋白质组学和代谢组学数据集。包含来自人类、模式生物和非模式生物的数据集。  </p>
<h2 id="多组学数据分析方法"><a href="#多组学数据分析方法" class="headerlink" title="多组学数据分析方法"></a>多组学数据分析方法</h2><p>根据算法思想，可将目前已有的多组学数据分析方法分为几个大类：<br><img src="/2021/12/01/multiomics/methods.png">  </p>
<h3 id="Network-Based"><a href="#Network-Based" class="headerlink" title="Network Based"></a>Network Based</h3><p><strong>SNF</strong> (Similarity network fusion)是一种基于网络的方法，使用网络融合方法整合多组学数据集。它为每种数据类型创建一个单独的网络，然后使用非线性网络融合方法将它们融合成一个单一的相似性网络。 融合步骤基于消息传递理论，使网络在每次迭代中更像其他网络。<br><strong>NetICS</strong> (Network-based integration of multi-omics data)为基于网络的多组学数据集成提供了一个框架，用于癌症基因优先排序。可预测遗传畸变、表观遗传变化和miRNA对相互作用网络中下游基因和蛋白质(表达)的影响。在有向功能交互网络上使用每个样本的网络扩散模型，并通过聚合个体排名得出种群水平的基因排名，并为所有样本提供全局排名。  </p>
<h3 id="Bayesian-approach"><a href="#Bayesian-approach" class="headerlink" title="Bayesian approach"></a>Bayesian approach</h3><p><strong>iCluster</strong>根据多种数据类型同时推断，为样本生成一个单一的聚类分配。这种无监督方法使用联合潜在变量模型进行集成聚类，并在单个框架中结合不同数据类型之间的关联以及数据类型内的方差-协方差结构，同时降低数据集的维度。通过期望最大化算法获得似然推理。<br><strong>iClusterPlus</strong>是iCluster的增强版，使用广义线性回归来确定综合基因组、表观基因组和转录组分析的分类和数字(连续和计数)变量的联合模型。该方法使用一组潜在变量”k”来代表驱动因素，这些因素预测关键的基因组变量，从而捕捉生物变异。此外，使用Lasso回归方法，iClusterPlus确定了有助于亚型之间生物变化的特征子集。<br><strong>LRAcluster</strong>使用概率模型与低秩近似法来寻找主要的低维子空间，以对全基因组数据进行分类。在这种方法中，每个组学数据都以大小匹配的参数矩阵为条件，并且这个低秩参数矩阵可以在低维空间中表示。 用户定义的维度参数(基于数据的解释方差)和聚类数(基于轮廓值)有助于更快地降维和更好地聚类疾病亚型。<br><strong>PSDF</strong> (Patient-specific data fusion)该方法使用贝叶斯非参数模型(Dirichlet 过程混合模型)来整合CNV和基因表达数据，以将样本分层为子组。每个样本根据它们在2个数据集之间的一致性被分配一个二元状态。只有表现出一致性的样本融合在一起，而其他样本保持未融合，因此考虑了患者特定的融合模型。<br><strong>BCC</strong> (Bayesian consensus clustering)提出了一种数据驱动的共识聚类方法，该方法对源特定特征以及使用有限狄利克雷混合模型扩展以解释多个数据源的整体聚类进行建模。<br><strong>Joint Bayesian factor</strong>使用非参数贝叶斯因子分析来整合组学数据集。 这种方法使用 beta-Bernoulli 过程将特征空间分解为共享的和特定于数据的组件。<br><strong>MDI</strong> (Multiple dataset integration)使用 Dirichlet 混合模型对每个数据源进行聚类，同时对聚类之间的成对依赖性进行建模。MDI在分配给组件(如基因组特征)的变量级别链接模型。组件变量级链接允许捕获多组学数据之间的依赖关系。<br><strong>MOFA</strong> (Multi-omics factor analysis)是一种无监督方法，用于在相同或部分重叠的样本上整合多组学数据类型。<br><strong>PARADIGM</strong>的应用可以扩展到对所研究疾病的发现。  </p>
<h3 id="Fusion-based-approaches"><a href="#Fusion-based-approaches" class="headerlink" title="Fusion-based approaches"></a>Fusion-based approaches</h3><p><strong>PFA</strong> (Pattern fusion analysis)允许在低维特征空间中跨异质基因组谱识别集成样本模式。首先使用主成分分析获得局部样本模式。 其后将这些局部样本模式与公共特征空间对齐，并跨大多数数据类型合成全局样本模式。在此过程中，将定量测量每种数据类型(或单个样本)对全局样本频谱的贡献，并迭代降低偏差或系统噪声的影响以更好地拟合数据。  </p>
<h3 id="Similarity-based-approaches"><a href="#Similarity-based-approaches" class="headerlink" title="Similarity-based approaches"></a>Similarity-based approaches</h3><p><strong>PINSPlus</strong> (Perturbation clustering for data integration and disease subtyping)是一种无监督的聚类方法，有助于从多组学数据中识别亚型。为了识别亚型，该算法确定患者在单个集群中分组的频率(1)当数据受到干扰时，(2)使用不同类型的组学数据时，(3)使用不同的聚类技术时。 所有场景中的强关联患者都聚集在一起形成一个亚型。<br><strong>NEMO</strong>(Neighborhood-based multi-omics clustering) 是一种基于相似性的简单多组学聚类方法，它进一步建立在先前建立的聚类方法（如 SNF 和 rMKL-LPP）的基础上。该方法最初为每个输入组学数据集构建基于患者间相似性矩阵的欧几里德距离。然后将每个组学的相似性矩阵整合到一个矩阵中，然后使用光谱聚类方法对其进行聚类。  </p>
<h3 id="Correlation-based-approaches"><a href="#Correlation-based-approaches" class="headerlink" title="Correlation based approaches"></a>Correlation based approaches</h3><p><strong>CNAmet</strong>用于对拷贝数改变、DNA 甲基化和基因表达数据进行综合分析。  </p>
<h3 id="Other-multivariate-approaches"><a href="#Other-multivariate-approaches" class="headerlink" title="Other multivariate approaches"></a>Other multivariate approaches</h3><p><strong>mixOmics</strong>提供了一组有监督和无监督的多元方法来执行多组学数据集的整合，重点是变量选择。<br><strong>moCluster</strong>使用多表多元分析方法来识别跨多组学数据集的模式。<br><strong>MCIA</strong> (Multiple co-inertia analysis)是一种探索性数据分析方法，它捕捉多个高维数据集（如基因表达、miRNA表达、蛋白质表达）之间的相互关系。<br><strong>JIVE</strong> (Joint and individual variation explained)通过分离数据集的联合效应和个体效应来整合多组学数据。<br><strong>MFA</strong> (Multiple factor analysis)是一种通过将其投影到低维变量空间来帮助整合组学数据集的方法。<br><strong>rMKL-LPP</strong> 使用多核学习来集成异构多数据并执行子类型识别。<br><strong>iNMF</strong> (Integrative nonnegative matrix factorization)扩展了NMF框架以在集成多个数据时考虑异构效应。<br><strong>FSMKL</strong> (Feature selection multiple kernel learning)是一种监督分类方法，使用多个内核来捕获数据集之间的相似性，以识别疾病进展的特征。<br><strong>sMBPLS</strong> (Sparse multi-block partial least squares)允许多块输入包含多个调控组学数据集，例如 CNV、DNA 甲基化和调控基因表达的 miRNA 表达。<br><strong>T-SVD</strong> (Thresholding singular value decomposition)有助于识别 2 个组学数据集之间的调控机制，尤其是当调控特征大于测量样本时。<br><strong>Joint NMF</strong> 该分解框架从多个数据集(相同样本)中识别相关模块，以推导出 md 模块，以揭示潜在的多层监管因素。  </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Subramanian I, Verma S, Kumar S, Jere A, Anamika K. Multi-omics Data Integration, Interpretation, and Its Application. Bioinformatics and Biology Insights. January 2020. <a href="doi:10.1177/1177932219899051">doi:10.1177/1177932219899051</a><br>[2] López de Maturana E, Alonso L, Alarcón P, Martín-Antoniano IA, Pineda S, Piorno L, Calle ML, Malats N. Challenges in the Integration of Omics and Non-Omics Data. Genes (Basel). 2019 Mar 20;10(3):238. <a href="doi:10.3390/genes10030238">doi:10.3390/genes10030238</a></p>
]]></content>
      <categories>
        <category>Paper</category>
        <category>MultiOmics</category>
      </categories>
      <tags>
        <tag>Bioinformatics</tag>
        <tag>MultiOmics</tag>
      </tags>
  </entry>
  <entry>
    <title>识别和消除批次效应的R包proBatch的使用</title>
    <url>/2021/11/08/proBatch/</url>
    <content><![CDATA[<center>proBatch: Tools for Diagnostics and Corrections of Batch Effects in Proteomics</center>
<span id="more"></span>

<br>

<h2 id="proBatch简介"><a href="#proBatch简介" class="headerlink" title="proBatch简介"></a>proBatch简介</h2><p>proBatch是便于在高通量实验中进行批量效应分析和校正的分析工具。主要为质谱蛋白质组学(DIA/SWATH)开发，但也可在调整后应用于大多数的Omic数据。<br>proBatch包含  </p>
<ul>
<li>诊断(蛋白质组/基因组范围和特征水平)  </li>
<li>校正(归一化和批次效应校正)  </li>
<li>基于非线性拟合的方法来处理复杂的、质谱特有的信号漂移</li>
<li>质量控制<br>功能。  </li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装所需的其它包"><a href="#安装所需的其它包" class="headerlink" title="安装所需的其它包"></a>安装所需的其它包</h3><p>proBatch主要通过调用其它包中的函数实现功能，因此依赖于许多其它已有的R包。如果其中一些包未安装，则需要在运行proBatch之前安装。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">bioc_deps &lt;- <span class="built_in">c</span>(<span class="string">&quot;GO.db&quot;</span>, <span class="string">&quot;impute&quot;</span>, <span class="string">&quot;preprocessCore&quot;</span>, <span class="string">&quot;pvca&quot;</span>,<span class="string">&quot;sva&quot;</span> )</span><br><span class="line">cran_deps &lt;- <span class="built_in">c</span>(<span class="string">&quot;corrplot&quot;</span>, <span class="string">&quot;data.table&quot;</span>, <span class="string">&quot;ggplot2&quot;</span>, <span class="string">&quot;ggfortify&quot;</span>,<span class="string">&quot;lazyeval&quot;</span>, <span class="string">&quot;lubridate&quot;</span>, <span class="string">&quot;pheatmap&quot;</span>, <span class="string">&quot;reshape2&quot;</span>,<span class="string">&quot;readr&quot;</span>, <span class="string">&quot;rlang&quot;</span>, <span class="string">&quot;tibble&quot;</span>, <span class="string">&quot;dplyr&quot;</span>, <span class="string">&quot;tidyr&quot;</span>, <span class="string">&quot;wesanderson&quot;</span>,<span class="string">&quot;WGCNA&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">  install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line">BiocManager::install(bioc_deps)</span><br><span class="line">install.packages(cran_deps)</span><br></pre></td></tr></table></figure>
<h3 id="安装proBatch"><a href="#安装proBatch" class="headerlink" title="安装proBatch"></a>安装proBatch</h3><p>可通过以下三个途径获取proBatch包：  </p>
<ul>
<li><a href="https://www.bioconductor.org/packages/release/bioc/html/proBatch.html">Bioconductor</a>  <figure class="highlight r"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!requireNamespace(<span class="string">&quot;BiocManager&quot;</span>, quietly = <span class="literal">TRUE</span>))</span><br><span class="line">        install.packages(<span class="string">&quot;BiocManager&quot;</span>)</span><br><span class="line"></span><br><span class="line">    BiocManager::install(<span class="string">&quot;proBatch&quot;</span>)</span><br><span class="line">    ```  </span><br><span class="line">- [Docker container](https://hub.docker.com/r/digitalproteomes/probatch)  </span><br><span class="line">- [GitHub repository](https://github.com/symbioticMe/batch_effects_workflow_code)  </span><br><span class="line">  ```R</span><br><span class="line">    library(devtools)</span><br><span class="line">    install_github(<span class="string">&quot;symbioticMe/proBatch&quot;</span>, build_vignettes = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<h2 id="proBatch的使用"><a href="#proBatch的使用" class="headerlink" title="proBatch的使用"></a>proBatch的使用</h2>要查看与系统中安装的proBatch版本相对应的说明文档，启动R并输入:  <figure class="highlight r"><table><tr><td class="code"><pre><span class="line">browseVignettes(<span class="string">&quot;proBatch&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用前的tips"><a href="#使用前的tips" class="headerlink" title="使用前的tips"></a>使用前的tips</h3><ul>
<li>一些基本的数据处理步骤已经完成，如已经完成搜库比对、FDR control、log-transformation等  </li>
<li>数据过滤。应过滤掉诱饵测量值(decoy measurements)以确保正确的样本强度分布对齐。过滤掉低质量的样本(通常通过鉴定肽的总强度或样品的相关性来确定)  </li>
<li>建议在批次效应校正之前不要填补缺失值  </li>
<li>在消除批次效应之后再进行蛋白质定量  </li>
</ul>
<h3 id="Preparing-for-data-analysis"><a href="#Preparing-for-data-analysis" class="headerlink" title="Preparing for data analysis"></a>Preparing for data analysis</h3><h4 id="Loading-the-libraries"><a href="#Loading-the-libraries" class="headerlink" title="Loading the libraries"></a>Loading the libraries</h4><p>加载所需的包，以便后续步骤的使用。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">require(dplyr)</span><br><span class="line">require(tibble)</span><br><span class="line">require(ggplot2)</span><br><span class="line">library(proBatch)</span><br></pre></td></tr></table></figure>
<h4 id="Input-data"><a href="#Input-data" class="headerlink" title="Input data"></a>Input data</h4><p>数据分析需要三个数据表，即：  </p>
<ol>
<li>measurement (data matrix)  </li>
<li>sample annotation  </li>
<li>feature annotation (optional) tables  </li>
</ol>
<p>如果对BioBase数据比较熟悉，则可认为上述的三种数据是：  </p>
<ol>
<li>assayData  </li>
<li>joined phenoData and protocolData  </li>
<li>featureData  </li>
</ol>
<p>三种数据可参考包中给出的示例数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data(<span class="string">&#x27;example_proteome&#x27;</span>, <span class="string">&#x27;example_sample_annotation&#x27;</span>, <span class="string">&#x27;example_peptide_annotation&#x27;</span>, package = <span class="string">&#x27;proBatch&#x27;</span>)  </span><br></pre></td></tr></table></figure>
<p>或<a href="http://www.bioconductor.org/packages/release/bioc/vignettes/proBatch/inst/doc/proBatch.pdf">proBatch overview</a>中的详细说明。  </p>
<h4 id="其它有用的函数"><a href="#其它有用的函数" class="headerlink" title="其它有用的函数"></a>其它有用的函数</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transforming the data to long or wide format</span></span><br><span class="line">example_matrix &lt;- long_to_matrix(example_proteome, feature_id_col = <span class="string">&#x27;peptide_group_label&#x27;</span>, measure_col = <span class="string">&#x27;Intensity&#x27;</span>, sample_id_col = <span class="string">&#x27;FullRunName&#x27;</span>)</span><br><span class="line"><span class="comment"># Transforming the data to log scale</span></span><br><span class="line"><span class="comment"># 零值会被保留为零</span></span><br><span class="line">log_transformed_matrix &lt;- log_transform_dm(example_matrix, log_base = <span class="number">2</span>, offset = <span class="number">1</span>)</span><br><span class="line"><span class="comment"># Defining the color scheme</span></span><br><span class="line">color_list &lt;- sample_annotation_to_colors(example_sample_annotation, factor_columns = <span class="built_in">c</span>(<span class="string">&#x27;MS_batch&#x27;</span>, <span class="string">&#x27;digestion_batch&#x27;</span>, <span class="string">&#x27;EarTag&#x27;</span>, <span class="string">&#x27;Strain&#x27;</span>, <span class="string">&#x27;Diet&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>), numeric_columns = <span class="built_in">c</span>(<span class="string">&#x27;DateTime&#x27;</span>,<span class="string">&#x27;order&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Initial-assessment-of-the-raw-data-matrix"><a href="#Initial-assessment-of-the-raw-data-matrix" class="headerlink" title="Initial assessment of the raw data matrix"></a>Initial assessment of the raw data matrix</h3><h4 id="Plotting-the-sample-mean"><a href="#Plotting-the-sample-mean" class="headerlink" title="Plotting the sample mean"></a>Plotting the sample mean</h4><p>proBatch建议在处理批次效应之后再填补缺失值，但包中没有兼容存在缺失值的情况，如果有缺失值无法计算mean。<br><code>plot_sample_mean</code>函数主要实现的功能为计算样本均值并绘制样本均值散点图，横坐标为样本顺序(order)，纵坐标为样本均值(Mean_Intensity)，并以不同颜色表示样本的batch。可通过自行编写能够兼容缺失值的代码实现这一功能。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot_sample &lt;- data.frame(row.names = colnames(log_transformed_matrix))</span><br><span class="line">colnum &lt;- ncol(log_transformed_matrix)</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">c</span>(<span class="number">1</span>:colnum))</span><br><span class="line">&#123;</span><br><span class="line">  item &lt;- colnames(log_transformed_matrix)[i]</span><br><span class="line">  plot_sample[item, <span class="string">&quot;mean&quot;</span>] &lt;- mean(log_transformed_matrix[,i], na.rm=<span class="built_in">T</span>)</span><br><span class="line">  plot_sample[item,<span class="string">&quot;MS_batch&quot;</span>] &lt;- sample_anno[i,<span class="string">&quot;MS_batch&quot;</span>]</span><br><span class="line">  plot_sample[item,<span class="string">&quot;order&quot;</span>] &lt;- sample_anno[i,<span class="string">&quot;order&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">ggplot(plot_sample, aes(order, mean, color = MS_batch)) + geom_point() + xlab(<span class="string">&quot;order&quot;</span>) + ylab(<span class="string">&quot;Mean_intensity&quot;</span>) + ylim(<span class="number">0</span>,<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Plotting-boxplots"><a href="#Plotting-boxplots" class="headerlink" title="Plotting boxplots"></a>Plotting boxplots</h4><p>绘制箱图观察数据：  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">log_transformed_long &lt;- matrix_to_long(log_transformed_matrix)</span><br><span class="line">batch_col = <span class="string">&#x27;MS_batch&#x27;</span></span><br><span class="line">plot_boxplot(log_transformed_long, example_sample_annotation, batch_col = batch_col, color_scheme = color_list[[batch_col]])</span><br></pre></td></tr></table></figure>
<p>利用PEAKS数据做到这一步时发现产生的箱图向0偏，即含有大量0值。这是PEAKS搜库结果的一个特点，除了缺失值还会有大量intensity被定量为0。在之前处理PEAKS数据时，log-transformation步骤会将0转换为NA，在后续步骤也当作缺失值处理。<br><img src="/2021/11/08/proBatch/value0.png" alt="含有大量0值"><br>而proBatch包针对的是openSWATH产生的tsv数据。该包中的函数<code>log_transform_dm</code>会将0保留为0，导致使用PEAKS数据画箱图时出现问题。返回log-transformation步骤使用自己写的处理代码处理数据后，箱图绘制与预期一致。<br><img src="/2021/11/08/proBatch/valueNA.png" alt="将0转换为NA">  </p>
<h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>包中提供Median Normalization和Quantiles Normalization，可直接使用。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Median Normalization</span></span><br><span class="line"><span class="comment"># If data has been log transformed</span></span><br><span class="line">median_normalized_matrix = normalize_data_dm(log_transformed_matrix, normalize_func = <span class="string">&#x27;medianCentering&#x27;</span>)</span><br><span class="line"><span class="comment"># if data hasn&#x27;t been log transformed</span></span><br><span class="line">median_normalized_matrix = normalize_data_dm(example_matrix, normalize_func = <span class="string">&#x27;medianCentering&#x27;</span>, log_base = <span class="number">2</span>, offset = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Quantile Normalization</span></span><br><span class="line">quantile_normalized_matrix = normalize_data_dm(log_transformed_matrix, normalize_func = <span class="string">&#x27;quantile&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>后续相应的画图观察处理后的数据时，应注意Inf值的影响。数据中如有<code>Inf</code>或<code>-Inf</code>，可通过<code>data[data == Inf] &lt;- NA</code>或<code>data[data == -Inf] &lt;- NA</code>将其替换。Inf出现是因为在log转换时没有处理好0值。  </p>
<h3 id="Diagnostics-of-batch-effects-in-normalized-data"><a href="#Diagnostics-of-batch-effects-in-normalized-data" class="headerlink" title="Diagnostics of batch effects in normalized data"></a>Diagnostics of batch effects in normalized data</h3><h4 id="Hierarchical-clustering-amp-heatmap"><a href="#Hierarchical-clustering-amp-heatmap" class="headerlink" title="Hierarchical clustering &amp; heatmap"></a>Hierarchical clustering &amp; heatmap</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">selected_annotations &lt;- <span class="built_in">c</span>(<span class="string">&#x27;MS_batch&#x27;</span>, <span class="string">&#x27;digestion_batch&#x27;</span>, <span class="string">&#x27;Diet&#x27;</span>)</span><br><span class="line"><span class="comment"># Plot clustering between samples</span></span><br><span class="line">plot_hierarchical_clustering(quantile_normalized_matrix, sample_annotation = example_sample_annotation, color_list = color_list, factors_to_plot = selected_annotations, distance = <span class="string">&#x27;euclidean&#x27;</span>, agglomeration = <span class="string">&#x27;complete&#x27;</span>, label_samples = <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment"># Heatmap</span></span><br><span class="line">plot_heatmap_diagnostic(quantile_normalized_matrix, example_sample_annotation, factors_to_plot = selected_annotations, cluster_cols = <span class="literal">TRUE</span>, color_list = color_list, show_rownames = <span class="literal">FALSE</span>, show_colnames = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p>根据报错信息可知color_list一项一直与我的数据不兼容，因此注释行显示不完全。<br>修改color_list或根据数据需要重写聚类绘图函数即可。   </p>
<h4 id="PCA-amp-PVCA"><a href="#PCA-amp-PVCA" class="headerlink" title="PCA &amp; PVCA"></a>PCA &amp; PVCA</h4><p>PCA和PVCA使用时，缺失值会被直接填为-1。<br>PVCA对计算的要求很高，且耗时较长，尤其是数据量大的情况。建议在性能较好的机器上运行这一步骤。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pca</span></span><br><span class="line">pca1 = plot_PCA(median_normalized_matrix, sample_anno, color_by = <span class="string">&#x27;MS_batch&#x27;</span>, plot_title = <span class="string">&#x27;MS batch&#x27;</span>, color_scheme = color_list[[<span class="string">&#x27;MS_batch&#x27;</span>]])</span><br><span class="line">pca2 = plot_PCA(median_normalized_matrix, sample_anno, color_by = <span class="string">&#x27;digestion_batch&#x27;</span>, plot_title = <span class="string">&#x27;Digestion batch&#x27;</span>, color_scheme = color_list[[<span class="string">&#x27;digestion_batch&#x27;</span>]])</span><br><span class="line">pca3 = plot_PCA(median_normalized_matrix, sample_anno, color_by = <span class="string">&#x27;order&#x27;</span>, plot_title = <span class="string">&#x27;order&#x27;</span>, color_scheme = color_list[[<span class="string">&#x27;order&#x27;</span>]])</span><br><span class="line">pca4 = plot_PCA(median_normalized_matrix, sample_anno, color_by = <span class="string">&#x27;DateTime&#x27;</span>, plot_title = <span class="string">&#x27;DateTime&#x27;</span>, color_scheme = color_list[[<span class="string">&#x27;DateTime&#x27;</span>]])</span><br><span class="line">library(ggpubr)</span><br><span class="line">ggarrange(pca1, pca2, pca3, pca4, ncol = <span class="number">2</span>, nrow = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pvca</span></span><br><span class="line">technical_factors = <span class="built_in">c</span>(<span class="string">&#x27;MS_batch&#x27;</span>, <span class="string">&#x27;digestion_batch&#x27;</span>)</span><br><span class="line">biological_factors = <span class="literal">NULL</span></span><br><span class="line">biospecimen_id_col = <span class="string">&#x27;EarTag&#x27;</span></span><br><span class="line">plot_PVCA(median_normalized_matrix, sample_anno, technical_factors = technical_factors, biological_factors = biological_factors)</span><br></pre></td></tr></table></figure>

<h4 id="Peptide-level-diagnostics-and-spike-ins"><a href="#Peptide-level-diagnostics-and-spike-ins" class="headerlink" title="Peptide-level diagnostics and spike-ins"></a>Peptide-level diagnostics and spike-ins</h4><p>这一步骤需要将来自同一蛋白的肽段注释在一起。如果缺少肽段的注释信息，这一步骤无法正常进行。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">median_normalized_long &lt;- matrix_to_long(median_normalized_matrix)</span><br><span class="line">plot_spike_in(median_normalized_long, sample_anno, peptide_annotation = peptide_anno, protein_col = <span class="string">&#x27;Gene&#x27;</span>, spike_ins = <span class="string">&#x27;BOVINE_A1ag&#x27;</span>, plot_title = <span class="string">&#x27;Spike-in BOVINE protein peptides&#x27;</span>, color_by_batch = <span class="literal">TRUE</span>, color_scheme = color_list[[batch_col]])</span><br></pre></td></tr></table></figure>

<h3 id="correction-batch-effect"><a href="#correction-batch-effect" class="headerlink" title="correction batch effect"></a>correction batch effect</h3><h4 id="Continuous-drift-correction"><a href="#Continuous-drift-correction" class="headerlink" title="Continuous drift correction"></a>Continuous drift correction</h4><p>处理连续型批次效应使用LOESS拟合。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">loess_fit_df &lt;- adjust_batch_trend_df(quantile_normalized_long, example_sample_annotation)</span><br><span class="line">loess_fit_70 &lt;- adjust_batch_trend_df(median_normalized_long, sample_anno, span = <span class="number">0.7</span>)</span><br><span class="line">plot_with_fitting_curve(feature_name = <span class="string">&#x27;N(+.98)NATVHEQVGGPSLTSDLQAQSK&#x27;</span>, fit_df = loess_fit_70, fit_value_col = <span class="string">&#x27;fit&#x27;</span>, df_long = median_normalized_long, sample_annotation = sample_anno, color_by_batch = <span class="literal">TRUE</span>, color_scheme = color_list[[batch_col]], plot_title = <span class="string">&#x27;Span = 70%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Discrete-batch-correction"><a href="#Discrete-batch-correction" class="headerlink" title="Discrete batch correction"></a>Discrete batch correction</h4><p>处理离散型批次效应可通过median centering (per feature per batch)和ComBat进行。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># median centering</span></span><br><span class="line">peptide_median_df &lt;- center_feature_batch_medians_df(loess_fit_df, sample_anno)</span><br><span class="line">plot_single_feature(feature_name = <span class="string">&#x27;N(+.98)NATVHEQVGGPSLTSDLQAQSK&#x27;</span>, df_long = peptide_median_df, sample_annotation = sample_anno, measure_col = <span class="string">&#x27;Intensity&#x27;</span>, plot_title = <span class="string">&#x27;Feature-level Median Centered&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ComBat</span></span><br><span class="line">comBat_df &lt;- correct_with_ComBat_df(loess_fit_df, example_sample_annotation)</span><br><span class="line">plot_single_feature(feature_name = <span class="string">&#x27;10231_QDVDVWLWQQEGSSK_2&#x27;</span>, df_long = loess_fit_df, sample_annotation = example_sample_annotation, plot_title = <span class="string">&#x27;Loess Fitted&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Correct-batch-effects-universal-function"><a href="#Correct-batch-effects-universal-function" class="headerlink" title="Correct batch effects: universal function"></a>Correct batch effects: universal function</h4><p>proBatch提供一个方便的多合一的函数来进行批量校正。<br>函数<code>correct_batch_effects_df()</code>能在一次函数调用中可修正MS信号漂移和离散位移。只需在<code>discrete_func</code>中指定首选的离散校正方法，即<code>&quot;ComBat &quot;</code>或 <code>&quot;MedianCentering&quot;</code>。并补充其他参数，如<code>adjust_batch_trend_df()</code>中的<code>span</code>、<code>abs_threshold</code>或<code>pct_threshold</code>。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">batch_corrected_df &lt;- correct_batch_effects_df(df_long = median_normalized_long, sample_annotation = sample_anno,discrete_func = <span class="string">&#x27;ComBat&#x27;</span>,continuous_func = <span class="string">&#x27;loess_regression&#x27;</span>,abs_threshold = <span class="number">5</span>, pct_threshold = <span class="number">0.20</span>)</span><br><span class="line">batch_corrected_matrix &lt;- long_to_matrix(batch_corrected_df)</span><br></pre></td></tr></table></figure>
<h3 id="Quality-control"><a href="#Quality-control" class="headerlink" title="Quality control"></a>Quality control</h3><h4 id="Heatmap-of-selected-replicate-samples"><a href="#Heatmap-of-selected-replicate-samples" class="headerlink" title="Heatmap of selected replicate samples"></a>Heatmap of selected replicate samples</h4><p>挑选重复组计算相关性并绘制热图观察批次效应处理结果。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># specify which samples to correlate</span></span><br><span class="line">earTags &lt;- <span class="built_in">c</span>(<span class="string">&#x27;ET1524&#x27;</span>, <span class="string">&#x27;ET2078&#x27;</span>, <span class="string">&#x27;ET1322&#x27;</span>, <span class="string">&#x27;ET1566&#x27;</span>, <span class="string">&#x27;ET1354&#x27;</span>, <span class="string">&#x27;ET1420&#x27;</span>, <span class="string">&#x27;ET2154&#x27;</span>, <span class="string">&#x27;ET1515&#x27;</span>, <span class="string">&#x27;ET1506&#x27;</span>, <span class="string">&#x27;ET2577&#x27;</span>, <span class="string">&#x27;ET1681&#x27;</span>, <span class="string">&#x27;ET1585&#x27;</span>, <span class="string">&#x27;ET1518&#x27;</span>, <span class="string">&#x27;ET1906&#x27;</span>)</span><br><span class="line">replicate_filenames = example_sample_annotation %&gt;% filter(MS_batch %in% <span class="built_in">c</span>(<span class="string">&#x27;Batch_2&#x27;</span>, <span class="string">&#x27;Batch_3&#x27;</span>)) %&gt;% filter(EarTag %in% earTags) %&gt;% pull(!!sym(<span class="string">&#x27;FullRunName&#x27;</span>))</span><br><span class="line"><span class="comment"># plot the ‘exploratory’ correlation matrix, which can be further beautified</span></span><br><span class="line">p1_exp = plot_sample_corr_heatmap(log_transformed_matrix, samples_to_plot = replicate_filenames, plot_title = <span class="string">&#x27;Correlation of selected samples&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># To ensure the color scale for correlation is consistent between two plots, we create a color vector and breaks</span></span><br><span class="line">breaksList &lt;- seq(<span class="number">0.7</span>, <span class="number">1</span>, by = <span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># color scale of pheatmap</span></span><br><span class="line">heatmap_colors = colorRampPalette(rev(RColorBrewer::brewer.pal(n = <span class="number">7</span>, name = <span class="string">&#x27;RdYlBu&#x27;</span>)))(<span class="built_in">length</span>(breaksList) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the heatmap with annotations for the chosen samples</span></span><br><span class="line">factors_to_show = <span class="built_in">c</span>(batch_col, biospecimen_id_col)</span><br><span class="line">p1 = plot_sample_corr_heatmap(log_transformed_matrix, samples_to_plot = replicate_filenames,sample_annotation = example_sample_annotation, factors_to_plot = factors_to_show, plot_title = <span class="string">&#x27;Log transformed correlation matrix of selected replicated samples&#x27;</span>, color_list = color_list, heatmap_color = heatmap_colors, breaks = breaksList, cluster_rows= <span class="literal">FALSE</span>, cluster_cols=<span class="literal">FALSE</span>,fontsize = <span class="number">4</span>, annotation_names_col = <span class="literal">TRUE</span>, annotation_legend = <span class="literal">FALSE</span>, show_colnames = <span class="literal">FALSE</span>)</span><br><span class="line">p2 = plot_sample_corr_heatmap(batch_corrected_matrix, samples_to_plot = replicate_filenames, sample_annotation = example_sample_annotation, factors_to_plot = factors_to_show, plot_title = <span class="string">&#x27;Batch Corrected selected replicated samples&#x27;</span>, color_list = color_list, heatmap_color = heatmap_colors, breaks = breaksList, cluster_rows= <span class="literal">FALSE</span>, cluster_cols=<span class="literal">FALSE</span>,fontsize = <span class="number">4</span>, annotation_names_col = <span class="literal">TRUE</span>, annotation_legend = <span class="literal">FALSE</span>, show_colnames = <span class="literal">FALSE</span>)</span><br><span class="line">library(gridExtra)</span><br><span class="line">grid.arrange(grobs = <span class="built_in">list</span>(p1$gtable, p2$gtable), ncol=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>由于缺失值的存在，直接使用包中函数进行这一步骤失败，自己写代码代替。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(pheatmap)</span><br><span class="line"><span class="comment"># 计算样本间的相关性</span></span><br><span class="line"><span class="comment"># completel.obs: 计算所有样本间overlap的部分，如果某一行有缺失值则这一行不加入计算</span></span><br><span class="line">mcor &lt;- cor(select_replicate_samples, method = <span class="string">&#x27;pearson&#x27;</span>, use = <span class="string">&quot;complete.obs&quot;</span>)</span><br><span class="line">pheatmap(mcor, cellwidth = <span class="number">25</span>, cellheight = <span class="number">25</span>, color = colorRampPalette(<span class="built_in">c</span>(<span class="string">&quot;#ffffff&quot;</span>, <span class="string">&quot;#4682b4&quot;</span>))(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Correlation-distribution-of-samples"><a href="#Correlation-distribution-of-samples" class="headerlink" title="Correlation distribution of samples"></a>Correlation distribution of samples</h4><p>绘制相同或不同批次的生物重复和非生物重复之间的相关分布。<br>样本相关性的比较不应该通过评估重复组内与批次内校正的单个例子来进行，而应该通过比较分布来进行。除非这些例子是在整个分布结构的背景下显示的，否则它们会导致错误的结论。样品相关性经常被用来证明测量的质量，因为它通常是非常高的(重复组相关性超过0.95的例子在质谱分析中很常见)。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">sample_cor_raw &lt;- plot_sample_corr_distribution(log_transformed_matrix, example_sample_annotation,repeated_samples = replicate_filenames, batch_col = <span class="string">&#x27;MS_batch&#x27;</span>, biospecimen_id_col = <span class="string">&#x27;EarTag&#x27;</span>, plot_title = <span class="string">&#x27;Correlation of samples (raw)&#x27;</span>, plot_param = <span class="string">&#x27;batch_replicate&#x27;</span>)</span><br><span class="line">raw_corr = sample_cor_raw + theme(axis.text.x = element_text(angle = <span class="number">45</span>, hjust = <span class="number">1</span>)) + ylim(<span class="number">0.7</span>,<span class="number">1</span>) + xlab(<span class="literal">NULL</span>)</span><br><span class="line">sample_cor_batchCor &lt;- plot_sample_corr_distribution(batch_corrected_matrix, example_sample_annotation, batch_col = <span class="string">&#x27;MS_batch&#x27;</span>, plot_title = <span class="string">&#x27;Batch corrected&#x27;</span>, plot_param = <span class="string">&#x27;batch_replicate&#x27;</span>)</span><br><span class="line">corr_corr = sample_cor_batchCor + theme(axis.text.x = element_text(angle = <span class="number">45</span>, hjust = <span class="number">1</span>)) + ylim(<span class="number">0.7</span>, <span class="number">1</span>) + xlab(<span class="literal">NULL</span>)</span><br><span class="line">library(gtable)</span><br><span class="line">library(grid)</span><br><span class="line">g2 &lt;- ggplotGrob(raw_corr)</span><br><span class="line">g3 &lt;- ggplotGrob(corr_corr)</span><br><span class="line">g &lt;- cbind(g2, g3, size = <span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">grid.draw(g)</span><br></pre></td></tr></table></figure>

<h4 id="Correlation-of-peptide-distributions-within-and-between-proteins"><a href="#Correlation-of-peptide-distributions-within-and-between-proteins" class="headerlink" title="Correlation of peptide distributions within and between proteins"></a>Correlation of peptide distributions within and between proteins</h4><p>来自同一蛋白的肽段之间会有更强的相关性，通过计算蛋白内和蛋白间肽段的相关性观察批次效应处理结果。<br>这一步骤对计算的要求较高，且数据量大时耗时较长。建议使用性能较好的电脑进行这一步骤的计算。  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">peptide_cor_raw &lt;- plot_peptide_corr_distribution(log_transformed_matrix, example_peptide_annotation, protein_col = <span class="string">&#x27;Gene&#x27;</span>, plot_title = <span class="string">&#x27;Peptide correlation (raw)&#x27;</span>)</span><br><span class="line">peptide_cor_batchCor &lt;- plot_peptide_corr_distribution(batch_corrected_matrix, example_peptide_annotation, protein_col = <span class="string">&#x27;Gene&#x27;</span>, plot_title = <span class="string">&#x27;Peptide correlation (batch correcte)&#x27;</span>)</span><br><span class="line">g2 &lt;- ggplotGrob(peptide_cor_raw+ ylim(<span class="built_in">c</span>(-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">g3 &lt;- ggplotGrob(peptide_cor_batchCor+ ylim(<span class="built_in">c</span>(-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">g &lt;- cbind(g2, g3, size = <span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">grid.draw(g)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://www.bioconductor.org/packages/release/bioc/manuals/proBatch/man/proBatch.pdf">proBatch Manual</a><br>[2] <a href="http://www.bioconductor.org/packages/release/bioc/vignettes/proBatch/inst/doc/proBatch.pdf">proBatch Overview</a>  </p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>proBatch</category>
      </categories>
      <tags>
        <tag>Rpackage</tag>
        <tag>BatchEffect</tag>
      </tags>
  </entry>
  <entry>
    <title>当你有两台电脑都需要用 ssh-key 登录到服务器</title>
    <url>/2023/03/30/sshkey2vps/</url>
    <content><![CDATA[<center> 为服务器添加一台通过 ssh-key 登录的电脑 </center>
<span id="more"></span>

<br>

<h2 id="生成-ssh-key"><a href="#生成-ssh-key" class="headerlink" title="生成 ssh-key"></a>生成 ssh-key</h2><p>首先查看电脑当前用户的目录下是否存在.ssh目录，以及目录中是否存在<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。如果存在，公钥即为<code>id_rsa.pub</code>中的内容。如果不存在，则输入命令：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “your email or other message”</span><br></pre></td></tr></table></figure>

<p>一路回车，直到生成一个矩形的图案为止，生成的这串字符就是后面需要的公钥。  </p>
<h2 id="配置-ssh-key"><a href="#配置-ssh-key" class="headerlink" title="配置 ssh-key"></a>配置 ssh-key</h2><p>利用能够登录到服务器的电脑连接到服务器，在 <code>~/.ssh/</code> 文件夹下新建文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano ~/.ssh/authorized_keys2</span><br></pre></td></tr></table></figure>

<p>将刚才生成的公钥粘贴进去。<br>修改 sshd 的相关配置，给新公钥授权。打开配置文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>找到 <code>AuthorizedKeysFile</code> 行，取消行首的 <code>#</code> 注释。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Expect .ssh/authorized_keys2 to be disregarded by default in future.</span><br><span class="line">AuthorizedKeysFile      .ssh/authorized_keys .ssh/authorized_keys2</span><br></pre></td></tr></table></figure>

<p>重启 sshd：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<h2 id="新电脑登录"><a href="#新电脑登录" class="headerlink" title="新电脑登录"></a>新电脑登录</h2><p>使用 MobaXterm 登录，勾选 <code>Use private key</code> 并指定私钥文件。<br>具体步骤为： <code>Session -&gt; SSH -&gt; Use private key and specify a private key for passwordless login</code>。<br>设置完成后即可顺利登录。  </p>
]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>sshkey</tag>
      </tags>
  </entry>
  <entry>
    <title>过程坎坷崩溃但至少递签了</title>
    <url>/2023/03/10/visa/</url>
    <content><![CDATA[<center> 是谁又被德国人逼疯了？是我啊，那没事了 </center>
<span id="more"></span>

<br>

<p>就像标题说的那样，过程坎坷崩溃，但总算递签了。看过很多人的经验，依然准备不好自己的材料，所以还是把这次递签经历写一写，顺便水一篇博客。如果你想看看我参考过的攻略：<a href="https://zhuanlan.zhihu.com/p/213775517?utm_id=0#">超详细德国留学上海递签攻略</a>。<br>现在回想整个过程，最有用的经验大概是能早办就早办、尽量不要拖和染了头也可以拍递签照片、递签。<del>撒，下面的废话可以不看了！</del>  </p>
<p>由于之前参加过上海审核部的 APS 面审，只能在审核部递签。上海审核部也给出了很详细的递签流程和材料参考：<a href="https://www.aps.org.cn/zh/shanghai-visum">上海审核部递签</a> 和材料相关提示：<a href="https://www.aps.org.cn/wp-content/uploads/WichtigeHinweise_Visumantrag_SH_chn.pdf">上海留学签证特别提示</a>。<br>撒，开始分享经验吧！  </p>
<h2 id="预约递签时间"><a href="#预约递签时间" class="headerlink" title="预约递签时间"></a>预约递签时间</h2><p>上海审核部递签需要至少提前一周预约，经过 APS 的属于一般国内申请人（C程序），每周可约的时间只有周一、周二和周四。我预约的时候要求发送姓名、审核号、希望递签日期，并附件发送德方高校录取通知书和经济来源证明，目前官网的要求又更新为姓名、审核号、希望递签日期，并附件发送经济来源证明。<br>预约时注意到底需要提供什么信息，收件人注意把地址中的 [at] 改为@，即 <a href="mailto:&#115;&#x68;&#x61;&#x2d;&#118;&#x69;&#115;&#x75;&#x6d;&#116;&#x65;&#114;&#x6d;&#x69;&#110;&#64;&#97;&#112;&#115;&#46;&#111;&#x72;&#103;&#x2e;&#99;&#x6e;">&#115;&#x68;&#x61;&#x2d;&#118;&#x69;&#115;&#x75;&#x6d;&#116;&#x65;&#114;&#x6d;&#x69;&#110;&#64;&#97;&#112;&#115;&#46;&#111;&#x72;&#103;&#x2e;&#99;&#x6e;</a>。  </p>
<p>由于审核部递签办公室只在上午上班，周一下午发邮件约时间，周二上午收到回复，问是否仍在校。在校生根据学校所在地划分辖区，非在校生需另外提交常住证明一类的东西。我的情况稍微有些复杂，已经向学校递交了退学材料，但学校完全没动静。回邮件说正在办退学，问是否需要证明常住地。然后，又超过办公时间了！上午十一点说下班就下班，绝对不多办公一秒！我也想要这样的工作。下午打电话问学校退学证明什么时候给，得到的回复很模糊，只有 “应该很快”。决定打个时间差，趁着学校各系统没有同步，直接办个在读证明。周三上午收到邮件问通过在读证明递签还是退学证明，回复用在读。没多久就收到预约成功的邮件和递签相关提示信息，顺利约到下一周周二递签。<br>建议能用在读证明还是用在读证明来申请签证，不能的话记得发送常住地证明。我没有用这个所以不知道需要什么证明，可以直接发邮件问。  </p>
<h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><p>所有材料一定要按照<a href="https://www.aps.org.cn/wp-content/uploads/WichtigeHinweise_Visumantrag_SH_chn.pdf">上海留学签证特别提示</a>中的顺序整理。所有材料整理好之后会是三沓，一沓原件，包括护照、照片和 VIDEX 表最后一页；两沓递签材料，包括签证申请表、复印件、翻译件等材料。  </p>
<h3 id="原件部分"><a href="#原件部分" class="headerlink" title="原件部分"></a>原件部分</h3><p>这部分材料除了护照、VIDEX 二维码和申请人联系方式附加声明都会当场返还。  </p>
<h4 id="护照"><a href="#护照" class="headerlink" title="护照"></a>护照</h4><p>这个没什么好说的，递签没有护照已经可以放弃了。  </p>
<h4 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h4><p>近六个月的小二寸照片三张，一张夹在护照照片页，另外两张贴在护照申请表上。可参考<a href="https://china.diplo.de/blob/1090226/8b25f160e56c0465aa9b5d5d19f89c4f/pdf-fotomustertafel-data.pdf">照片模板</a>，一定要注意头部比例。<br>当初拍照片时，被照相馆的人说我这个紫粉头肯定不行，让我去染一染再拍。我直接僵硬，完全没想过发色还会影响递签。找遍全网递签攻略，还真的没有任何一篇提到递签照片发色的问题。而我又因为时间比较紧张，不敢冒险，只好想办法把头发颜色变一变。纠结好久，用了一次性染发喷雾把头发喷黑，赶在照相馆下班前拍了照片。照片问题解决了，但递签当场如果发色有问题怎么办呢？理发店送了我一瓶染发喷雾，但不能带上高铁。找顺丰的快递员问，顺丰说他们也不能发喷雾，至少不对个人开放。网上买一瓶发到宾馆也不是不行，但自己喷肯定会很狼狈，后脑勺的头发照顾不到。我又去全网翻攻略，发现经过 APS 面审的人去上海审核部只是递交材料，没有面审环节，决定这发色就这样吧，不让我递签就投诉！万万没想到，递签时因为头部比例不对，当场重新出去拍照片，根本来不及再折腾发色，只好拍了一张紫粉头。想想当初因为发色崩溃但最后还是用紫粉头递签就觉得非常好笑！<br>所以全网染头递签第一人 (自封) 在此告诉大家，发色并不影响递签照片，但头部比例真的会影响！  </p>
<h4 id="VIDEX-二维码"><a href="#VIDEX-二维码" class="headerlink" title="VIDEX 二维码"></a>VIDEX 二维码</h4><p>直接参考审核部给我的邮件内容。请在<a href="https://videx.diplo.de/">该网址</a>内填写 ，请勿通过其它链接制作！填写时请注意出生地须跟护照保持一致，填写省份。另外出入境时间只能填写90天的时间。如果你和我一样非常需要有人指导每一个空都该怎么填，可以参考这篇《<a href="https://www.liudebaoxian.com/newsinfo/542777.html">最新！APS 审核部递签的 Videx 填写模板和注意事项 - 德国 TK 在线</a>》。<br>打印一定要用激光打印机！我用激光打印机打了两份，第一份就非常顺利扫码成功。  </p>
<h4 id="德国高校录取通知书或大学预备语言班报名证明"><a href="#德国高校录取通知书或大学预备语言班报名证明" class="headerlink" title="德国高校录取通知书或大学预备语言班报名证明"></a>德国高校录取通知书或大学预备语言班报名证明</h4><p>我用的 zu，直接彩打，表示这一份是原件，和另外两份材料区分开来。如果 zu 本身没有彩色，直接黑白应该就可以。  </p>
<h4 id="经济来源证明"><a href="#经济来源证明" class="headerlink" title="经济来源证明"></a>经济来源证明</h4><p>就是保证金的那个证明，也是直接彩打来表示这是原件。我用的 Expatrio 的套餐，申签险、入境后公保和保证金一套直接办完。申请很简单，十分钟搞定，也有微信客服在线答疑。但并不推荐用这个套餐，建议自己了解一下保险、保证金然后再办。  </p>
<h4 id="高中毕业证"><a href="#高中毕业证" class="headerlink" title="高中毕业证"></a>高中毕业证</h4><p>没有本科经历的人才需要，经过 APS 的人一般都不用提供。  </p>
<h4 id="中国高校在读证明-休学证明-退学证明"><a href="#中国高校在读证明-休学证明-退学证明" class="headerlink" title="中国高校在读证明/休学证明/退学证明"></a>中国高校在读证明/休学证明/退学证明</h4><p>就是这个东西折磨我好几天，最后用的在读证明递签。还是那句话，所有的证明材料能早办就早办，能用在读证明就用在读证明 (注意在读证明只在当学期有效)。不要事到临头才慌慌张张找学校，学校行政慢得要死，完全不可信！  </p>
<h4 id="本科毕业证书和学士学位证书"><a href="#本科毕业证书和学士学位证书" class="headerlink" title="本科毕业证书和学士学位证书"></a>本科毕业证书和学士学位证书</h4><p>不用带学校发的那个没屁用的硬壳子，只用带那张纸就好。  </p>
<h4 id="硕士毕业证书和硕士学位证书"><a href="#硕士毕业证书和硕士学位证书" class="headerlink" title="硕士毕业证书和硕士学位证书"></a>硕士毕业证书和硕士学位证书</h4><p>硕士如果已经毕业就带上，没有想带你也带不上。  </p>
<h4 id="入境后医疗保险证明"><a href="#入境后医疗保险证明" class="headerlink" title="入境后医疗保险证明"></a>入境后医疗保险证明</h4><p>Expatrio 的套餐包含申签险、入境后公保证明，同样彩打表示这是原件。  </p>
<h4 id="留德人员审核部的审核证书-审核证明-审核传真"><a href="#留德人员审核部的审核证书-审核证明-审核传真" class="headerlink" title="留德人员审核部的审核证书/审核证明/审核传真"></a>留德人员审核部的审核证书/审核证明/审核传真</h4><p>就是 APS 证书，当初审核部给了十份，随便带一份就好。  </p>
<h4 id="语言水平证明"><a href="#语言水平证明" class="headerlink" title="语言水平证明"></a>语言水平证明</h4><p>申请到的专业只需要英语达到 CEFR 的 B2 水平，我准备的雅思成绩单，6.5 分刚好是 B2。  </p>
<h4 id="申请人联系方式附加声明"><a href="#申请人联系方式附加声明" class="headerlink" title="申请人联系方式附加声明"></a>申请人联系方式附加声明</h4><p>从网上下载<a href="https://china.diplo.de/blob/1341728/895a5533a3c35c4fd2fbc21e92d6dfa3/pdf-formular-zusatzerklaerung-erreichbarkeit-data.pdf">表格</a>。<br>我是打印出来手写，注意中文填写，最后一页要签字。没有代办人的话，代办人信息无需填写。只需要一份，会被收走。  </p>
<h3 id="递签材料"><a href="#递签材料" class="headerlink" title="递签材料"></a>递签材料</h3><p>这一部分才是真正的递签材料，一定一定要按顺序整理出两份材料，注意不要遗漏、出错。<br>一些证书复印件和翻译件在之前 APS 申请时就办理过，所以很多都是直接用的当初的材料。如果当初多办理几份，甚至不需要再复印一遍。  </p>
<h4 id="签证申请表原件"><a href="#签证申请表原件" class="headerlink" title="签证申请表原件"></a>签证申请表原件</h4><p>从<a href="https://china.diplo.de/blob/1427944/57dfe34ea710b4f0e827bc58b6ac56ba/pdf-antrag-natvisum-data.pdf">这里</a>下载表格，可以直接电脑填了打印出来最后签字，也可以直接打印出来填写。建议用电脑填，有错误随时可以改，确认无误再打印。而手写涂改很麻烦，最好不要写写划划，但从头到尾不出错填写很难。注意出生地要和护照保持一致，写省份。第 12 项的入境时间和医保证明、VIDEX 表格入境时间一致，离境时间为完成学业的时间。<br>如果你需要参考模板，可以直接看<a href="(https://zhuanlan.zhihu.com/p/213775517?utm_id=0#)">这一篇</a>中签证申请表部分的图片，就是审核部给出的官方模板。  </p>
<h4 id="《居留法》条款告知书"><a href="#《居留法》条款告知书" class="headerlink" title="《居留法》条款告知书"></a>《居留法》条款告知书</h4><p>其实就是签证申请表那个文件的最后一页，但也可以再<a href="https://china.diplo.de/blob/2561254/5e9cccec777a2ca0b7aaa019dcd6f670/pdf-belehrung-zum-visumantrag-data.pdf">单独打印一份</a>，签名要中文加拼音。  </p>
<h4 id="入境后医疗保险证明复印件"><a href="#入境后医疗保险证明复印件" class="headerlink" title="入境后医疗保险证明复印件"></a>入境后医疗保险证明复印件</h4><p>就是前面交过的原件直接打印为黑白的，当作复印件提交。  </p>
<h4 id="保险声明"><a href="#保险声明" class="headerlink" title="保险声明"></a>保险声明</h4><p>在<a href="https://www.aps.org.cn/wp-content/uploads/Belehrung_KV.pdf">这里</a>下载。出入境日期须与签证申请表上第 12 项填写的日期一致，离境日期为实际完成学业时间，签名要中文加拼音。  </p>
<h4 id="护照照片页复印件"><a href="#护照照片页复印件" class="headerlink" title="护照照片页复印件"></a>护照照片页复印件</h4><p>注意复印照片页，要清晰。不会还没有护照吧？  </p>
<h4 id="德国高校录取通知书复印件或大学预备语言班报名证明复印件"><a href="#德国高校录取通知书复印件或大学预备语言班报名证明复印件" class="headerlink" title="德国高校录取通知书复印件或大学预备语言班报名证明复印件"></a>德国高校录取通知书复印件或大学预备语言班报名证明复印件</h4><p>直接黑白打印通知书即可。这里有个新要求：<br><em>录取通知书上需写明注册报到的时间，或者打印学校官网上相关注册时间。另外入学时间紧张的同学需要跟德国高校联系最晚何时可以注册，出具证明文件或往来邮件放在两份材料里。若已经成功注册，请提供两份注册证明/在读证明。</em><br>FU 的 zu 上有邮寄注册时间，因此我打印了和学校沟通的邮件 (表明已经收到材料正在处理中)、application portal 显示 “Request for enrollment in progress” 的状态截图和学校的 academic calendar。应该不需要全部打印，但保险起见就全部打印了，收材料的姐姐全部都收走了。<br>打印沟通邮件和 academic calendar 的方式是直接在网页空白处右键 -&gt; 打印/print -&gt; 打印为 pdf -&gt; 保存。打印 application portal 用这个方法无法显示部分内容，所以用了截图。academic calendar 最终效果如下：  </p>
<p><img src="/2023/03/10/visa/academiccalendar.png">  </p>
<h4 id="经济来源证明复印件"><a href="#经济来源证明复印件" class="headerlink" title="经济来源证明复印件"></a>经济来源证明复印件</h4><p>黑白打印保证金账户证明。  </p>
<h4 id="语言水平证明复印件"><a href="#语言水平证明复印件" class="headerlink" title="语言水平证明复印件"></a>语言水平证明复印件</h4><p>雅思成绩单复印件。这里也有新增要求：<br><em>明确大学授课语言和要求达到的语言级别的说明（录取通知书、考试规定或大学的确认书），以及与入学要求相符的语言水平证明或在德国报考且符合录取通知书上要求的语言级别考试证明及已就读的语言班证明。</em><br>因此打印了学校专业介绍页面的申请要求，其中注明了英语成绩要达到 CEFR 的 B2 水平 (you are required to prove English language skills at level B2 of the Common European Framework of Reference for Languages (CEFR))。打印方式是直接在网页空白处右键 -&gt; 打印/print -&gt; 打印为 pdf -&gt; 保存。最终效果如下：  </p>
<p><img src="/2023/03/10/visa/FUenglish.png">  </p>
<h4 id="高中毕业证书复印件，并附德文或英文翻译"><a href="#高中毕业证书复印件，并附德文或英文翻译" class="headerlink" title="高中毕业证书复印件，并附德文或英文翻译"></a>高中毕业证书复印件，并附德文或英文翻译</h4><p>不适用，不用管。  </p>
<h4 id="中国高校在读证明-休学证明-退学证明的复印件，并附德文或英文翻译"><a href="#中国高校在读证明-休学证明-退学证明的复印件，并附德文或英文翻译" class="headerlink" title="中国高校在读证明/休学证明/退学证明的复印件，并附德文或英文翻译"></a>中国高校在读证明/休学证明/退学证明的复印件，并附德文或英文翻译</h4><p>翻译件可以自己翻译，不需要学校盖章或公正。如果学校能翻就让学校翻译一下盖章，不行的话就找模板自己翻。<br>注意在读证明只在当学期有效，如果过期一定要及时重新办理，不要盲目相信学校的办事效率。  </p>
<h4 id="本科毕业证书和本科学位证书的复印件，并附德文或英文翻译"><a href="#本科毕业证书和本科学位证书的复印件，并附德文或英文翻译" class="headerlink" title="本科毕业证书和本科学位证书的复印件，并附德文或英文翻译"></a>本科毕业证书和本科学位证书的复印件，并附德文或英文翻译</h4><p>同上，翻译无需盖章或公正，学校提供就用学校的翻译件，学校不提供就自己翻译。  </p>
<h4 id="硕士毕业证书和硕士学位证书的复印件，并附德文或英文翻译"><a href="#硕士毕业证书和硕士学位证书的复印件，并附德文或英文翻译" class="headerlink" title="硕士毕业证书和硕士学位证书的复印件，并附德文或英文翻译"></a>硕士毕业证书和硕士学位证书的复印件，并附德文或英文翻译</h4><p>没有毕业证，不适用，不管。如果有，翻译件准备同上。  </p>
<h4 id="德文或英文个人简历-至今为止无间断经历"><a href="#德文或英文个人简历-至今为止无间断经历" class="headerlink" title="德文或英文个人简历 (至今为止无间断经历)"></a>德文或英文个人简历 (至今为止无间断经历)</h4><p>可以找模板，也可也自己做一个表格式简历，一页，含有从小学开始的学习、工作经历即可。  </p>
<h4 id="德文或英文留学动机说明"><a href="#德文或英文留学动机说明" class="headerlink" title="德文或英文留学动机说明"></a>德文或英文留学动机说明</h4><p>可以找模板但不要太套路，可以写留学原因、求学计划和毕业后规划。1-2 页内容即可，写多了也行。可打印可手写，但都要记得在结尾签名，中文加拼音。  </p>
<h4 id="德国户籍登记机构的注销证明"><a href="#德国户籍登记机构的注销证明" class="headerlink" title="德国户籍登记机构的注销证明"></a>德国户籍登记机构的注销证明</h4><p>这个的适用条件是 “如果此前的德国长期签证过期未超过 6 个月”，一般没在德国长期呆过都不用管这一项。  </p>
<h4 id="留德人员审核部审核证书-审核证明-审核传真的复印件"><a href="#留德人员审核部审核证书-审核证明-审核传真的复印件" class="headerlink" title="留德人员审核部审核证书/审核证明/审核传真的复印件"></a>留德人员审核部审核证书/审核证明/审核传真的复印件</h4><p>APS 证书复印件。  </p>
<p>上述签证材料都直接整理为顺序正确的两沓，递交前可以找人帮忙一起对一遍顺序并检查一下所有的签名是否已经签上。</p>
<h3 id="其它准备"><a href="#其它准备" class="headerlink" title="其它准备"></a>其它准备</h3><p>所有材料都建议多打两份，空白不用写内容，以便签证材料出问题时当场重填提交。<br>带有银联标志的银行卡，卡内至少有六百块用于交签证费。<br>签证等候室有曲别针、胶棒和笔，如材料有问题，可当场重新整理、填写。自己想带也可以，但材料已经很重了，没必要带现场会有的东西。  </p>
<h2 id="递签"><a href="#递签" class="headerlink" title="递签"></a>递签</h2><h3 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h3><p>住在之前 APS 面审时住的如家，即如家上海新国际博览中心张江高科地铁站店，和德国中心同在科苑路，步行前往德国中心只需要十分钟。如家住宿水平也就普普通通，但因为八点半就要到达递签，住得近挺好的。<br>从如家前往德国中心的路上有一家打印店，在德国中心斜对面，早上八点开门。如果有材料没有打印好，可以在这里打印。签证照片如果不合格也可以在这里当场重拍，再返回德国中心递交。打印店老板已经习惯于给递签的同学打材料、拍照片，很多东西比递签的同学还熟悉，应该可以放心。当然，最好还是提前已经准备好所有东西，这里只能用于应急。  </p>
<h3 id="递交材料"><a href="#递交材料" class="headerlink" title="递交材料"></a>递交材料</h3><p>当天递签的人只有三个，剩下的都是 APS 面审的同学。会先叫递签的人进入等候室，等设备调试完毕才叫大家逐个递签。<br>递签不用取号，顺序全靠自觉排队。当天因为人少，算不上排队，我们三个很自觉地根据到场时间递签。等候室会有关于材料的广播，这时可以对材料做最后的检查。墙上也有各种材料的填写模板，自己比对模板查看材料有无问题。桌子上有曲别针、胶棒和笔，如材料有问题，可当场重新整理、填写。  </p>
<p>进入递签室要报姓名和审核号，方便确认当天是否有预约以及确认到场。审核号记不住可以用笔记在不用的纸上，报完审核号收起来就行，后面在缴费单上签字也需要审核号。<br>递签先要把护照、VIDEX 二维码和所有原件递交。查看后留下护照、二维码和申请人联系方式附加声明其余原件归还。<br>接下来递交复印件，收材料的姐姐会检查所有文件顺序和一些关键的空是否有误，补充材料中用铅笔画出重点，比如注册时间和语言要求这些信息。不知道可不可以自己画，如果要自己画，也建议用铅笔。<br>然后录指纹，先右手除大拇指以外四指、左手四指、双手拇指。我一直在出汗，录指纹的仪器上全是我的汗，中间换手还抽了张台面上的纸擦了一下。<br>接着填写快递单，旁边有参考模板，根据模板填写即可。填写完毕后，会给一张底单，所以不用自己记录单号。<br>最后交签证费，递签当天的签证费是 555 元人民币。直接刷卡，在单子上签字。递签结束，可以离开。  </p>
<p>如果顺利的话，单人的整个流程大概也就十分钟。即使中间遇到材料有问题也不要慌张，只要能在 11 点以前回来重新递交即可。我中间因为照片不合格跑出去重新拍照一次 (就在前面提到的那家打印店重新拍照)，最后结束才十点半。  </p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>整个过程非常非常焦虑，材料搞得我好几次垂死病中惊坐起发现材料有问题。很多时候都在想如果能早点开始准备就好了，但时间不能倒流，只能硬着头皮继续。不管怎么样，总算是硬着头皮准备好材料递签了，接下来在家睡大觉等签证。<br>希望一切顺利！  </p>
<h2 id="签证到手！"><a href="#签证到手！" class="headerlink" title="签证到手！"></a>签证到手！</h2><p>整整四个周后，收到快递信息，顺利拿到签证！  </p>
]]></content>
      <categories>
        <category>runrunrun</category>
      </categories>
      <tags>
        <tag>Visa</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Markdown写博客</title>
    <url>/2021/09/16/writenewblog/</url>
    <content><![CDATA[<center>创建、发布新文章；用vscode + markdown编辑文章；给文章添加分类和标签。</center>
<span id="more"></span>

<br>

<h2 id="新建文章-create-a-post"><a href="#新建文章-create-a-post" class="headerlink" title="新建文章 create a post"></a>新建文章 create a post</h2><p>在博客目录运行命令：</p>
<pre><code>$ hexo new [layout] title
# layout有三种:post, draft, page, 默认是post，可以在博客配置文件中更改default_layout来更改默认设置
# Hexo会根据scaffolds文件夹内相对应的文件来建立md文件
# 当创建不同布局的md文件时，它们会存储在不同路径

$ hexo new &quot;My New Post&quot;
#新建一个名为&quot;My New Post&quot;的md文件
</code></pre>
<p>后续编辑这个文件即可。</p>
<h2 id="vscode-markdown写文章"><a href="#vscode-markdown写文章" class="headerlink" title="vscode + markdown写文章"></a>vscode + markdown写文章</h2><p>可按照以下步骤编辑一遍博客文章：</p>
<ol>
<li>从<a href="https://code.visualstudio.com/">官网</a>下载vscode，并安装。  </li>
<li>安装markdown插件：<ul>
<li>Markdown All in One: 组合包，把最常用的Markdown优化全部装好</li>
<li>Markdown Preview Github Styling: 在本地就能预览Markdown文件最终在Github Pages中显示的效果</li>
</ul>
</li>
<li>学习基本的markdown语法，利用vscode编辑文章。同时，利用”Open Preview to the Side”按键或快捷键可同时预览文章</li>
<li>写完这篇文章</li>
</ol>
<h2 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h2><h3 id="生成categories页并修改type属性"><a href="#生成categories页并修改type属性" class="headerlink" title="生成categories页并修改type属性"></a>生成categories页并修改type属性</h3><p>在博客目录运行命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>运行成功后会提示：</p>
<pre><code>INFO  Created: ~/Documents/blog/source/categories/index.md
</code></pre>
<p>根据所给路径找到index.md文件，在文件的框架内添加一行：</p>
<pre><code>type: &quot;categories&quot;
</code></pre>
<h3 id="给文章添加categories"><a href="#给文章添加categories" class="headerlink" title="给文章添加categories"></a>给文章添加categories</h3><p>在文章头的<code>categories:</code>后以<code>-</code>为标志添加标签，如本文的标签：</p>
<pre><code>categories:
- Blog #注意“-”后一定要加空格
</code></pre>
<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><h3 id="生成tag页并修改type属性"><a href="#生成tag页并修改type属性" class="headerlink" title="生成tag页并修改type属性"></a>生成tag页并修改type属性</h3><p>在博客目录运行命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>运行成功后会提示：</p>
<pre><code>INFO  Created: ~/Documents/blog/source/tags/index.md
</code></pre>
<p>根据所给路径找到index.md文件，在文件的框架内添加一行：</p>
<pre><code>type: &quot;tags&quot;
</code></pre>
<h3 id="给文章添加tag"><a href="#给文章添加tag" class="headerlink" title="给文章添加tag"></a>给文章添加tag</h3><p>在文章头的<code>tags:</code>后以<code>-</code>为标志添加标签，如本文的标签：</p>
<pre><code>tags: 
- Blog #注意“-”后一定要加空格
- Hexo
- Markdown
- vscode
</code></pre>
<h2 id="文章的发布"><a href="#文章的发布" class="headerlink" title="文章的发布"></a>文章的发布</h2><p>在博客目录运行命令：</p>
<pre><code>$ hexo generate
$ hexo server  # 本地预查看
$ hexo deploy  # 部署到GitHub Pages

# 此步骤报错可先检查文件头等文章各部分是否缺少空格
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/156915260">Hexo博客写文章及基本操作</a></li>
<li><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo使用攻略-添加分类及标签</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/56943330">[Markdown] 使用vscode开始Markdown写作之旅</a></li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Markdown</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
